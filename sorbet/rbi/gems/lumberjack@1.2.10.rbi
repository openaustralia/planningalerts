# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `lumberjack` gem.
# Please instead update this file by running `bin/tapioca gem lumberjack`.


module ActiveSupport::TaggedLogging
  include ::Lumberjack::TaggedLogging
  extend ::Lumberjack::TaggedLogging::ClassMethods
end

# source://lumberjack//lib/lumberjack.rb#9
module Lumberjack
  class << self
    # Contexts can be used to store tags that will be attached to all log entries in the block.
    #
    # If this method is called with a block, it will set a logging context for the scope of a block.
    # If there is already a context in scope, a new one will be created that inherits
    # all the tags of the parent context.
    #
    # Otherwise, it will return the current context. If one doesn't exist, it will return a new one
    # but that context will not be in any scope.
    #
    # @return [Lumberjack::Context] The current context if called without a block.
    #
    # source://lumberjack//lib/lumberjack.rb#64
    def context(&block); end

    # Return true if inside a context block.
    #
    # @return [Boolean]
    #
    # source://lumberjack//lib/lumberjack.rb#90
    def context?; end

    # Return the tags from the current context or nil if there are no tags.
    #
    # @return [Hash, nil]
    #
    # source://lumberjack//lib/lumberjack.rb#97
    def context_tags; end

    # Set tags on the current context
    #
    # @param tags [Hash] The tags to set.
    # @return [void]
    #
    # source://lumberjack//lib/lumberjack.rb#106
    def tag(tags); end

    # Define a unit of work within a block. Within the block supplied to this
    # method, calling +unit_of_work_id+ will return the same value that can
    # This can then be used for tying together log entries.
    #
    # You can specify the id for the unit of work if desired. If you don't supply
    # it, a 12 digit hexidecimal number will be automatically generated for you.
    #
    # For the common use case of treating a single web request as a unit of work, see the
    # Lumberjack::Rack::UnitOfWork class.
    #
    # @param id [String] The id for the unit of work.
    # @return [void]
    #
    # source://lumberjack//lib/lumberjack.rb#39
    def unit_of_work(id = T.unsafe(nil)); end

    # Get the UniqueIdentifier for the current unit of work.
    #
    # @return [String, nil] The id for the current unit of work.
    #
    # source://lumberjack//lib/lumberjack.rb#50
    def unit_of_work_id; end

    # Set the context to use within a block.
    #
    # @param context [Lumberjack::Context] The context to use within the block.
    # @return [Object] The result of the block.
    #
    # source://lumberjack//lib/lumberjack.rb#77
    def use_context(context, &block); end
  end
end

# A context is used to store tags that are then added to all log entries within a block.
#
# source://lumberjack//lib/lumberjack/context.rb#5
class Lumberjack::Context
  # @param parent_context [Context] A parent context to inherit tags from.
  # @return [Context] a new instance of Context
  #
  # source://lumberjack//lib/lumberjack/context.rb#9
  def initialize(parent_context = T.unsafe(nil)); end

  # Get a context tag.
  #
  # @param key [String, Symbol] The tag key.
  # @return [Object] The tag value.
  #
  # source://lumberjack//lib/lumberjack/context.rb#28
  def [](key); end

  # Set a context tag.
  #
  # @param key [String, Symbol] The tag key.
  # @param value [Object] The tag value.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/context.rb#37
  def []=(key, value); end

  # Clear all the context data.
  #
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/context.rb#44
  def reset; end

  # Set tags on the context.
  #
  # @param tags [Hash] The tags to set.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/context.rb#18
  def tag(tags); end

  # Returns the value of attribute tags.
  #
  # source://lumberjack//lib/lumberjack/context.rb#6
  def tags; end
end

# This is an abstract class for logging devices. Subclasses must implement the +write+ method and
# may implement the +close+ and +flush+ methods if applicable.
#
# source://lumberjack//lib/lumberjack/device.rb#6
class Lumberjack::Device
  # source://lumberjack//lib/lumberjack/device/rolling_log_file.rb#110
  def cleanup_files!; end

  # Subclasses may implement this method to close the device.
  #
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/device.rb#26
  def close; end

  # Subclasses may implement this method to get the format for log timestamps.
  #
  # @return [String] The format for log timestamps.
  #
  # source://lumberjack//lib/lumberjack/device.rb#47
  def datetime_format; end

  # Subclasses may implement this method to set a format for log timestamps.
  #
  # @param format [String] The format for log timestamps.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/device.rb#54
  def datetime_format=(format); end

  # source://lumberjack//lib/lumberjack/device/rolling_log_file.rb#121
  def do_once(file); end

  # Subclasses may implement this method to flush any buffers used by the device.
  #
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/device.rb#41
  def flush; end

  # Subclasses may implement this method to reopen the device.
  #
  # @param logdev [Object] The log device to use.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/device.rb#34
  def reopen(logdev = T.unsafe(nil)); end

  # Subclasses must implement this method to write a LogEntry.
  #
  # @param entry [Lumberjack::LogEntry] The entry to write.
  # @raise [NotImplementedError]
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/device.rb#19
  def write(entry); end
end

# This log device will append entries to a file and roll the file periodically by date. Files
# are rolled at midnight and can be rolled daily, weekly, or monthly. Archive file names will
# have the date appended to them in the format ".YYYY-MM-DD" for daily, ".week-of-YYYY-MM-DD" for weekly
# and ".YYYY-MM" for monthly. It is not guaranteed that log messages will break exactly on the
# roll period as buffered entries will always be written to the same file.
#
# source://lumberjack//lib/lumberjack/device/date_rolling_log_file.rb#12
class Lumberjack::Device::DateRollingLogFile < ::Lumberjack::Device::RollingLogFile
  # Create a new logging device to the specified file. The period to roll the file is specified
  # with the :roll option which may contain a value of :daily, :weekly,
  # or :monthly.
  #
  # @param path [String, Pathname] The path to the log file.
  # @param options [Hash] The options for the device.
  # @return [DateRollingLogFile] a new instance of DateRollingLogFile
  #
  # source://lumberjack//lib/lumberjack/device/date_rolling_log_file.rb#19
  def initialize(path, options = T.unsafe(nil)); end

  # The date based suffix for file.
  #
  # @return [String]
  #
  # source://lumberjack//lib/lumberjack/device/date_rolling_log_file.rb#34
  def archive_file_suffix; end

  # Check if the file should be rolled.
  #
  # @return [Boolean]
  #
  # source://lumberjack//lib/lumberjack/device/date_rolling_log_file.rb#48
  def roll_file?; end

  protected

  # source://lumberjack//lib/lumberjack/device/date_rolling_log_file.rb#69
  def after_roll; end
end

# This is a logging device that appends log entries to a file.
#
# source://lumberjack//lib/lumberjack/device/log_file.rb#8
class Lumberjack::Device::LogFile < ::Lumberjack::Device::Writer
  # Create a logger to the file at +path+. Options are passed through to the Writer constructor.
  #
  # @param path [String, Pathname] The path to the log file.
  # @param options [Hash] The options for the device.
  # @return [LogFile] a new instance of LogFile
  #
  # source://lumberjack//lib/lumberjack/device/log_file.rb#18
  def initialize(path, options = T.unsafe(nil)); end

  # The absolute path of the file being logged to.
  #
  # source://lumberjack//lib/lumberjack/device/log_file.rb#12
  def path; end

  # Reopen the log file.
  #
  # @param logdev [Object] not used
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/device/log_file.rb#28
  def reopen(logdev = T.unsafe(nil)); end

  private

  # source://lumberjack//lib/lumberjack/device/log_file.rb#35
  def file_stream; end
end

# source://lumberjack//lib/lumberjack/device/log_file.rb#9
Lumberjack::Device::LogFile::EXTERNAL_ENCODING = T.let(T.unsafe(nil), String)

# This is a logging device that forward log entries to multiple other devices.
#
# source://lumberjack//lib/lumberjack/device/multi.rb#6
class Lumberjack::Device::Multi < ::Lumberjack::Device
  # @param devices [Array<Lumberjack::Device>] The devices to write to.
  # @return [Multi] a new instance of Multi
  #
  # source://lumberjack//lib/lumberjack/device/multi.rb#8
  def initialize(*devices); end

  # source://lumberjack//lib/lumberjack/device/multi.rb#24
  def close; end

  # source://lumberjack//lib/lumberjack/device/multi.rb#36
  def datetime_format; end

  # source://lumberjack//lib/lumberjack/device/multi.rb#40
  def datetime_format=(format); end

  # source://lumberjack//lib/lumberjack/device/multi.rb#18
  def flush; end

  # source://lumberjack//lib/lumberjack/device/multi.rb#30
  def reopen(logdev = T.unsafe(nil)); end

  # source://lumberjack//lib/lumberjack/device/multi.rb#12
  def write(entry); end
end

# This is a logging device that produces no output. It can be useful in
# testing environments when log file output is not useful.
#
# source://lumberjack//lib/lumberjack/device/null.rb#7
class Lumberjack::Device::Null < ::Lumberjack::Device
  # @return [Null] a new instance of Null
  #
  # source://lumberjack//lib/lumberjack/device/null.rb#8
  def initialize(*args); end

  # source://lumberjack//lib/lumberjack/device/null.rb#11
  def write(entry); end
end

# This is an abstract class for a device that appends entries to a file and periodically archives
# the existing file and starts a one. Subclasses must implement the roll_file? and archive_file_suffix
# methods.
#
# The :keep option can be used to specify a maximum number of rolled log files to keep.
# Older files will be deleted based on the time they were created. The default is to keep all files.
#
# The :min_roll_check option can be used to specify the number of seconds between checking
# the file to determine if it needs to be rolled. The default is to check at most once per second.
#
# source://lumberjack//lib/lumberjack/device/rolling_log_file.rb#14
class Lumberjack::Device::RollingLogFile < ::Lumberjack::Device::LogFile
  # @return [RollingLogFile] a new instance of RollingLogFile
  #
  # source://lumberjack//lib/lumberjack/device/rolling_log_file.rb#18
  def initialize(path, options = T.unsafe(nil)); end

  # Returns a suffix that will be appended to the file name when it is archived.. The suffix should
  # change after it is time to roll the file. The log file will be renamed when it is rolled.
  #
  # @raise [NotImplementedError]
  #
  # source://lumberjack//lib/lumberjack/device/rolling_log_file.rb#34
  def archive_file_suffix; end

  # Returns the value of attribute keep.
  #
  # source://lumberjack//lib/lumberjack/device/rolling_log_file.rb#16
  def keep; end

  # Sets the attribute keep
  #
  # @param value the value to set the attribute keep to.
  #
  # source://lumberjack//lib/lumberjack/device/rolling_log_file.rb#16
  def keep=(_arg0); end

  # Returns the value of attribute path.
  #
  # source://lumberjack//lib/lumberjack/device/rolling_log_file.rb#15
  def path; end

  # Roll the log file by renaming it to the archive file name and then re-opening a stream to the log
  # file path. Rolling a file is safe in multi-threaded or multi-process environments.
  #
  # source://lumberjack//lib/lumberjack/device/rolling_log_file.rb#45
  def roll_file!; end

  # Return +true+ if the file should be rolled.
  #
  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://lumberjack//lib/lumberjack/device/rolling_log_file.rb#39
  def roll_file?; end

  protected

  # This method will be called after a file has been rolled. Subclasses can
  # implement code to reset the state of the device. This method is thread safe.
  #
  # source://lumberjack//lib/lumberjack/device/rolling_log_file.rb#73
  def after_roll; end

  # Handle rolling the file before flushing.
  #
  # source://lumberjack//lib/lumberjack/device/rolling_log_file.rb#77
  def before_flush; end

  private

  # source://lumberjack//lib/lumberjack/device/rolling_log_file.rb#96
  def reopen_file; end
end

# This is a log device that appends entries to a file and rolls the file when it reaches a specified
# size threshold. When a file is rolled, it will have an number extension appended to the file name.
# For example, if the log file is named production.log, the first time it is rolled it will be renamed
# production.log.1, then production.log.2, etc.
#
# source://lumberjack//lib/lumberjack/device/size_rolling_log_file.rb#9
class Lumberjack::Device::SizeRollingLogFile < ::Lumberjack::Device::RollingLogFile
  # Create an new log device to the specified file. The maximum size of the log file is specified with
  # the :max_size option. The unit can also be specified: "32K", "100M", "2G" are all valid.
  #
  # @return [SizeRollingLogFile] a new instance of SizeRollingLogFile
  #
  # source://lumberjack//lib/lumberjack/device/size_rolling_log_file.rb#14
  def initialize(path, options = T.unsafe(nil)); end

  # source://lumberjack//lib/lumberjack/device/size_rolling_log_file.rb#38
  def archive_file_suffix; end

  # Returns the value of attribute max_size.
  #
  # source://lumberjack//lib/lumberjack/device/size_rolling_log_file.rb#10
  def max_size; end

  # @return [Boolean]
  #
  # source://lumberjack//lib/lumberjack/device/size_rolling_log_file.rb#42
  def roll_file?; end

  protected

  # Calculate the next archive file name extension.
  #
  # source://lumberjack//lib/lumberjack/device/size_rolling_log_file.rb#51
  def next_archive_number; end
end

# This logging device writes log entries as strings to an IO stream. By default, messages will be buffered
# and written to the stream in a batch when the buffer is full or when +flush+ is called.
#
# Subclasses can implement a +before_flush+ method if they have logic to execute before flushing the log.
# If it is implemented, it will be called before every flush inside a mutex lock.
#
# source://lumberjack//lib/lumberjack/device/writer.rb#10
class Lumberjack::Device::Writer < ::Lumberjack::Device
  # Create a new device to write log entries to a stream. Entries are converted to strings
  # using a Template. The template can be specified using the :template option. This can
  # either be a Proc or a string that will compile into a Template object.
  #
  # If the template is a Proc, it should accept an LogEntry as its only argument and output a string.
  #
  # If the template is a template string, it will be used to create a Template. The
  # :additional_lines and :time_format options will be passed through to the
  # Template constuctor.
  #
  # The default template is "[:time :severity :progname(:pid) #:unit_of_work_id] :message"
  # with additional lines formatted as "\n [#:unit_of_work_id] :message". The unit of
  # work id will only appear if it is present.
  #
  # The size of the internal buffer in bytes can be set by providing :buffer_size (defaults to 32K).
  #
  # @param stream [IO] The stream to write log entries to.
  # @param options [Hash] The options for the device.
  # @return [Writer] a new instance of Writer
  #
  # source://lumberjack//lib/lumberjack/device/writer.rb#66
  def initialize(stream, options = T.unsafe(nil)); end

  # The size of the internal buffer. Defaults to 32K.
  #
  # source://lumberjack//lib/lumberjack/device/writer.rb#15
  def buffer_size; end

  # Set the buffer size in bytes. The device will only be physically written to when the buffer size
  # is exceeded.
  #
  # @param value [Integer] The size of the buffer in bytes.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/device/writer.rb#86
  def buffer_size=(value); end

  # Close the underlying stream.
  #
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/device/writer.rb#119
  def close; end

  # Get the datetime format.
  #
  # @return [String] The datetime format.
  #
  # source://lumberjack//lib/lumberjack/device/writer.rb#139
  def datetime_format; end

  # Set the datetime format.
  #
  # @param format [String] The datetime format.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/device/writer.rb#147
  def datetime_format=(format); end

  # Flush the underlying stream.
  #
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/device/writer.rb#127
  def flush; end

  # Write an entry to the stream. The entry will be converted into a string using the defined template.
  #
  # @param entry [LogEntry, String] The entry to write to the stream.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/device/writer.rb#95
  def write(entry); end

  protected

  # Get the underlying stream.
  #
  # source://lumberjack//lib/lumberjack/device/writer.rb#159
  def stream; end

  # Set the underlying stream.
  #
  # source://lumberjack//lib/lumberjack/device/writer.rb#156
  def stream=(_arg0); end

  private

  # source://lumberjack//lib/lumberjack/device/writer.rb#163
  def write_to_stream(lines); end
end

# Internal buffer to batch writes to the stream.
#
# source://lumberjack//lib/lumberjack/device/writer.rb#18
class Lumberjack::Device::Writer::Buffer
  # @return [Buffer] a new instance of Buffer
  #
  # source://lumberjack//lib/lumberjack/device/writer.rb#21
  def initialize; end

  # source://lumberjack//lib/lumberjack/device/writer.rb#26
  def <<(string); end

  # source://lumberjack//lib/lumberjack/device/writer.rb#42
  def clear; end

  # @return [Boolean]
  #
  # source://lumberjack//lib/lumberjack/device/writer.rb#31
  def empty?; end

  # source://lumberjack//lib/lumberjack/device/writer.rb#35
  def pop!; end

  # source://lumberjack//lib/lumberjack/device/writer.rb#19
  def size; end
end

# source://lumberjack//lib/lumberjack/device/writer.rb#12
Lumberjack::Device::Writer::DEFAULT_ADDITIONAL_LINES_TEMPLATE = T.let(T.unsafe(nil), String)

# source://lumberjack//lib/lumberjack/device/writer.rb#11
Lumberjack::Device::Writer::DEFAULT_FIRST_LINE_TEMPLATE = T.let(T.unsafe(nil), String)

# This class controls the conversion of log entry messages into a loggable format. This allows you
# to log any object you want and have the logging system deal with converting it into a string.
#
# Formats are added to a Formatter by associating them with a class using the +add+ method. Formats
# are any object that responds to the +call+ method.
#
# By default, all object will be converted to strings using their inspect method except for Strings
# and Exceptions. Strings are not converted and Exceptions are converted using the ExceptionFormatter.
#
# Enumerable objects (including Hash and Array) will call the formatter recursively for each element.
#
# source://lumberjack//lib/lumberjack/formatter.rb#14
class Lumberjack::Formatter
  # @return [Formatter] a new instance of Formatter
  #
  # source://lumberjack//lib/lumberjack/formatter.rb#37
  def initialize; end

  # Add a formatter for a class. The formatter can be specified as either an object
  # that responds to the +call+ method or as a symbol representing one of the predefined
  # formatters, or as a block to the method call.
  #
  # The predefined formatters are:
  #   - :date_time
  #   - :exception
  #   - :id
  #   - :inspect
  #   - :object
  #   - :pretty_print
  #   - :string
  #   - :strip
  #   - :structured
  #   - :truncate
  #
  # You can add multiple classes at once by passing an array of classes.
  #
  # You can also pass class names as strings instead of the classes themselves. This can
  # help avoid loading dependency issues. This applies only to classes; modules cannot be
  # passed in as strings.
  #
  # @example
  #
  #   # Use a predefined formatter
  #   formatter.add(MyClass, :pretty_print)
  #
  #   # Pass in a formatter object
  #   formatter.add(MyClass, Lumberjack::Formatter::PrettyPrintFormatter.new)
  #
  #   # Use a block
  #   formatter.add(MyClass){|obj| obj.humanize}
  #
  #   # Add statements can be chained together
  #   formatter.add(MyClass, :pretty_print).add(YourClass){|obj| obj.humanize}
  # @param klass [Class, Module, String, Array<Class, Module, String>] The class or module to add a formatter for.
  # @param formatter [Symbol, Class, String, #call] The formatter to use for the class.
  #   If a symbol is passed in, it will be used to load one of the predefined formatters.
  #   If a class is passed in, it will be initialized with the args passed in.
  #   Otherwise, the object will be used as the formatter and must respond to call method.
  # @param args [Array] Arguments to pass to the formatter when it is initialized.
  # @return [self] Returns itself so that add statements can be chained together.
  # @yield [obj] A block that will be used as the formatter for the class.
  # @yieldparam obj [Object] The object to format.
  # @yieldreturn [String] The formatted string.
  #
  # source://lumberjack//lib/lumberjack/formatter.rb#93
  def add(klass, formatter = T.unsafe(nil), *args, &block); end

  # Compatibility with the Logger::Formatter signature. This method will just convert the message
  # object to a string and ignores the other parameters.
  #
  # @param severity [Integer, String, Symbol] The severity of the message.
  # @param timestamp [Time] The time the message was logged.
  # @param progname [String] The name of the program logging the message.
  # @param msg [Object] The message object to format.
  #
  # source://lumberjack//lib/lumberjack/formatter.rb#175
  def call(severity, timestamp, progname, msg); end

  # Remove all formatters including the default formatter. Can be chained to add method calls.
  #
  # @return [self] Returns itself so that clear statements can be chained together.
  #
  # source://lumberjack//lib/lumberjack/formatter.rb#149
  def clear; end

  # Format a message object by applying all formatters attached to it.
  #
  # @param message [Object] The message object to format.
  # @return [Object] The formatted object.
  #
  # source://lumberjack//lib/lumberjack/formatter.rb#159
  def format(message); end

  # Remove the formatter associated with a class. Remove statements can be chained together.
  #
  # You can remove multiple classes at once by passing an array of classes.
  #
  # You can also pass class names as strings instead of the classes themselves. This can
  # help avoid loading dependency issues. This applies only to classes; modules cannot be
  # passed in as strings.
  #
  # @param klass [Class, Module, String, Array<Class, Module, String>] The class or module to remove the formatters for.
  # @return [self] Returns itself so that remove statements can be chained together.
  #
  # source://lumberjack//lib/lumberjack/formatter.rb#134
  def remove(klass); end

  private

  # Find the formatter for a class by looking it up using the class hierarchy.
  #
  # source://lumberjack//lib/lumberjack/formatter.rb#182
  def formatter_for(klass); end

  class << self
    # Returns a new empty formatter with no mapping. For historical reasons, a formatter
    # is initialized with mappings to help output objects as strings. This will return one
    # without the default mappings.
    #
    # @return [Lumberjack::Formatter] a new empty formatter
    #
    # source://lumberjack//lib/lumberjack/formatter.rb#32
    def empty; end
  end
end

# Format a Date, Time, or DateTime object. If you don't specify a format in the constructor,
# it will use the ISO-8601 format.
#
# source://lumberjack//lib/lumberjack/formatter/date_time_formatter.rb#7
class Lumberjack::Formatter::DateTimeFormatter
  # @param format [String] The format to use when formatting the date/time object.
  # @return [DateTimeFormatter] a new instance of DateTimeFormatter
  #
  # source://lumberjack//lib/lumberjack/formatter/date_time_formatter.rb#11
  def initialize(format = T.unsafe(nil)); end

  # source://lumberjack//lib/lumberjack/formatter/date_time_formatter.rb#15
  def call(obj); end

  # Returns the value of attribute format.
  #
  # source://lumberjack//lib/lumberjack/formatter/date_time_formatter.rb#8
  def format; end
end

# Format an exception including the backtrace. You can specify an object that
# responds to `call` as a backtrace cleaner. The exception backtrace will be
# passed to this object and the returned array is what will be logged. You can
# use this to clean out superfluous lines.
#
# source://lumberjack//lib/lumberjack/formatter/exception_formatter.rb#9
class Lumberjack::Formatter::ExceptionFormatter
  # @param backtrace_cleaner [#call] An object that responds to `call` and takes
  #   an array of strings (the backtrace) and returns an array of strings (the
  # @return [ExceptionFormatter] a new instance of ExceptionFormatter
  #
  # source://lumberjack//lib/lumberjack/formatter/exception_formatter.rb#14
  def initialize(backtrace_cleaner = T.unsafe(nil)); end

  # Returns the value of attribute backtrace_cleaner.
  #
  # source://lumberjack//lib/lumberjack/formatter/exception_formatter.rb#10
  def backtrace_cleaner; end

  # Sets the attribute backtrace_cleaner
  #
  # @param value the value to set the attribute backtrace_cleaner to.
  #
  # source://lumberjack//lib/lumberjack/formatter/exception_formatter.rb#10
  def backtrace_cleaner=(_arg0); end

  # source://lumberjack//lib/lumberjack/formatter/exception_formatter.rb#18
  def call(exception); end

  private

  # source://lumberjack//lib/lumberjack/formatter/exception_formatter.rb#30
  def clean_backtrace(trace); end
end

# Format an object that has an id as a hash with keys for class and id. This formatter is useful
# as a default formatter for objects pulled from a data store. By default it will use :id as the
# id attribute.
#
# source://lumberjack//lib/lumberjack/formatter/id_formatter.rb#8
class Lumberjack::Formatter::IdFormatter
  # @param id_attribute [Symbol, String] The attribute to use as the id.
  # @return [IdFormatter] a new instance of IdFormatter
  #
  # source://lumberjack//lib/lumberjack/formatter/id_formatter.rb#10
  def initialize(id_attribute = T.unsafe(nil)); end

  # source://lumberjack//lib/lumberjack/formatter/id_formatter.rb#14
  def call(obj); end
end

# Format an object by calling +inspect+ on it.
#
# source://lumberjack//lib/lumberjack/formatter/inspect_formatter.rb#6
class Lumberjack::Formatter::InspectFormatter
  # source://lumberjack//lib/lumberjack/formatter/inspect_formatter.rb#7
  def call(obj); end
end

# No-op formatter that just returns the object itself.
#
# source://lumberjack//lib/lumberjack/formatter/object_formatter.rb#6
class Lumberjack::Formatter::ObjectFormatter
  # source://lumberjack//lib/lumberjack/formatter/object_formatter.rb#7
  def call(obj); end
end

# Format an object with it's pretty print method.
#
# source://lumberjack//lib/lumberjack/formatter/pretty_print_formatter.rb#9
class Lumberjack::Formatter::PrettyPrintFormatter
  # Create a new formatter. The maximum width of the message can be specified with the width
  # parameter (defaults to 79 characters).
  #
  # @param width [Integer] The maximum width of the message.
  # @return [PrettyPrintFormatter] a new instance of PrettyPrintFormatter
  #
  # source://lumberjack//lib/lumberjack/formatter/pretty_print_formatter.rb#16
  def initialize(width = T.unsafe(nil)); end

  # source://lumberjack//lib/lumberjack/formatter/pretty_print_formatter.rb#20
  def call(obj); end

  # Returns the value of attribute width.
  #
  # source://lumberjack//lib/lumberjack/formatter/pretty_print_formatter.rb#10
  def width; end

  # Sets the attribute width
  #
  # @param value the value to set the attribute width to.
  #
  # source://lumberjack//lib/lumberjack/formatter/pretty_print_formatter.rb#10
  def width=(_arg0); end
end

# Format an object by calling `to_s` on it.
#
# source://lumberjack//lib/lumberjack/formatter/string_formatter.rb#6
class Lumberjack::Formatter::StringFormatter
  # source://lumberjack//lib/lumberjack/formatter/string_formatter.rb#7
  def call(obj); end
end

# Format an object by calling `to_s` on it and stripping leading and trailing whitespace.
#
# source://lumberjack//lib/lumberjack/formatter/strip_formatter.rb#6
class Lumberjack::Formatter::StripFormatter
  # source://lumberjack//lib/lumberjack/formatter/strip_formatter.rb#7
  def call(obj); end
end

# Dereference arrays and hashes and recursively call formatters on each element.
#
# source://lumberjack//lib/lumberjack/formatter/structured_formatter.rb#8
class Lumberjack::Formatter::StructuredFormatter
  # @param formatter [Formatter] The formatter to call on each element
  #   in the structure.
  # @return [StructuredFormatter] a new instance of StructuredFormatter
  #
  # source://lumberjack//lib/lumberjack/formatter/structured_formatter.rb#14
  def initialize(formatter = T.unsafe(nil)); end

  # source://lumberjack//lib/lumberjack/formatter/structured_formatter.rb#18
  def call(obj); end

  private

  # source://lumberjack//lib/lumberjack/formatter/structured_formatter.rb#24
  def call_with_references(obj, references); end

  # source://lumberjack//lib/lumberjack/formatter/structured_formatter.rb#50
  def with_object_reference(obj, references); end
end

# source://lumberjack//lib/lumberjack/formatter/structured_formatter.rb#9
class Lumberjack::Formatter::StructuredFormatter::RecusiveReferenceError < ::StandardError; end

# Truncate a string object to a specific length. This is useful
# for formatting messages when there is a limit on the number of
# characters that can be logged per message. This formatter should
# only be used when necessary since it is a lossy formatter.
#
# When a string is truncated, it will have a unicode ellipsis
# character (U+2026) appended to the end of the string.
#
# source://lumberjack//lib/lumberjack/formatter/truncate_formatter.rb#12
class Lumberjack::Formatter::TruncateFormatter
  # @param length [Integer] The maximum length of the string (defaults to 32K)
  # @return [TruncateFormatter] a new instance of TruncateFormatter
  #
  # source://lumberjack//lib/lumberjack/formatter/truncate_formatter.rb#14
  def initialize(length = T.unsafe(nil)); end

  # source://lumberjack//lib/lumberjack/formatter/truncate_formatter.rb#18
  def call(obj); end
end

# source://lumberjack//lib/lumberjack.rb#10
Lumberjack::LINE_SEPARATOR = T.let(T.unsafe(nil), String)

# An entry in a log is a data structure that captures the log message as well as
# information about the system that logged the message.
#
# source://lumberjack//lib/lumberjack/log_entry.rb#6
class Lumberjack::LogEntry
  # Create a new log entry.
  #
  # @param time [Time] The time the log entry was created.
  # @param severity [Integer, String] The severity of the log entry.
  # @param message [String] The message to log.
  # @param progname [String] The name of the program that created the log entry.
  # @param pid [Integer] The process id of the program that created the log entry.
  # @param tags [Hash] A hash of tags to associate with the log entry.
  # @return [LogEntry] a new instance of LogEntry
  #
  # source://lumberjack//lib/lumberjack/log_entry.rb#21
  def initialize(time, severity, message, progname, pid, tags); end

  # source://lumberjack//lib/lumberjack/log_entry.rb#43
  def inspect; end

  # Returns the value of attribute message.
  #
  # source://lumberjack//lib/lumberjack/log_entry.rb#7
  def message; end

  # Sets the attribute message
  #
  # @param value the value to set the attribute message to.
  #
  # source://lumberjack//lib/lumberjack/log_entry.rb#7
  def message=(_arg0); end

  # Returns the value of attribute pid.
  #
  # source://lumberjack//lib/lumberjack/log_entry.rb#7
  def pid; end

  # Sets the attribute pid
  #
  # @param value the value to set the attribute pid to.
  #
  # source://lumberjack//lib/lumberjack/log_entry.rb#7
  def pid=(_arg0); end

  # Returns the value of attribute progname.
  #
  # source://lumberjack//lib/lumberjack/log_entry.rb#7
  def progname; end

  # Sets the attribute progname
  #
  # @param value the value to set the attribute progname to.
  #
  # source://lumberjack//lib/lumberjack/log_entry.rb#7
  def progname=(_arg0); end

  # Returns the value of attribute severity.
  #
  # source://lumberjack//lib/lumberjack/log_entry.rb#7
  def severity; end

  # Sets the attribute severity
  #
  # @param value the value to set the attribute severity to.
  #
  # source://lumberjack//lib/lumberjack/log_entry.rb#7
  def severity=(_arg0); end

  # source://lumberjack//lib/lumberjack/log_entry.rb#35
  def severity_label; end

  # Return the tag with the specified name.
  #
  # source://lumberjack//lib/lumberjack/log_entry.rb#62
  def tag(name); end

  # Returns the value of attribute tags.
  #
  # source://lumberjack//lib/lumberjack/log_entry.rb#7
  def tags; end

  # Sets the attribute tags
  #
  # @param value the value to set the attribute tags to.
  #
  # source://lumberjack//lib/lumberjack/log_entry.rb#7
  def tags=(_arg0); end

  # Returns the value of attribute time.
  #
  # source://lumberjack//lib/lumberjack/log_entry.rb#7
  def time; end

  # Sets the attribute time
  #
  # @param value the value to set the attribute time to.
  #
  # source://lumberjack//lib/lumberjack/log_entry.rb#7
  def time=(_arg0); end

  # source://lumberjack//lib/lumberjack/log_entry.rb#39
  def to_s; end

  # Deprecated - backward compatibility with 1.0 API
  #
  # source://lumberjack//lib/lumberjack/log_entry.rb#48
  def unit_of_work_id; end

  # Deprecated - backward compatibility with 1.0 API
  #
  # source://lumberjack//lib/lumberjack/log_entry.rb#53
  def unit_of_work_id=(value); end

  private

  # source://lumberjack//lib/lumberjack/log_entry.rb#68
  def tags_to_s; end
end

# source://lumberjack//lib/lumberjack/log_entry.rb#9
Lumberjack::LogEntry::TIME_FORMAT = T.let(T.unsafe(nil), String)

# source://lumberjack//lib/lumberjack/log_entry.rb#11
Lumberjack::LogEntry::UNIT_OF_WORK_ID = T.let(T.unsafe(nil), String)

# Logger is a thread safe logging object. It has a compatible API with the Ruby
# standard library Logger class, the Log4r gem, and ActiveSupport::BufferedLogger.
#
# === Example
#
#   logger = Lumberjack::Logger.new
#   logger.info("Starting processing")
#   logger.debug("Processing options #{options.inspect}")
#   logger.fatal("OMG the application is on fire!")
#
# Log entries are written to a logging Device if their severity meets or exceeds the log level.
#
# Devices may use buffers internally and the log entries are not guaranteed to be written until you call
# the +flush+ method. Sometimes this can result in problems when trying to track down extraordinarily
# long running sections of code since it is likely that none of the messages logged before the long
# running code will appear in the log until the entire process finishes. You can set the +:flush_seconds+
# option on the constructor to force the device to be flushed periodically. This will create a new
# monitoring thread, but its use is highly recommended.
#
# Each log entry records the log message and severity along with the time it was logged, the
# program name, process id, and unit of work id. The message will be converted to a string, but
# otherwise, it is up to the device how these values are recorded. Messages are converted to strings
# using a Formatter associated with the logger.
#
# source://lumberjack//lib/lumberjack/logger.rb#27
class Lumberjack::Logger
  include ::Lumberjack::Severity

  # Create a new logger to log to a Device.
  #
  # The +device+ argument can be in any one of several formats.
  #
  # If it is a Device object, that object will be used.
  # If it has a +write+ method, it will be wrapped in a Device::Writer class.
  # If it is :null, it will be a Null device that won't record any output.
  # Otherwise, it will be assumed to be file path and wrapped in a Device::LogFile class.
  #
  # This method can take the following options:
  #
  # * :level - The logging level below which messages will be ignored.
  # * :formatter - The formatter to use for outputting messages to the log.
  # * :datetime_format - The format to use for log timestamps.
  # * :tag_formatter - The TagFormatter to use for formatting tags.
  # * :progname - The name of the program that will be recorded with each log entry.
  # * :flush_seconds - The maximum number of seconds between flush calls.
  # * :roll - If the log device is a file path, it will be a Device::DateRollingLogFile if this is set.
  # * :max_size - If the log device is a file path, it will be a Device::SizeRollingLogFile if this is set.
  #
  # All other options are passed to the device constuctor.
  #
  # @param device [Lumberjack::Device, Object, Symbol, String] The device to log to.
  # @param options [Hash] The options for the logger.
  # @return [Logger] a new instance of Logger
  #
  # source://lumberjack//lib/lumberjack/logger.rb#69
  def initialize(device = T.unsafe(nil), options = T.unsafe(nil)); end

  # Add a message when the severity is not known.
  #
  # @param msg [Object] The message to log.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#417
  def <<(msg); end

  # ::Logger compatible method to add a log entry.
  #
  # @param severity [Integer, Symbol, String] The severity of the message.
  # @param message [Object] The message to log.
  # @param progname [String] The name of the program that is logging the message.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#229
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # Add a message to the log with a given severity. The message can be either
  # passed in the +message+ argument or supplied with a block. This method
  # is not normally called. Instead call one of the helper functions
  # +fatal+, +error+, +warn+, +info+, or +debug+.
  #
  # The severity can be passed in either as one of the Severity constants,
  # or as a Severity label.
  #
  # @example
  #
  #   logger.add_entry(Logger::ERROR, exception)
  #   logger.add_entry(Logger::INFO, "Request completed")
  #   logger.add_entry(:warn, "Request took a long time")
  #   logger.add_entry(Logger::DEBUG){"Start processing with options #{options.inspect}"}
  # @param severity [Integer, Symbol, String] The severity of the message.
  # @param message [Object] The message to log.
  # @param progname [String] The name of the program that is logging the message.
  # @param tags [Hash] The tags to add to the log entry.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#188
  def add_entry(severity, message, progname = T.unsafe(nil), tags = T.unsafe(nil)); end

  # Close the logging device.
  #
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#255
  def close; end

  # Returns +true+ if the logging device is closed.
  #
  # @return [Boolean] +true+ if the logging device is closed.
  #
  # source://lumberjack//lib/lumberjack/logger.rb#264
  def closed?; end

  # Get the timestamp format on the device if it has one.
  #
  # @return [String, nil] The timestamp format or nil if the device doesn't support it.
  #
  # source://lumberjack//lib/lumberjack/logger.rb#91
  def datetime_format; end

  # Set the timestamp format on the device if it is supported.
  #
  # @param format [String] The timestamp format.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#99
  def datetime_format=(format); end

  # Log a +DEBUG+ message. The message can be passed in either the +message+ argument or in a block.
  #
  # @param message_or_progname_or_tags [Object] The message to log or progname
  #   if the message is passed in a block.
  # @param progname_or_tags [String, Hash] The name of the program that is logging the message or tags
  #   if the message is passed in a block.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#383
  def debug(message_or_progname_or_tags = T.unsafe(nil), progname_or_tags = T.unsafe(nil), &block); end

  # Set the log level to debug.
  #
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#397
  def debug!; end

  # Return +true+ if +DEBUG+ messages are being logged.
  #
  # @return [Boolean]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#390
  def debug?; end

  # The device being written to
  #
  # source://lumberjack//lib/lumberjack/logger.rb#40
  def device; end

  # The device being written to
  #
  # source://lumberjack//lib/lumberjack/logger.rb#40
  def device=(_arg0); end

  # Log an +ERROR+ message. The message can be passed in either the +message+ argument or in a block.
  #
  # @param message_or_progname_or_tags [Object] The message to log or progname
  #   if the message is passed in a block.
  # @param progname_or_tags [String, Hash] The name of the program that is logging the message or tags
  #   if the message is passed in a block.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#308
  def error(message_or_progname_or_tags = T.unsafe(nil), progname_or_tags = T.unsafe(nil), &block); end

  # Set the log level to error.
  #
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#322
  def error!; end

  # Return +true+ if +ERROR+ messages are being logged.
  #
  # @return [Boolean]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#315
  def error?; end

  # Log a +FATAL+ message. The message can be passed in either the +message+ argument or in a block.
  #
  # @param message_or_progname_or_tags [Object] The message to log or progname
  #   if the message is passed in a block.
  # @param progname_or_tags [String, Hash] The name of the program that is logging the message or tags
  #   if the message is passed in a block.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#283
  def fatal(message_or_progname_or_tags = T.unsafe(nil), progname_or_tags = T.unsafe(nil), &block); end

  # Set the log level to fatal.
  #
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#297
  def fatal!; end

  # Return +true+ if +FATAL+ messages are being logged.
  #
  # @return [Boolean]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#290
  def fatal?; end

  # Flush the logging device. Messages are not guaranteed to be written until this method is called.
  #
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#246
  def flush; end

  # Get the Lumberjack::Formatter used to format objects for logging as messages.
  #
  # @return [Lumberjack::Formatter] The formatter.
  #
  # source://lumberjack//lib/lumberjack/logger.rb#145
  def formatter; end

  # Set the Lumberjack::Formatter used to format objects for logging as messages.
  #
  # @param value [Lumberjack::Formatter, Object] The formatter to use.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#138
  def formatter=(value); end

  # Log an +INFO+ message. The message can be passed in either the +message+ argument or in a block.
  #
  # @param message_or_progname_or_tags [Object] The message to log or progname
  #   if the message is passed in a block.
  # @param progname_or_tags [String] The name of the program that is logging the message or tags
  #   if the message is passed in a block.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#358
  def info(message_or_progname_or_tags = T.unsafe(nil), progname_or_tags = T.unsafe(nil), &block); end

  # Set the log level to info.
  #
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#372
  def info!; end

  # Return +true+ if +INFO+ messages are being logged.
  #
  # @return [Boolean]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#365
  def info?; end

  # The time that the device was last flushed.
  #
  # source://lumberjack//lib/lumberjack/logger.rb#31
  def last_flushed_at; end

  # Get the level of severity of entries that are logged. Entries with a lower
  # severity level will be ignored.
  #
  # @return [Integer] The severity level.
  #
  # source://lumberjack//lib/lumberjack/logger.rb#109
  def level; end

  # Set the log level using either an integer level like Logger::INFO or a label like
  # :info or "info"
  #
  # @param value [Integer, Symbol, String] The severity level.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#120
  def level=(value); end

  # ::Logger compatible method to add a log entry.
  #
  # @param severity [Integer, Symbol, String] The severity of the message.
  # @param message [Object] The message to log.
  # @param progname [String] The name of the program that is logging the message.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#229
  def log(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # Get the program name associated with log messages.
  #
  # @return [String]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#460
  def progname; end

  # Set the name of the program to attach to log entries.
  #
  # source://lumberjack//lib/lumberjack/logger.rb#37
  def progname=(_arg0); end

  # Remove a tag from the current tag context. If this is called inside a block to a
  # call to `tag`, the tags will only be removed for the duration of that block. Otherwise
  # they will be removed from the global tags.
  #
  # @param tag_names [Array<String, Symbol>] The tags to remove.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#493
  def remove_tag(*tag_names); end

  # Reopen the logging device.
  #
  # @param logdev [Object] passed through to the logging device.
  #
  # source://lumberjack//lib/lumberjack/logger.rb#271
  def reopen(logdev = T.unsafe(nil)); end

  # Set the program name that is associated with log messages. If a block
  # is given, the program name will be valid only within the block.
  #
  # @param value [String] The program name to use.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#449
  def set_progname(value, &block); end

  # Get the level of severity of entries that are logged. Entries with a lower
  # severity level will be ignored.
  #
  # @return [Integer] The severity level.
  #
  # source://lumberjack//lib/lumberjack/logger.rb#109
  def sev_threshold; end

  # Set the log level using either an integer level like Logger::INFO or a label like
  # :info or "info"
  #
  # @param value [Integer, Symbol, String] The severity level.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#120
  def sev_threshold=(value); end

  # Silence the logger by setting a new log level inside a block. By default, only +ERROR+ or +FATAL+
  # messages will be logged.
  #
  # @example
  #
  #   logger.level = Logger::INFO
  #   logger.silence do
  #   do_something   # Log level inside the block is +ERROR+
  #   end
  # @param temporary_level [Integer, String, Symbol] The log level to use inside the block.
  # @return [Object] The result of the block.
  #
  # source://lumberjack//lib/lumberjack/logger.rb#433
  def silence(temporary_level = T.unsafe(nil), &block); end

  # Set +silencer+ to false to disable silencing the log.
  #
  # source://lumberjack//lib/lumberjack/logger.rb#34
  def silencer; end

  # Set +silencer+ to false to disable silencing the log.
  #
  # source://lumberjack//lib/lumberjack/logger.rb#34
  def silencer=(_arg0); end

  # Set a hash of tags on logger. If a block is given, the tags will only be set
  # for the duration of the block. If this method is called inside such a block,
  # the tags will only be defined on the tags in that block. When the parent block
  # exits, all the tags will be reverted. If there is no block, then the tags will
  # be defined as global and apply to all log statements.
  #
  # @param tags [Hash] The tags to set.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#472
  def tag(tags, &block); end

  # The TagFormatter used for formatting tags for output
  #
  # source://lumberjack//lib/lumberjack/logger.rb#43
  def tag_formatter; end

  # The TagFormatter used for formatting tags for output
  #
  # source://lumberjack//lib/lumberjack/logger.rb#43
  def tag_formatter=(_arg0); end

  # Enable this logger to function like an ActiveSupport::TaggedLogger. This will make the logger
  # API compatible with ActiveSupport::TaggedLogger and is provided as a means of compatibility
  # with other libraries that assume they can call the `tagged` method on a logger to add tags.
  #
  # The tags added with this method are just strings so they are stored in the logger tags
  # in an array under the "tagged" tag. So calling `logger.tagged("foo", "bar")` will result
  # in tags `{"tagged" => ["foo", "bar"]}`.
  #
  # @return [Lumberjack::Logger] self.
  #
  # source://lumberjack//lib/lumberjack/logger.rb#163
  def tagged_logger!; end

  # Return all tags in scope on the logger including global tags set on the Lumberjack
  # context, tags set on the logger, and tags set on the current block for the logger.
  #
  # @return [Hash]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#506
  def tags; end

  # Log a message when the severity is not known. Unknown messages will always appear in the log.
  # The message can be passed in either the +message+ argument or in a block.
  #
  # @param message_or_progname_or_tags [Object] The message to log or progname
  #   if the message is passed in a block.
  # @param progname_or_tags [String, Hash] The name of the program that is logging the message or tags
  #   if the message is passed in a block.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#409
  def unknown(message_or_progname_or_tags = T.unsafe(nil), progname_or_tags = T.unsafe(nil), &block); end

  # Remove all tags on the current logger and logging context within a block.
  # You can still set new block scoped tags within theuntagged block and provide
  # tags on individual log methods.
  #
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#521
  def untagged(&block); end

  # Log a +WARN+ message. The message can be passed in either the +message+ argument or in a block.
  #
  # @param message_or_progname_or_tags [Object] The message to log or progname
  #   if the message is passed in a block.
  # @param progname_or_tags [String, Hash] The name of the program that is logging the message or tags
  #   if the message is passed in a block.
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#333
  def warn(message_or_progname_or_tags = T.unsafe(nil), progname_or_tags = T.unsafe(nil), &block); end

  # Set the log level to warn.
  #
  # @return [void]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#347
  def warn!; end

  # Return +true+ if +WARN+ messages are being logged.
  #
  # @return [Boolean]
  #
  # source://lumberjack//lib/lumberjack/logger.rb#340
  def warn?; end

  # Adjust the log level during the block execution for the current Fiber only.
  #
  # @param severity [Integer, Symbol, String] The severity level.
  # @return [Object] The result of the block.
  #
  # source://lumberjack//lib/lumberjack/logger.rb#130
  def with_level(severity, &block); end

  private

  # Dereference arguments to log calls so we can have methods with compatibility with ::Logger
  #
  # source://lumberjack//lib/lumberjack/logger.rb#539
  def call_add_entry(severity, message_or_progname_or_tags, progname_or_tags, &block); end

  # Create a thread that will periodically call flush.
  #
  # source://lumberjack//lib/lumberjack/logger.rb#627
  def create_flusher_thread(flush_seconds); end

  # Open a logging device.
  #
  # source://lumberjack//lib/lumberjack/logger.rb#596
  def open_device(device, options); end

  # Set a local value for a thread tied to this object within a block.
  #
  # source://lumberjack//lib/lumberjack/logger.rb#585
  def push_thread_local_value(name, value); end

  # Set a local value for a thread tied to this object.
  #
  # source://lumberjack//lib/lumberjack/logger.rb#564
  def set_thread_local_value(name, value); end

  # Get a local value for a thread tied to this object.
  #
  # source://lumberjack//lib/lumberjack/logger.rb#579
  def thread_local_value(name); end

  # source://lumberjack//lib/lumberjack/logger.rb#617
  def write_to_device(entry); end
end

# source://lumberjack//lib/lumberjack/rack.rb#4
module Lumberjack::Rack; end

# Middleware to create a global context for Lumberjack for the scope of a rack request.
#
# source://lumberjack//lib/lumberjack/rack/context.rb#6
class Lumberjack::Rack::Context
  # @return [Context] a new instance of Context
  #
  # source://lumberjack//lib/lumberjack/rack/context.rb#7
  def initialize(app); end

  # source://lumberjack//lib/lumberjack/rack/context.rb#11
  def call(env); end
end

# Support for using the Rails ActionDispatch request id in the log.
# The format is expected to be a random UUID and only the first chunk is used for terseness
# if the abbreviated argument is true.
#
# source://lumberjack//lib/lumberjack/rack/request_id.rb#8
class Lumberjack::Rack::RequestId
  # @return [RequestId] a new instance of RequestId
  #
  # source://lumberjack//lib/lumberjack/rack/request_id.rb#11
  def initialize(app, abbreviated = T.unsafe(nil)); end

  # source://lumberjack//lib/lumberjack/rack/request_id.rb#16
  def call(env); end
end

# source://lumberjack//lib/lumberjack/rack/request_id.rb#9
Lumberjack::Rack::RequestId::REQUEST_ID = T.let(T.unsafe(nil), String)

# source://lumberjack//lib/lumberjack/rack/unit_of_work.rb#5
class Lumberjack::Rack::UnitOfWork
  # @return [UnitOfWork] a new instance of UnitOfWork
  #
  # source://lumberjack//lib/lumberjack/rack/unit_of_work.rb#6
  def initialize(app); end

  # source://lumberjack//lib/lumberjack/rack/unit_of_work.rb#10
  def call(env); end
end

# The standard severity levels for logging messages.
#
# source://lumberjack//lib/lumberjack/severity.rb#5
module Lumberjack::Severity
  class << self
    # Coerce a value to a severity level.
    #
    # @param value [Integer, String, Symbol] The value to coerce.
    # @return [Integer] The severity level.
    #
    # source://lumberjack//lib/lumberjack/severity.rb#37
    def coerce(value); end

    # Convert a severity label to a level.
    #
    # @param label [String, Symbol] The severity label to convert.
    # @return [Integer] The severity level.
    #
    # source://lumberjack//lib/lumberjack/severity.rb#29
    def label_to_level(label); end

    # Convert a severity level to a label.
    #
    # @param severity [Integer] The severity level to convert.
    # @return [String] The severity label.
    #
    # source://lumberjack//lib/lumberjack/severity.rb#21
    def level_to_label(severity); end
  end
end

# Backward compatibilty with 1.0 API
#
# source://lumberjack//lib/lumberjack/severity.rb#7
Lumberjack::Severity::DEBUG = T.let(T.unsafe(nil), Integer)

# source://lumberjack//lib/lumberjack/severity.rb#10
Lumberjack::Severity::ERROR = T.let(T.unsafe(nil), Integer)

# source://lumberjack//lib/lumberjack/severity.rb#11
Lumberjack::Severity::FATAL = T.let(T.unsafe(nil), Integer)

# source://lumberjack//lib/lumberjack/severity.rb#8
Lumberjack::Severity::INFO = T.let(T.unsafe(nil), Integer)

# source://lumberjack//lib/lumberjack/severity.rb#14
Lumberjack::Severity::SEVERITY_LABELS = T.let(T.unsafe(nil), Array)

# source://lumberjack//lib/lumberjack/severity.rb#12
Lumberjack::Severity::UNKNOWN = T.let(T.unsafe(nil), Integer)

# source://lumberjack//lib/lumberjack/severity.rb#9
Lumberjack::Severity::WARN = T.let(T.unsafe(nil), Integer)

# Class for formatting tags. You can register a default formatter and tag
# name specific formatters. Formatters can be either `Lumberjack::Formatter`
# objects or any object that responds to `call`.
#
# tag_formatter = Lumberjack::TagFormatter.new.default(Lumberjack::Formatter.new)
# tag_formatter.add(["password", "email"]) { |value| "***" }
# tag_formatter.add("finished_at", Lumberjack::Formatter::DateTimeFormatter.new("%Y-%m-%dT%H:%m:%S%z"))
#
# source://lumberjack//lib/lumberjack/tag_formatter.rb#11
class Lumberjack::TagFormatter
  # @return [TagFormatter] a new instance of TagFormatter
  #
  # source://lumberjack//lib/lumberjack/tag_formatter.rb#12
  def initialize; end

  # Add a formatter for specific tag names. This can either be a Lumberjack::Formatter
  # or an object that responds to `call` or a block. The default formatter will not be
  # applied.
  #
  # @param names [String, Array<String>] The tag names to apply the formatter to.
  # @param formatter [Lumberjack::Formatter, #call, nil] The formatter to use.
  #   If this is nil, then the block will be used as the formatter.
  # @return [Lumberjack::TagFormatter] self
  #
  # source://lumberjack//lib/lumberjack/tag_formatter.rb#46
  def add(names, formatter = T.unsafe(nil), &block); end

  # Remove all formatters.
  #
  # @return [Lumberjack::TagFormatter] self
  #
  # source://lumberjack//lib/lumberjack/tag_formatter.rb#73
  def clear; end

  # Add a default formatter applied to all tag values. This can either be a Lumberjack::Formatter
  # or an object that responds to `call` or a block.
  #
  # @param formatter [Lumberjack::Formatter, #call, nil] The formatter to use.
  #   If this is nil, then the block will be used as the formatter.
  # @return [Lumberjack::TagFormatter] self
  #
  # source://lumberjack//lib/lumberjack/tag_formatter.rb#23
  def default(formatter = T.unsafe(nil), &block); end

  # Format a hash of tags using the formatters
  #
  # @param tags [Hash] The tags to format.
  # @return [Hash] The formatted tags.
  #
  # source://lumberjack//lib/lumberjack/tag_formatter.rb#83
  def format(tags); end

  # Remove formatters for specific tag names. The default formatter will still be applied.
  #
  # @param names [String, Array<String>] The tag names to remove the formatter from.
  # @return [Lumberjack::TagFormatter] self
  #
  # source://lumberjack//lib/lumberjack/tag_formatter.rb#63
  def remove(names); end

  # Remove the default formatter.
  #
  # @return [Lumberjack::TagFormatter] self
  #
  # source://lumberjack//lib/lumberjack/tag_formatter.rb#33
  def remove_default; end

  private

  # source://lumberjack//lib/lumberjack/tag_formatter.rb#104
  def dereference_formatter(formatter); end
end

# Methods to make Lumberjack::Logger API compatible with ActiveSupport::TaggedLogger.
#
# source://lumberjack//lib/lumberjack/tagged_logger_support.rb#8
module Lumberjack::TaggedLoggerSupport
  # source://lumberjack//lib/lumberjack/tagged_logger_support.rb#62
  def clear_tags!; end

  # source://lumberjack//lib/lumberjack/tagged_logger_support.rb#56
  def pop_tags(size = T.unsafe(nil)); end

  # source://lumberjack//lib/lumberjack/tagged_logger_support.rb#52
  def push_tags(*tags); end

  # Compatibility with ActiveSupport::TaggedLogging which only supports adding tags as strings.
  # If a tag looks like "key:value"  or "key=value", it will be added as a key value pair.
  # Otherwise it will be appended to a list named "tagged".
  #
  # source://lumberjack//lib/lumberjack/tagged_logger_support.rb#43
  def tagged(*tags, &block); end
end

# source://lumberjack//lib/lumberjack/tagged_logger_support.rb#9
class Lumberjack::TaggedLoggerSupport::Formatter
  extend ::Forwardable

  # @return [Formatter] a new instance of Formatter
  #
  # source://lumberjack//lib/lumberjack/tagged_logger_support.rb#13
  def initialize(formatter:, logger:); end

  # source://lumberjack//lib/lumberjack/tagged_logger_support.rb#35
  def __formatter; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def clear_tags!(*args, **_arg1, &block); end

  # source://lumberjack//lib/lumberjack/tagged_logger_support.rb#19
  def current_tags; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def pop_tags(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def push_tags(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def tagged(*args, **_arg1, &block); end

  # source://lumberjack//lib/lumberjack/tagged_logger_support.rb#28
  def tags_text; end
end

# Monkey patch for ActiveSupport::TaggedLogger so it doesn't blow up when
# a Lumberjack logger is trying to be wrapped. This module will be automatically
# included in ActiveSupport::TaggedLogger if activesupport is already loaded.
#
# source://lumberjack//lib/lumberjack/tagged_logging.rb#7
module Lumberjack::TaggedLogging
  mixes_in_class_methods ::Lumberjack::TaggedLogging::ClassMethods

  class << self
    # @private
    #
    # source://lumberjack//lib/lumberjack/tagged_logging.rb#9
    def included(base); end
  end
end

# source://lumberjack//lib/lumberjack/tagged_logging.rb#14
module Lumberjack::TaggedLogging::ClassMethods
  # source://lumberjack//lib/lumberjack/tagged_logging.rb#15
  def new(logger); end
end

# source://lumberjack//lib/lumberjack/tags.rb#4
class Lumberjack::Tags
  class << self
    # Ensure keys are strings and expand any values in a hash that are Proc's by calling them and replacing
    # the value with the result. This allows setting global tags with runtime values.
    #
    # @param hash [Hash] The hash to transform.
    # @return [Hash] The hash with string keys and expanded values.
    #
    # source://lumberjack//lib/lumberjack/tags.rb#31
    def expand_runtime_values(hash); end

    # Transform hash keys to strings. This method exists for optimization and backward compatibility.
    # If a hash already has string keys, it will be returned as is.
    #
    # @param hash [Hash] The hash to transform.
    # @return [Hash] The hash with string keys.
    #
    # source://lumberjack//lib/lumberjack/tags.rb#11
    def stringify_keys(hash); end
  end
end

# A template converts entries to strings. Templates can contain the following place holders to
# reference log entry values:
#
# * :time
# * :severity
# * :progname
# * :tags
# * :message
#
# Any other words prefixed with a colon will be substituted with the value of the tag with that name.
# If your tag name contains characters other than alpha numerics and the underscore, you must surround it
# with curly brackets: `:{http.request-id}`.
#
# source://lumberjack//lib/lumberjack/template.rb#16
class Lumberjack::Template
  # Create a new template from the markup. The +first_line+ argument is used to format only the first
  # line of a message. Additional lines will be added to the message unformatted. If you wish to format
  # the additional lines, use the :additional_lines options to specify a template. Note that you'll need
  # to provide the line separator character in this template if you want to keep the message on multiple lines.
  #
  # The time will be formatted as YYYY-MM-DDTHH:MM:SSS.SSS by default. If you wish to change the format, you
  # can specify the :time_format option which can be either a time format template as documented in
  # +Time#strftime+ or the values +:milliseconds+ or +:microseconds+ to use the standard format with the
  # specified precision.
  #
  # Messages will have white space stripped from both ends.
  #
  # @param first_line [String] The template to use to format the first line of a message.
  # @param options [Hash] The options for the template.
  # @return [Template] a new instance of Template
  #
  # source://lumberjack//lib/lumberjack/template.rb#36
  def initialize(first_line, options = T.unsafe(nil)); end

  # Convert an entry into a string using the template.
  #
  # @param entry [Lumberjack::LogEntry] The entry to convert to a string.
  # @return [String] The entry converted to a string.
  #
  # source://lumberjack//lib/lumberjack/template.rb#68
  def call(entry); end

  # Get the format used to format the time.
  #
  # @return [String]
  #
  # source://lumberjack//lib/lumberjack/template.rb#60
  def datetime_format; end

  # Set the format used to format the time.
  #
  # @param format [String] The format to use to format the time.
  #
  # source://lumberjack//lib/lumberjack/template.rb#48
  def datetime_format=(format); end

  private

  # Compile the template string into a value that can be used with sprintf.
  #
  # source://lumberjack//lib/lumberjack/template.rb#118
  def compile(template); end

  # source://lumberjack//lib/lumberjack/template.rb#98
  def tag_args(tags, tag_vars); end
end

# source://lumberjack//lib/lumberjack/template.rb#19
Lumberjack::Template::MICROSECOND_TIME_FORMAT = T.let(T.unsafe(nil), String)

# source://lumberjack//lib/lumberjack/template.rb#18
Lumberjack::Template::MILLISECOND_TIME_FORMAT = T.let(T.unsafe(nil), String)

# source://lumberjack//lib/lumberjack/template.rb#20
Lumberjack::Template::PLACEHOLDER_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://lumberjack//lib/lumberjack/template.rb#17
Lumberjack::Template::TEMPLATE_ARGUMENT_ORDER = T.let(T.unsafe(nil), Array)
