# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `honeybadger` gem.
# Please instead update this file by running `bin/tapioca gem honeybadger`.


# Honeybadger's public API is made up of two parts: the {Honeybadger} singleton
# module, and the {Agent} class. The singleton module delegates its methods to
# a global agent instance, {Agent#instance}; this allows methods to be accessed
# directly, for example when calling +Honeybadger.notify+:
#
#   begin
#     raise 'testing an error report'
#   rescue => err
#     Honeybadger.notify(err)
#   end
#
# Custom agents may also be created by users who want to report to multiple
# Honeybadger projects in the same app (or have fine-grained control over
# configuration), however most users will use the global agent.
#
# @see Honeybadger::Agent
#
# source://honeybadger//lib/honeybadger/version.rb#1
module Honeybadger
  extend ::Forwardable
  extend ::Honeybadger

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#add_breadcrumb
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def add_breadcrumb(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#backtrace_filter
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def backtrace_filter(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#breadcrumbs
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def breadcrumbs(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#check_in
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def check_in(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#clear!
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def clear!(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#collect
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def collect(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @api private
  # @see Agent#config
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def config(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#configure
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def configure(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#context
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def context(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#decrement_counter
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def decrement_counter(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#event
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def event(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#exception_filter
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def exception_filter(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#exception_fingerprint
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def exception_fingerprint(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#flush
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def flush(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#gauge
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def gauge(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#get_context
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def get_context(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#histogram
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def histogram(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#increment_counter
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def increment_counter(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @api private
  # @see Agent#init!
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def init!(*args, **_arg1, &block); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/singleton.rb#78
  def install_at_exit_callback; end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#instrumentation
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def instrumentation(*args, **_arg1, &block); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/singleton.rb#70
  def load_plugins!; end

  # Forwards to {Agent.instance}.
  #
  # @see Agent#notify
  #
  # source://honeybadger//lib/honeybadger/singleton.rb#63
  def notify(exception_or_opts = T.unsafe(nil), opts = T.unsafe(nil), **kwargs); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#registry
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def registry(*args, **_arg1, &block); end

  # @deprecated
  # @raise [NoMethodError]
  #
  # source://honeybadger//lib/honeybadger/singleton.rb#89
  def start(config = T.unsafe(nil)); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#stop
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def stop(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#time
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def time(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#track_deployment
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def track_deployment(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @api private
  # @see Agent#with_rack_env
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def with_rack_env(*args, **_arg1, &block); end

  private

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/singleton.rb#104
  def ignored_exception?(exception); end
end

# The Honeybadger agent contains all the methods for interacting with the
# Honeybadger service. It can be used to send notifications to multiple
# projects in large apps. The global agent instance ({Agent.instance}) should
# always be accessed through the {Honeybadger} singleton.
#
# === Context
#
# Context is global by default, meaning agents created via
# +Honeybadger::Agent.new+ will share context (added via
# +Honeybadger.context+ or {Honeybadger::Agent#context}) with other agents.
# This also includes the Rack environment when using the
# {Honeybadger::Rack::ErrorNotifier} middleware. To localize context for a
# custom agent, use the +local_context: true+ option when initializing.
#
# @example
#
#   # Standard usage:
#   OtherBadger = Honeybadger::Agent.new
#
#   # With local context:
#   OtherBadger = Honeybadger::Agent.new(local_context: true)
#
#   OtherBadger.configure do |config|
#   config.api_key = 'project api key'
#   end
#
#   begin
#   # Risky operation
#   rescue => e
#   OtherBadger.notify(e)
#   end
#
# source://honeybadger//lib/honeybadger/agent.rb#49
class Honeybadger::Agent
  include ::Honeybadger::Logging::Helper
  extend ::Forwardable

  # @return [Agent] a new instance of Agent
  #
  # source://honeybadger//lib/honeybadger/agent.rb#64
  def initialize(opts = T.unsafe(nil)); end

  # Appends a breadcrumb to the trace. Use this when you want to add some
  # custom data to your breadcrumb trace in effort to help debugging. If a
  # notice is reported to Honeybadger, all breadcrumbs within the execution
  # path will be appended to the notice. You will be able to view the
  # breadcrumb trace in the Honeybadger interface to see what events led up
  # to the notice.
  #
  # @example
  #   Honeybadger.add_breadcrumb("Email Sent", metadata: { user: user.id, message: message })
  # @option params
  # @option params
  # @param message [String] The message you want to send with the breadcrumb
  # @param params [Hash] extra options for breadcrumb building
  # @return self
  #
  # source://honeybadger//lib/honeybadger/agent.rb#318
  def add_breadcrumb(message, metadata: T.unsafe(nil), category: T.unsafe(nil)); end

  # @api private
  # @see Config#backend
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def backend(*args, **_arg1, &block); end

  # DEPRECATED: Callback to filter backtrace lines. One use for this is to make
  # additional [PROJECT_ROOT] or [GEM_ROOT] substitutions, which are used by
  # Honeybadger when grouping errors and displaying application traces.
  #
  # @example
  #   Honeybadger.backtrace_filter do |line|
  #   line.gsub(/^\/my\/unknown\/bundle\/path/, "[GEM_ROOT]")
  #   end
  # @yieldparam line [String] The backtrace line to modify.
  # @yieldreturn [String] The new (modified) backtrace line.
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def backtrace_filter(*args, **_arg1, &block); end

  # Direct access to the Breadcrumbs::Collector instance
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/agent.rb#292
  def breadcrumbs; end

  # Perform a synchronous check_in.
  #
  # @example
  #   Honeybadger.check_in('1MqIo1')
  # @param id [String] The unique check in id (e.g. '1MqIo1') or the check in url.
  # @return [Boolean] true if the check in was successful and false
  #   otherwise.
  #
  # source://honeybadger//lib/honeybadger/agent.rb#199
  def check_in(id); end

  # Clear all transaction scoped data.
  #
  # source://honeybadger//lib/honeybadger/agent.rb#274
  def clear!; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/agent.rb#425
  def collect(collector); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/agent.rb#441
  def config; end

  # Configure the Honeybadger agent via Ruby.
  #
  # @example
  #   Honeybadger.configure do |config|
  #   config.api_key = 'project api key'
  #   config.exceptions.ignore += [CustomError]
  #   end
  # @yield [Config::Ruby] configuration object.
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def configure(*args, **_arg1, &block); end

  # Save global context for the current request.
  #
  # @example
  #   Honeybadger.context({my_data: 'my value'})
  #
  #   # Inside a Rails controller:
  #   before_action do
  #   Honeybadger.context({user_id: current_user.id})
  #   end
  #
  #   # Explicit conversion
  #   class User < ActiveRecord::Base
  #   def to_honeybadger_context
  #   { user_id: id, user_email: email }
  #   end
  #   end
  #
  #   user = User.first
  #   Honeybadger.context(user)
  #
  #   # Clearing global context:
  #   Honeybadger.context.clear!
  # @option context
  # @option context
  # @option context
  # @param context [Hash] A Hash of data which will be sent to Honeybadger
  #   when an error occurs. If the object responds to +#to_honeybadger_context+,
  #   the return value of that method will be used (explicit conversion). Can
  #   include any key/value, but a few keys have a special meaning in
  #   Honeybadger.
  # @return [Object, self] value of the block if passed, otherwise self
  #
  # source://honeybadger//lib/honeybadger/agent.rb#266
  def context(context = T.unsafe(nil), &block); end

  # @api private
  # @see Honeybadger::Instrumentation#decrement_counter
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def decrement_counter(*args, **_arg1, &block); end

  # Sends event to events backend
  #
  # @example
  #   # With event type as first argument (recommended):
  #   Honeybadger.event("user_signed_up", user_id: 123)
  #
  #   # With just a payload:
  #   Honeybadger.event(event_type: "user_signed_up", user_id: 123)
  # @param event_name [String, Hash] a String describing the event or a Hash
  #   when the second argument is omitted.
  # @param payload [Hash] Additional data to be sent with the event as keyword arguments
  # @return [void]
  #
  # source://honeybadger//lib/honeybadger/agent.rb#393
  def event(event_type, payload = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/agent.rb#514
  def events_worker; end

  # DEPRECATED: Callback to ignore exceptions.
  #
  # See public API documentation for {Honeybadger::Notice} for available attributes.
  #
  # @example
  #   # Ignoring based on error message:
  #   Honeybadger.exception_filter do |notice|
  #   notice.error_message =~ /sensitive data/
  #   end
  #
  #   # Ignore an entire class of exceptions:
  #   Honeybadger.exception_filter do |notice|
  #   notice.exception.class < MyError
  #   end
  # @yieldreturn [Boolean] true (to ignore) or false (to send).
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def exception_filter(*args, **_arg1, &block); end

  # DEPRECATED: Callback to add a custom grouping strategy for exceptions. The return
  # value is hashed and sent to Honeybadger. Errors with the same fingerprint
  # will be grouped.
  #
  # See public API documentation for {Honeybadger::Notice} for available attributes.
  #
  # @example
  #   Honeybadger.exception_fingerprint do |notice|
  #   [notice.error_class, notice.component, notice.backtrace.to_s].join(':')
  #   end
  # @yieldreturn [#to_s] The fingerprint of the error.
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def exception_fingerprint(*args, **_arg1, &block); end

  # Flushes all data from workers before returning. This is most useful in
  # tests when using the test backend, where normally the asynchronous nature
  # of this library could create race conditions.
  #
  # @example
  #   # Without a block:
  #   it "sends a notification to Honeybadger" do
  #   expect {
  #   Honeybadger.notify(StandardError.new('test backend'))
  #   Honeybadger.flush
  #   }.to change(Honeybadger::Backend::Test.notifications[:notices], :size).by(0)
  #   end
  #
  #   # With a block:
  #   it "sends a notification to Honeybadger" do
  #   expect {
  #   Honeybadger.flush do
  #   49.times do
  #   Honeybadger.notify(StandardError.new('test backend'))
  #   end
  #   end
  #   }.to change(Honeybadger::Backend::Test.notifications[:notices], :size).by(49)
  #   end
  # @return [Object, Boolean] value of block if block is given, otherwise true
  #   on success or false if Honeybadger isn't running.
  # @yield An optional block to execute (exceptions will propagate after
  #   data is flushed).
  #
  # source://honeybadger//lib/honeybadger/agent.rb#359
  def flush; end

  # @api private
  # @see Honeybadger::Instrumentation#gauge
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def gauge(*args, **_arg1, &block); end

  # Get global context for the current request.
  #
  # @example
  #   Honeybadger.context({my_data: 'my value'})
  #   Honeybadger.get_context # => {my_data: 'my value'}
  # @return [Hash, nil]
  #
  # source://honeybadger//lib/honeybadger/agent.rb#286
  def get_context; end

  # @api private
  # @see Honeybadger::Instrumentation#histogram
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def histogram(*args, **_arg1, &block); end

  # @api private
  # @see Honeybadger::Instrumentation#increment_counter
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def increment_counter(*args, **_arg1, &block); end

  # @api private
  # @see Config#init!
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def init!(*args, **_arg1, &block); end

  # source://honeybadger//lib/honeybadger/agent.rb#551
  def instrumentation; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/agent.rb#514
  def metrics_worker; end

  # Sends an exception to Honeybadger. Does not report ignored exceptions by
  # default.
  #
  # @example
  #   # With an exception:
  #   begin
  #   fail 'oops'
  #   rescue => exception
  #   Honeybadger.notify(exception, context: {
  #   my_data: 'value'
  #   }) # => '-1dfb92ae-9b01-42e9-9c13-31205b70744a'
  #   end
  #
  #   # Custom notification:
  #   Honeybadger.notify('Something went wrong.',
  #   error_class: 'MyClass',
  #   context: {my_data: 'value'}
  #   ) # => '06220c5a-b471-41e5-baeb-de247da45a56'
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param exception_or_opts [Exception, Hash, Object] An Exception object,
  #   or a Hash of options which is used to build the notice. All other types
  #   of objects will be converted to a String and used as the :error_message.
  # @param opts [Hash] The options Hash when the first argument is an Exception.
  # @param kwargs [Hash] options as keyword args.
  # @return [String] UUID reference to the notice within Honeybadger.
  # @return [false] when ignored.
  #
  # source://honeybadger//lib/honeybadger/agent.rb#127
  def notify(exception_or_opts = T.unsafe(nil), opts = T.unsafe(nil), **kwargs); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/agent.rb#433
  def registry; end

  # Stops the Honeybadger service.
  #
  # @example
  #   Honeybadger.stop # => nil
  #
  # source://honeybadger//lib/honeybadger/agent.rb#372
  def stop(force = T.unsafe(nil)); end

  # @api private
  # @see Honeybadger::Instrumentation#time
  #
  # source://forwardable/1.3.3/forwardable.rb#231
  def time(*args, **_arg1, &block); end

  # Track a new deployment
  #
  # @example
  #   Honeybadger.track_deployment(revision: 'be2ceb6')
  # @param :environment [String] The environment name. Defaults to the current configured environment.
  # @param :revision [String] The VCS revision being deployed. Defaults to the currently configured revision.
  # @param :local_username [String] The name of the user who performed the deploy.
  # @param :repository [String] The base URL of the VCS repository. It should be HTTPS-style.
  # @return [Boolean] true if the deployment was successfully tracked and false
  #   otherwise.
  #
  # source://honeybadger//lib/honeybadger/agent.rb#218
  def track_deployment(environment: T.unsafe(nil), revision: T.unsafe(nil), local_username: T.unsafe(nil), repository: T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/agent.rb#504
  def with_rack_env(rack_env, &block); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/agent.rb#514
  def worker; end

  private

  # source://honeybadger//lib/honeybadger/agent.rb#565
  def context_manager; end

  # source://honeybadger//lib/honeybadger/agent.rb#585
  def init_events_worker; end

  # source://honeybadger//lib/honeybadger/agent.rb#590
  def init_metrics_worker; end

  # source://honeybadger//lib/honeybadger/agent.rb#580
  def init_worker; end

  # source://honeybadger//lib/honeybadger/agent.rb#570
  def push(object); end

  # source://honeybadger//lib/honeybadger/agent.rb#575
  def send_now(object); end

  # @raise [ArgumentError]
  #
  # source://honeybadger//lib/honeybadger/agent.rb#557
  def validate_notify_opts!(opts); end

  # source://honeybadger//lib/honeybadger/agent.rb#595
  def with_error_handling; end

  class << self
    # @api private
    #
    # source://honeybadger//lib/honeybadger/agent.rb#55
    def instance; end

    # @api private
    #
    # source://honeybadger//lib/honeybadger/agent.rb#60
    def instance=(instance); end
  end
end

# Binding#source_location was added in Ruby 2.6.
#
# @api private
#
# source://honeybadger//lib/honeybadger/notice.rb#47
Honeybadger::BINDING_HAS_SOURCE_LOCATION = T.let(T.unsafe(nil), TrueClass)

# @api private
#
# source://honeybadger//lib/honeybadger/backend/base.rb#8
module Honeybadger::Backend
  class << self
    # @api private
    #
    # source://honeybadger//lib/honeybadger/backend.rb#23
    def for(backend); end

    # @api private
    #
    # source://honeybadger//lib/honeybadger/backend.rb#14
    def mapping; end
  end
end

# @api private
#
# source://honeybadger//lib/honeybadger/backend.rb#12
class Honeybadger::Backend::BackendError < ::StandardError; end

# source://honeybadger//lib/honeybadger/backend/base.rb#71
class Honeybadger::Backend::Base
  include ::Honeybadger::Logging::Helper
  extend ::Forwardable

  # @return [Base] a new instance of Base
  #
  # source://honeybadger//lib/honeybadger/backend/base.rb#76
  def initialize(config); end

  # Does a check in using the input id.
  #
  # @param id [String] The unique check_in id.
  # @raise NotImplementedError
  #
  # source://honeybadger//lib/honeybadger/backend/base.rb#99
  def check_in(id); end

  # Send event
  #
  # @example
  #   backend.event([{event_type: "email_received", ts: "2023-03-04T12:12:00+1:00", subject: 'Re: Aquisition' }})
  # @param payload [Array] array of event hashes to send
  # @raise NotImplementedError
  #
  # source://honeybadger//lib/honeybadger/backend/base.rb#118
  def event(payload); end

  # Process payload for feature.
  #
  # @example
  #   backend.notify(:notices, Notice.new(...))
  # @param feature [Symbol] The feature name (corresponds to HTTP
  #   endpoint). Current options are: `:notices`, `:deploys`, `:ping`.
  # @param payload [#to_json] The JSON payload to send.
  # @raise NotImplementedError
  #
  # source://honeybadger//lib/honeybadger/backend/base.rb#90
  def notify(feature, payload); end

  # Track a deployment
  #
  # @example
  #   backend.track_deployment({ revision: 'be2ceb6' })
  # @param payload [#to_json] The JSON payload containing all deployment data.
  #
  # source://honeybadger//lib/honeybadger/backend/base.rb#108
  def track_deployment(payload); end

  private

  # Returns the value of attribute config.
  #
  # source://honeybadger//lib/honeybadger/backend/base.rb#124
  def config; end
end

# Logs the notice payload rather than sending it. The purpose of this
# backend is primarily for programmatically inspecting JSON payloads in
# integration tests.
#
# source://honeybadger//lib/honeybadger/backend/debug.rb#8
class Honeybadger::Backend::Debug < ::Honeybadger::Backend::Null
  # source://honeybadger//lib/honeybadger/backend/debug.rb#15
  def check_in(id); end

  # source://honeybadger//lib/honeybadger/backend/debug.rb#21
  def event(payload); end

  # source://honeybadger//lib/honeybadger/backend/debug.rb#9
  def notify(feature, payload); end
end

# source://honeybadger//lib/honeybadger/backend/null.rb#5
class Honeybadger::Backend::Null < ::Honeybadger::Backend::Base
  # @return [Null] a new instance of Null
  #
  # source://honeybadger//lib/honeybadger/backend/null.rb#16
  def initialize(*args); end

  # source://honeybadger//lib/honeybadger/backend/null.rb#24
  def check_in(id); end

  # source://honeybadger//lib/honeybadger/backend/null.rb#28
  def event(payload); end

  # source://honeybadger//lib/honeybadger/backend/null.rb#20
  def notify(feature, payload); end
end

# source://honeybadger//lib/honeybadger/backend/null.rb#6
class Honeybadger::Backend::Null::StubbedResponse < ::Honeybadger::Backend::Response
  # @return [StubbedResponse] a new instance of StubbedResponse
  #
  # source://honeybadger//lib/honeybadger/backend/null.rb#7
  def initialize; end

  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/backend/null.rb#11
  def success?; end
end

# source://honeybadger//lib/honeybadger/backend/base.rb#9
class Honeybadger::Backend::Response
  # Initializes the Response instance.
  #
  # @overload initialize
  # @overload initialize
  # @return [Response] a new instance of Response
  #
  # source://honeybadger//lib/honeybadger/backend/base.rb#36
  def initialize(*args); end

  # Returns the value of attribute body.
  #
  # source://honeybadger//lib/honeybadger/backend/base.rb#12
  def body; end

  # Returns the value of attribute code.
  #
  # source://honeybadger//lib/honeybadger/backend/base.rb#12
  def code; end

  # Returns the value of attribute error.
  #
  # source://honeybadger//lib/honeybadger/backend/base.rb#12
  def error; end

  # source://honeybadger//lib/honeybadger/backend/base.rb#51
  def error_message; end

  # Returns the value of attribute message.
  #
  # source://honeybadger//lib/honeybadger/backend/base.rb#12
  def message; end

  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/backend/base.rb#47
  def success?; end

  private

  # source://honeybadger//lib/honeybadger/backend/base.rb#62
  def parse_error(body); end
end

# source://honeybadger//lib/honeybadger/backend/base.rb#14
Honeybadger::Backend::Response::FRIENDLY_ERRORS = T.let(T.unsafe(nil), Hash)

# source://honeybadger//lib/honeybadger/backend/base.rb#10
Honeybadger::Backend::Response::NOT_BLANK = T.let(T.unsafe(nil), Regexp)

# source://honeybadger//lib/honeybadger/backend/server.rb#11
class Honeybadger::Backend::Server < ::Honeybadger::Backend::Base
  # @return [Server] a new instance of Server
  #
  # source://honeybadger//lib/honeybadger/backend/server.rb#21
  def initialize(config); end

  # Does a check in using the input id.
  #
  # @param id [String] The unique check_in id.
  # @return [Response]
  #
  # source://honeybadger//lib/honeybadger/backend/server.rb#44
  def check_in(id); end

  # Send event
  #
  # @example
  #   backend.event([{event_type: "email_received", ts: "2023-03-04T12:12:00+1:00", subject: 'Re: Aquisition' }})
  # @param payload [Array] array of event hashes to send
  # @return [Response]
  #
  # source://honeybadger//lib/honeybadger/backend/server.rb#56
  def event(payload); end

  # Post payload to endpoint for feature.
  #
  # @param feature [Symbol] The feature which is being notified.
  # @param payload [#to_json] The JSON payload to send.
  # @return [Response]
  #
  # source://honeybadger//lib/honeybadger/backend/server.rb#32
  def notify(feature, payload); end

  private

  # source://honeybadger//lib/honeybadger/backend/server.rb#64
  def payload_headers(payload); end
end

# source://honeybadger//lib/honeybadger/backend/server.rb#16
Honeybadger::Backend::Server::CHECK_IN_ENDPOINT = T.let(T.unsafe(nil), String)

# source://honeybadger//lib/honeybadger/backend/server.rb#12
Honeybadger::Backend::Server::ENDPOINTS = T.let(T.unsafe(nil), Hash)

# source://honeybadger//lib/honeybadger/backend/server.rb#17
Honeybadger::Backend::Server::EVENTS_ENDPOINT = T.let(T.unsafe(nil), String)

# source://honeybadger//lib/honeybadger/backend/server.rb#19
Honeybadger::Backend::Server::HTTP_ERRORS = T.let(T.unsafe(nil), Array)

# source://honeybadger//lib/honeybadger/backend/test.rb#5
class Honeybadger::Backend::Test < ::Honeybadger::Backend::Null
  # source://honeybadger//lib/honeybadger/backend/test.rb#55
  def check_in(id); end

  # source://honeybadger//lib/honeybadger/backend/test.rb#41
  def check_ins; end

  # source://honeybadger//lib/honeybadger/backend/test.rb#50
  def event(payload); end

  # source://honeybadger//lib/honeybadger/backend/test.rb#37
  def notifications; end

  # source://honeybadger//lib/honeybadger/backend/test.rb#45
  def notify(feature, payload); end

  class << self
    # The check in list.
    #
    # @api public
    # @example
    #   Test.check_ins # => ["foobar", "danny", ...]
    # @return [Array<Object>] List of check ins.
    #
    # source://honeybadger//lib/honeybadger/backend/test.rb#33
    def check_ins; end

    # The event list.
    #
    # @example
    #   Test.events # => [{}, {}, ...]
    # @return [Array<Hash>] List of event payloads.
    #
    # source://honeybadger//lib/honeybadger/backend/test.rb#22
    def events; end

    # The notification list.
    #
    # @example
    #   Test.notifications[:notices] # => [Notice, Notice, ...]
    # @return [Hash] Notifications hash.
    #
    # source://honeybadger//lib/honeybadger/backend/test.rb#12
    def notifications; end
  end
end

# Front end to parsing the backtrace for each notice.
#
# @api private
#
# source://honeybadger//lib/honeybadger/backtrace.rb#6
class Honeybadger::Backtrace
  # @api private
  # @return [Backtrace] a new instance of Backtrace
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#126
  def initialize(lines); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#161
  def ==(other); end

  # Holder for an Array of Backtrace::Line instances.
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#114
  def application_lines; end

  # JSON support.
  #
  # Returns JSON representation of backtrace.
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#142
  def as_json(options = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#157
  def inspect; end

  # Holder for an Array of Backtrace::Line instances.
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#114
  def lines; end

  # Convert Backtrace to arry.
  #
  # Returns array containing backtrace lines.
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#134
  def to_a; end

  # Convert Backtrace to arry.
  #
  # Returns array containing backtrace lines.
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#134
  def to_ary; end

  # Creates JSON.
  #
  # Returns valid JSON representation of backtrace.
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#149
  def to_json(*a); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#153
  def to_s; end

  private

  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#171
  def application_lines=(_arg0); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#171
  def lines=(_arg0); end

  class << self
    # @api private
    #
    # source://honeybadger//lib/honeybadger/backtrace.rb#116
    def parse(ruby_backtrace, opts = T.unsafe(nil)); end

    # @api private
    #
    # source://honeybadger//lib/honeybadger/backtrace.rb#173
    def split_multiline_backtrace(backtrace); end
  end
end

# Handles backtrace parsing line by line.
#
# @api private
#
# source://honeybadger//lib/honeybadger/backtrace.rb#8
class Honeybadger::Backtrace::Line
  # @api private
  # @return [Line] a new instance of Line
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#52
  def initialize(file, number, method, filtered_file = T.unsafe(nil), filtered_number = T.unsafe(nil), filtered_method = T.unsafe(nil), source_radius = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#69
  def ==(other); end

  # Determines if this line is part of the application trace or not.
  #
  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#78
  def application?; end

  # The file portion of the line (such as app/models/user.rb).
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#13
  def file; end

  # Filtered representations
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#22
  def filtered_file; end

  # Filtered representations
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#22
  def filtered_method; end

  # Filtered representations
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#22
  def filtered_number; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#73
  def inspect; end

  # The method of the line (such as index).
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#19
  def method; end

  # The line number portion of the line.
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#16
  def number; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#82
  def source; end

  # Reconstructs the line in a readable fashion.
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#65
  def to_s; end

  private

  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#88
  def file=(_arg0); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#88
  def filtered_file=(_arg0); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#88
  def filtered_method=(_arg0); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#88
  def filtered_number=(_arg0); end

  # Open source file and read line(s).
  #
  # Returns an array of line(s) from source file.
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#95
  def get_source(file, number, radius = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#88
  def method=(_arg0); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#88
  def number=(_arg0); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#90
  def source_radius; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/backtrace.rb#90
  def source_radius=(_arg0); end

  class << self
    # Parses a single line of a given backtrace
    #
    # @api private
    # @param unparsed_line [String] The raw line from +caller+ or some backtrace.
    # @return The parsed backtrace line.
    #
    # source://honeybadger//lib/honeybadger/backtrace.rb#29
    def parse(unparsed_line, opts = T.unsafe(nil)); end
  end
end

# Backtrace line regexp (optionally allowing leading X: for windows support).
#
# @api private
#
# source://honeybadger//lib/honeybadger/backtrace.rb#10
Honeybadger::Backtrace::Line::INPUT_FORMAT = T.let(T.unsafe(nil), Regexp)

# source://honeybadger//lib/honeybadger/breadcrumbs/active_support.rb#4
module Honeybadger::Breadcrumbs; end

# source://honeybadger//lib/honeybadger/breadcrumbs/active_support.rb#5
class Honeybadger::Breadcrumbs::ActiveSupport
  class << self
    # source://honeybadger//lib/honeybadger/breadcrumbs/active_support.rb#6
    def default_notifications; end

    private

    # source://honeybadger//lib/honeybadger/breadcrumbs/active_support.rb#108
    def active_record_connection_db_config; end
  end
end

# source://honeybadger//lib/honeybadger/breadcrumbs/breadcrumb.rb#5
class Honeybadger::Breadcrumbs::Breadcrumb
  include ::Comparable

  # @return [Breadcrumb] a new instance of Breadcrumb
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/breadcrumb.rb#13
  def initialize(category: T.unsafe(nil), message: T.unsafe(nil), metadata: T.unsafe(nil)); end

  # source://honeybadger//lib/honeybadger/breadcrumbs/breadcrumb.rb#31
  def <=>(other); end

  # Returns the value of attribute active.
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/breadcrumb.rb#9
  def active; end

  # Sets the attribute active
  #
  # @param value the value to set the attribute active to.
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/breadcrumb.rb#9
  def active=(_arg0); end

  # Is the Breadcrumb active or not. Inactive Breadcrumbs not be included
  # with any outgoing payloads.
  #
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/breadcrumb.rb#40
  def active?; end

  # Raw breadcrumb data structure
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/breadcrumb.rb#8
  def category; end

  # Sets the breadcrumb to inactive
  #
  # @return self
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/breadcrumb.rb#47
  def ignore!; end

  # Returns the value of attribute message.
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/breadcrumb.rb#9
  def message; end

  # Sets the attribute message
  #
  # @param value the value to set the attribute message to.
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/breadcrumb.rb#9
  def message=(_arg0); end

  # Returns the value of attribute metadata.
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/breadcrumb.rb#9
  def metadata; end

  # Sets the attribute metadata
  #
  # @param value the value to set the attribute metadata to.
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/breadcrumb.rb#9
  def metadata=(_arg0); end

  # Raw breadcrumb data structure
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/breadcrumb.rb#8
  def timestamp; end

  # source://honeybadger//lib/honeybadger/breadcrumbs/breadcrumb.rb#22
  def to_h; end
end

# source://honeybadger//lib/honeybadger/breadcrumbs/collector.rb#5
class Honeybadger::Breadcrumbs::Collector
  include ::Enumerable
  extend ::Forwardable

  # @return [Collector] a new instance of Collector
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/collector.rb#29
  def initialize(config, buffer = T.unsafe(nil)); end

  # Add Breadcrumb to stack
  #
  # @return [self] Filtered breadcrumbs
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/collector.rb#37
  def <<(breadcrumb); end

  # Add Breadcrumb to stack
  #
  # @return [self] Filtered breadcrumbs
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/collector.rb#37
  def add!(breadcrumb); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def clear!(*args, **_arg1, &block); end

  # Removes the prevous breadcrumb from the buffer if the supplied
  # block returns a falsy value
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/collector.rb#50
  def drop_previous_breadcrumb_if; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def previous(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_a(*args, **_arg1, &block); end

  # source://honeybadger//lib/honeybadger/breadcrumbs/collector.rb#62
  def to_h; end

  # All active breadcrumbs you want to remove a breadcrumb from the trail,
  # then you can selectively ignore breadcrumbs while building a notice.
  #
  # @return [Array] Active breadcrumbs
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/collector.rb#58
  def trail; end

  private

  # Since the collector is shared with the worker thread, there is a chance
  # it can be cleared before we have prepared the request. We provide the
  # ability to duplicate a collector which should also duplicate the buffer
  # instance, as that holds the breadcrumbs.
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/collector.rb#76
  def initialize_dup(source); end
end

# source://honeybadger//lib/honeybadger/breadcrumbs/ring_buffer.rb#3
class Honeybadger::Breadcrumbs::RingBuffer
  include ::Enumerable

  # @return [RingBuffer] a new instance of RingBuffer
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/ring_buffer.rb#11
  def initialize(buffer_size = T.unsafe(nil)); end

  # source://honeybadger//lib/honeybadger/breadcrumbs/ring_buffer.rb#16
  def add!(item); end

  # Returns the value of attribute buffer.
  #
  # source://honeybadger//lib/honeybadger/breadcrumbs/ring_buffer.rb#9
  def buffer; end

  # source://honeybadger//lib/honeybadger/breadcrumbs/ring_buffer.rb#22
  def clear!; end

  # source://honeybadger//lib/honeybadger/breadcrumbs/ring_buffer.rb#39
  def drop; end

  # source://honeybadger//lib/honeybadger/breadcrumbs/ring_buffer.rb#31
  def each(&blk); end

  # source://honeybadger//lib/honeybadger/breadcrumbs/ring_buffer.rb#35
  def previous; end

  # source://honeybadger//lib/honeybadger/breadcrumbs/ring_buffer.rb#27
  def to_a; end
end

# The Config class is used to manage Honeybadger's initialization and
# configuration.
#
# @api private
#
# source://honeybadger//lib/honeybadger/config/defaults.rb#5
class Honeybadger::Config
  include ::Honeybadger::Logging::Helper
  extend ::Forwardable

  # @api private
  # @return [Config] a new instance of Config
  #
  # source://honeybadger//lib/honeybadger/config.rb#40
  def initialize(opts = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#117
  def [](key); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#129
  def []=(key, value); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#154
  def backend; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#159
  def backend=(backend); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#82
  def backtrace_filter(&block); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#95
  def before_event_hooks; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#91
  def before_notify_hooks; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#213
  def ca_bundle_path; end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/config.rb#295
  def cluster_collection?(name); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#301
  def collection_interval(name); end

  # @api private
  # @yield [new_ruby]
  #
  # source://honeybadger//lib/honeybadger/config.rb#74
  def configure; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#227
  def connection_port; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#237
  def connection_protocol; end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/config.rb#178
  def debug?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#322
  def detected_framework; end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/config.rb#164
  def dev?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#47
  def env; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#47
  def env=(_arg0); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#253
  def events_batch_size; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#249
  def events_max_queue_size; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#257
  def events_timeout; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#99
  def exception_filter(&block); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#108
  def exception_fingerprint(&block); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#265
  def excluded_request_keys; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#47
  def framework; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#47
  def framework=(_arg0); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#338
  def framework_name; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#117
  def get(key); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#187
  def ignored_classes; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#203
  def ignored_events; end

  # Called by framework (see lib/honeybadger/init/) at the point of
  # initialization. This is not required for the notifier to work (i.e. with
  # `require 'honeybadger/ruby'`).
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#52
  def init!(opts = T.unsafe(nil), env = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/config.rb#291
  def insights_enabled?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#64
  def load!(framework: T.unsafe(nil), env: T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/config.rb#285
  def load_plugin?(name); end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/config.rb#306
  def load_plugin_insights?(name); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#223
  def local_cert_path; end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/config.rb#182
  def log_debug?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#274
  def log_level(key = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#149
  def logger; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#245
  def max_queue_size; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#261
  def params_filters; end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/config.rb#172
  def public?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#195
  def raw_ignored_events; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#312
  def root_regexp; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#47
  def ruby; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#47
  def ruby=(_arg0); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#129
  def set(key, value); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#135
  def to_h(defaults = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#135
  def to_hash(defaults = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/config.rb#168
  def warn_development?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#47
  def yaml; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#47
  def yaml=(_arg0); end

  private

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#404
  def build_file_logger(path); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#415
  def build_logger; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#395
  def build_stdout_logger; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#362
  def config_path; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#366
  def config_paths; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#372
  def default_backend; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#351
  def detect_revision!; end

  # Converts a nested hash into a single layer where keys become arrays:
  # ex: > flat_hash({ :nested => { :hash => "value" }})
  #     > { [:nested, :hash] => "value" }
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#474
  def flat_hash(h, f = T.unsafe(nil), g = T.unsafe(nil)); end

  # Takes an Array and a value and returns true if the value exists in the
  # array in String or Symbol form, otherwise false.
  #
  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/config.rb#436
  def includes_token?(obj, value); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#377
  def init_backend!; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#430
  def init_logging!; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#450
  def load_config_from_disk; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#441
  def locate_absolute_path(path, root); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#356
  def log_path; end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/config.rb#411
  def log_stdout?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/config.rb#458
  def undotify_keys(hash); end
end

# source://honeybadger//lib/honeybadger/config/defaults.rb#6
class Honeybadger::Config::Boolean; end

# @api private
#
# source://honeybadger//lib/honeybadger/config.rb#24
class Honeybadger::Config::ConfigError < ::StandardError; end

# source://honeybadger//lib/honeybadger/config/defaults.rb#420
Honeybadger::Config::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://honeybadger//lib/honeybadger/config/defaults.rb#42
Honeybadger::Config::DEFAULT_PATHS = T.let(T.unsafe(nil), Array)

# source://honeybadger//lib/honeybadger/config/defaults.rb#40
Honeybadger::Config::DEVELOPMENT_ENVIRONMENTS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://honeybadger//lib/honeybadger/config.rb#34
Honeybadger::Config::DOTTED_KEY = T.let(T.unsafe(nil), Regexp)

# source://honeybadger//lib/honeybadger/config/env.rb#5
module Honeybadger::Config::Env
  class << self
    # source://honeybadger//lib/honeybadger/config/env.rb#25
    def cast_value(value, type = T.unsafe(nil)); end

    # source://honeybadger//lib/honeybadger/config/env.rb#11
    def new(env = T.unsafe(nil)); end
  end
end

# source://honeybadger//lib/honeybadger/config/env.rb#8
Honeybadger::Config::Env::ARRAY_VALUES = T.let(T.unsafe(nil), Regexp)

# source://honeybadger//lib/honeybadger/config/env.rb#6
Honeybadger::Config::Env::CONFIG_KEY = T.let(T.unsafe(nil), Regexp)

# source://honeybadger//lib/honeybadger/config/env.rb#7
Honeybadger::Config::Env::CONFIG_MAPPING = T.let(T.unsafe(nil), Hash)

# source://honeybadger//lib/honeybadger/config/env.rb#9
Honeybadger::Config::Env::IGNORED_TYPES = T.let(T.unsafe(nil), Set)

# source://honeybadger//lib/honeybadger/config/defaults.rb#8
Honeybadger::Config::IGNORE_DEFAULT = T.let(T.unsafe(nil), Array)

# source://honeybadger//lib/honeybadger/config/defaults.rb#34
Honeybadger::Config::IGNORE_EVENTS_DEFAULT = T.let(T.unsafe(nil), Array)

# @api private
#
# source://honeybadger//lib/honeybadger/config.rb#38
Honeybadger::Config::IVARS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://honeybadger//lib/honeybadger/config.rb#32
Honeybadger::Config::KEY_REPLACEMENT = T.let(T.unsafe(nil), Regexp)

# source://honeybadger//lib/honeybadger/config/ruby.rb#3
class Honeybadger::Config::Mash
  # @return [Mash] a new instance of Mash
  #
  # source://honeybadger//lib/honeybadger/config/ruby.rb#6
  def initialize(config, prefix: T.unsafe(nil), hash: T.unsafe(nil)); end

  # source://honeybadger//lib/honeybadger/config/ruby.rb#12
  def to_h; end

  # source://honeybadger//lib/honeybadger/config/ruby.rb#12
  def to_hash; end

  private

  # Returns the value of attribute config.
  #
  # source://honeybadger//lib/honeybadger/config/ruby.rb#19
  def config; end

  # source://honeybadger//lib/honeybadger/config/ruby.rb#65
  def get(key); end

  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/config/ruby.rb#54
  def getter?(method_name); end

  # Returns the value of attribute hash.
  #
  # source://honeybadger//lib/honeybadger/config/ruby.rb#19
  def hash; end

  # source://honeybadger//lib/honeybadger/config/ruby.rb#59
  def key(method_name); end

  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/config/ruby.rb#43
  def mash?(method); end

  # source://honeybadger//lib/honeybadger/config/ruby.rb#21
  def method_missing(method_name, *args, &block); end

  # Returns the value of attribute prefix.
  #
  # source://honeybadger//lib/honeybadger/config/ruby.rb#19
  def prefix; end

  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/config/ruby.rb#34
  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/config/ruby.rb#48
  def setter?(method_name); end
end

# source://honeybadger//lib/honeybadger/config/ruby.rb#4
Honeybadger::Config::Mash::KEYS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://honeybadger//lib/honeybadger/config.rb#36
Honeybadger::Config::NOT_BLANK = T.let(T.unsafe(nil), Regexp)

# source://honeybadger//lib/honeybadger/config/defaults.rb#44
Honeybadger::Config::OPTIONS = T.let(T.unsafe(nil), Hash)

# source://honeybadger//lib/honeybadger/config/ruby.rb#72
class Honeybadger::Config::Ruby < ::Honeybadger::Config::Mash
  # source://honeybadger//lib/honeybadger/config/ruby.rb#85
  def backend; end

  # source://honeybadger//lib/honeybadger/config/ruby.rb#81
  def backend=(backend); end

  # source://honeybadger//lib/honeybadger/config/ruby.rb#113
  def backtrace_filter(&block); end

  # source://honeybadger//lib/honeybadger/config/ruby.rb#101
  def before_event(action = T.unsafe(nil), &block); end

  # source://honeybadger//lib/honeybadger/config/ruby.rb#89
  def before_notify(action = T.unsafe(nil), &block); end

  # source://honeybadger//lib/honeybadger/config/ruby.rb#122
  def exception_filter(&block); end

  # source://honeybadger//lib/honeybadger/config/ruby.rb#131
  def exception_fingerprint(&block); end

  # source://honeybadger//lib/honeybadger/config/ruby.rb#77
  def logger; end

  # source://honeybadger//lib/honeybadger/config/ruby.rb#73
  def logger=(logger); end

  private

  # source://honeybadger//lib/honeybadger/config/ruby.rb#142
  def validate_before_action(action, type); end
end

# source://honeybadger//lib/honeybadger/config/yaml.rb#7
module Honeybadger::Config::Yaml
  class << self
    # source://honeybadger//lib/honeybadger/config/yaml.rb#61
    def dotify_keys(hash, key_prefix = T.unsafe(nil)); end

    # source://honeybadger//lib/honeybadger/config/yaml.rb#27
    def load_yaml(path); end

    # source://honeybadger//lib/honeybadger/config/yaml.rb#10
    def new(path, env = T.unsafe(nil)); end
  end
end

# source://honeybadger//lib/honeybadger/config/yaml.rb#8
Honeybadger::Config::Yaml::DISALLOWED_KEYS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://honeybadger//lib/honeybadger/context_manager.rb#5
class Honeybadger::ContextManager
  include ::Honeybadger::Conversions

  # @api private
  # @return [ContextManager] a new instance of ContextManager
  #
  # source://honeybadger//lib/honeybadger/context_manager.rb#12
  def initialize; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/context_manager.rb#17
  def clear!; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/context_manager.rb#48
  def get_context; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/context_manager.rb#60
  def get_rack_env; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/context_manager.rb#68
  def get_request_id; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/context_manager.rb#24
  def set_context(hash, &block); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/context_manager.rb#56
  def set_rack_env(env); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/context_manager.rb#64
  def set_request_id(request_id); end

  private

  # @api private
  #
  # source://honeybadger//lib/honeybadger/context_manager.rb#76
  def _initialize; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/context_manager.rb#74
  def custom; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/context_manager.rb#74
  def custom=(_arg0); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/context_manager.rb#74
  def rack_env; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/context_manager.rb#74
  def rack_env=(_arg0); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/context_manager.rb#74
  def request_id; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/context_manager.rb#74
  def request_id=(_arg0); end

  class << self
    # @api private
    #
    # source://honeybadger//lib/honeybadger/context_manager.rb#8
    def current; end
  end
end

# @api private
#
# source://honeybadger//lib/honeybadger/conversions.rb#3
module Honeybadger::Conversions
  private

  # Convert context into a Hash.
  #
  # @api private
  # @param object [Object] The context object.
  # @return [Hash] The hash context.
  #
  # source://honeybadger//lib/honeybadger/conversions.rb#12
  def Context(object, depth = T.unsafe(nil)); end

  class << self
    # Convert context into a Hash.
    #
    # @api private
    # @param object [Object] The context object.
    # @return [Hash] The hash context.
    #
    # source://honeybadger//lib/honeybadger/conversions.rb#12
    def Context(object, depth = T.unsafe(nil)); end
  end
end

# @api private
#
# source://honeybadger//lib/honeybadger/conversions.rb#5
Honeybadger::Conversions::MAX_CONTEXT_DEPTH = T.let(T.unsafe(nil), Integer)

# source://honeybadger//lib/honeybadger/counter.rb#4
class Honeybadger::Counter < ::Honeybadger::Metric
  # source://honeybadger//lib/honeybadger/counter.rb#5
  def count(by = T.unsafe(nil)); end

  # source://honeybadger//lib/honeybadger/counter.rb#14
  def payloads; end
end

# source://honeybadger//lib/honeybadger/event.rb#4
class Honeybadger::Event
  extend ::Forwardable

  # @api private
  # @return [Event] a new instance of Event
  #
  # source://honeybadger//lib/honeybadger/event.rb#19
  def initialize(event_type_or_payload, payload = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def [](*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def []=(*args, **_arg1, &block); end

  # Template used to create JSON payload.
  #
  # @api private
  # @return [Hash] JSON representation of the event.
  #
  # source://honeybadger//lib/honeybadger/event.rb#49
  def as_json(*args); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def dig(*args, **_arg1, &block); end

  # The event_type of the event
  #
  # source://honeybadger//lib/honeybadger/event.rb#11
  def event_type; end

  # Halts the event and the before_event callback chain.
  #
  # Returns nothing.
  #
  # source://honeybadger//lib/honeybadger/event.rb#35
  def halt!; end

  # Determines if this event will be discarded.
  #
  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/event.rb#41
  def halted?; end

  # The payload data of the event
  #
  # source://honeybadger//lib/honeybadger/event.rb#14
  def payload; end

  # The timestamp of the event
  #
  # source://honeybadger//lib/honeybadger/event.rb#8
  def ts; end
end

# A concurrent queue to notify the backend.
#
# @api private
#
# source://honeybadger//lib/honeybadger/events_worker.rb#9
class Honeybadger::EventsWorker
  include ::Honeybadger::Logging::Helper
  extend ::Forwardable

  # TODO: These could be configurable?
  #
  # @api private
  # @return [EventsWorker] a new instance of EventsWorker
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#29
  def initialize(config); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def backend(*args, **_arg1, &block); end

  # Blocks until queue is processed up to this point in time.
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#85
  def flush; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#45
  def push(msg); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#56
  def send_now(msg); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#60
  def shutdown(force = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#95
  def start; end

  private

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#262
  def calc_throttle_interval; end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#127
  def can_start?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#220
  def check_and_send; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#193
  def check_timeout; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#114
  def config; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#274
  def dec_throttle; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#201
  def enqueue_msg(msg); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#227
  def flush_send_queue; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#283
  def handle_response(response); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#266
  def inc_throttle; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#137
  def kill!; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#114
  def last_sent; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#114
  def marker; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#114
  def mutex; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#114
  def pid; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#114
  def queue; end

  # Release the marker. Important to perform during cleanup when shutting
  # down, otherwise it could end up waiting indefinitely.
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#315
  def release_marker; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#166
  def run; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#159
  def schedule_timeout_check; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#207
  def send_batch; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#114
  def send_queue; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#256
  def send_to_backend(msg); end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#119
  def shutdown?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#319
  def signal_marker(marker); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#114
  def start_at; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#149
  def suspend(interval); end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#123
  def suspended?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#114
  def thread; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#114
  def throttle; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#114
  def throttle_interval; end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#133
  def throttled?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#114
  def timeout_thread; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/events_worker.rb#237
  def work(msg); end
end

# The base number for the exponential backoff formula when calculating the
# throttle interval. `1.05 ** throttle` will reach an interval of 2 minutes
# after around 100 429 responses from the server.
#
# @api private
#
# source://honeybadger//lib/honeybadger/events_worker.rb#25
Honeybadger::EventsWorker::BASE_THROTTLE = T.let(T.unsafe(nil), Float)

# @api private
#
# source://honeybadger//lib/honeybadger/events_worker.rb#20
Honeybadger::EventsWorker::CHECK_TIMEOUT = T.let(T.unsafe(nil), Symbol)

# @api private
#
# source://honeybadger//lib/honeybadger/events_worker.rb#19
Honeybadger::EventsWorker::FLUSH = T.let(T.unsafe(nil), Symbol)

# Used to signal the worker to shutdown.
#
# @api private
#
# source://honeybadger//lib/honeybadger/events_worker.rb#18
Honeybadger::EventsWorker::SHUTDOWN = T.let(T.unsafe(nil), Symbol)

# Sub-class thread so we have a named thread (useful for debugging in Thread.list).
#
# @api private
#
# source://honeybadger//lib/honeybadger/events_worker.rb#15
class Honeybadger::EventsWorker::Thread < ::Thread; end

# Substitution for gem root in backtrace lines.
#
# @api private
#
# source://honeybadger//lib/honeybadger/notice.rb#24
Honeybadger::GEM_ROOT = T.let(T.unsafe(nil), String)

# source://honeybadger//lib/honeybadger/gauge.rb#4
class Honeybadger::Gauge < ::Honeybadger::Metric
  # source://honeybadger//lib/honeybadger/gauge.rb#19
  def payloads; end

  # source://honeybadger//lib/honeybadger/gauge.rb#5
  def record(value); end
end

# source://honeybadger//lib/honeybadger/histogram.rb#4
class Honeybadger::Histogram < ::Honeybadger::Metric
  # source://honeybadger//lib/honeybadger/histogram.rb#22
  def bins; end

  # source://honeybadger//lib/honeybadger/histogram.rb#16
  def find_bin(value); end

  # source://honeybadger//lib/honeybadger/histogram.rb#26
  def payloads; end

  # source://honeybadger//lib/honeybadger/histogram.rb#8
  def record(value); end
end

# source://honeybadger//lib/honeybadger/histogram.rb#5
Honeybadger::Histogram::DEFAULT_BINS = T.let(T.unsafe(nil), Array)

# not quite, but pretty much
#
# source://honeybadger//lib/honeybadger/histogram.rb#6
Honeybadger::Histogram::INFINITY = T.let(T.unsafe(nil), Float)

# source://honeybadger//lib/honeybadger/init/rails.rb#7
module Honeybadger::Init; end

# source://honeybadger//lib/honeybadger/init/rails.rb#8
module Honeybadger::Init::Rails; end

# source://honeybadger//lib/honeybadger/init/rails.rb#9
class Honeybadger::Init::Rails::Railtie < ::Rails::Railtie; end

# +Honeybadger::Instrumentation+ defines the API for collecting metric data from anywhere
# in an application. These class methods may be used directly, or from the Honeybadger singleton
# instance. There are three usage variations as show in the example below:
#
# class TicketsController < ApplicationController
#   def create
#     # pass a block
#     Honeybadger.time('create.ticket') { Ticket.create(params[:ticket]) }
#
#     # pass a lambda argument
#     Honeybadger.time 'create.ticket', ->{ Ticket.create(params[:ticket]) }
#
#     # pass the duration argument
#     duration = timing_method { Ticket.create(params[:ticket]) }
#     Honeybadger.time 'create.ticket', duration: duration
#   end
# end
#
# source://honeybadger//lib/honeybadger/instrumentation.rb#28
class Honeybadger::Instrumentation
  # @return [Instrumentation] a new instance of Instrumentation
  #
  # source://honeybadger//lib/honeybadger/instrumentation.rb#31
  def initialize(agent); end

  # Returns the value of attribute agent.
  #
  # source://honeybadger//lib/honeybadger/instrumentation.rb#29
  def agent; end

  # source://honeybadger//lib/honeybadger/instrumentation.rb#94
  def decrement_counter(name, *args); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/instrumentation.rb#115
  def extract_attributes(args); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/instrumentation.rb#120
  def extract_callable(args); end

  # source://honeybadger//lib/honeybadger/instrumentation.rb#104
  def gauge(name, *args); end

  # source://honeybadger//lib/honeybadger/instrumentation.rb#66
  def histogram(name, *args); end

  # source://honeybadger//lib/honeybadger/instrumentation.rb#84
  def increment_counter(name, *args); end

  # returns two parameters, the first is the duration of the execution, and the second is
  # the return value of the passed block
  #
  # source://honeybadger//lib/honeybadger/instrumentation.rb#41
  def monotonic_timer; end

  # source://honeybadger//lib/honeybadger/instrumentation.rb#35
  def registry; end

  # source://honeybadger//lib/honeybadger/instrumentation.rb#48
  def time(name, *args); end
end

# +Honeybadger::InstrumentationHelper+ is a module that can be included into any class. This module
# provides a convenient DSL around the instrumentation methods to prvoide a cleaner interface.
# There are three usage variations as show in the example below:
#
# class TicketsController < ApplicationController
#   include Honeybadger::InstrumentationHelper
#
#   def create
#     metric_source 'controller'
#     metric_attributes { foo: 'bar' } # These attributes get tagged to all metrics called after.
#
#     # pass a block
#     time('create.ticket') { Ticket.create(params[:ticket]) }
#
#     # pass a lambda argument
#     time 'create.ticket', ->{ Ticket.create(params[:ticket]) }
#
#     # pass the duration argument
#     duration = timing_method { Ticket.create(params[:ticket]) }
#     time 'create.ticket', duration: duration
#   end
# end
#
# source://honeybadger//lib/honeybadger/instrumentation_helper.rb#30
module Honeybadger::InstrumentationHelper
  # source://honeybadger//lib/honeybadger/instrumentation_helper.rb#89
  def decrement_counter(name, *args); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/instrumentation_helper.rb#110
  def extract_attributes(args); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/instrumentation_helper.rb#116
  def extract_callable(args); end

  # source://honeybadger//lib/honeybadger/instrumentation_helper.rb#99
  def gauge(name, *args); end

  # source://honeybadger//lib/honeybadger/instrumentation_helper.rb#67
  def histogram(name, *args); end

  # source://honeybadger//lib/honeybadger/instrumentation_helper.rb#79
  def increment_counter(name, *args); end

  # source://honeybadger//lib/honeybadger/instrumentation_helper.rb#42
  def metric_agent(agent); end

  # source://honeybadger//lib/honeybadger/instrumentation_helper.rb#50
  def metric_attributes(attributes); end

  # source://honeybadger//lib/honeybadger/instrumentation_helper.rb#46
  def metric_instrumentation; end

  # source://honeybadger//lib/honeybadger/instrumentation_helper.rb#38
  def metric_source(source); end

  # returns two parameters, the first is the duration of the execution, and the second is
  # the return value of the passed block
  #
  # source://honeybadger//lib/honeybadger/instrumentation_helper.rb#34
  def monotonic_timer; end

  # source://honeybadger//lib/honeybadger/instrumentation_helper.rb#55
  def time(name, *args); end
end

# @api private
#
# source://honeybadger//lib/honeybadger/logging.rb#8
module Honeybadger::Logging; end

# @api private
#
# source://honeybadger//lib/honeybadger/logging.rb#48
class Honeybadger::Logging::Base
  # @api private
  # @raise [NotImplementedError]
  #
  # source://honeybadger//lib/honeybadger/logging.rb#59
  def add(severity, msg); end

  # source://honeybadger//lib/honeybadger/logging.rb#50
  def debug(msg); end

  # source://honeybadger//lib/honeybadger/logging.rb#54
  def debug?; end

  # source://honeybadger//lib/honeybadger/logging.rb#50
  def error(msg); end

  # source://honeybadger//lib/honeybadger/logging.rb#54
  def error?; end

  # source://honeybadger//lib/honeybadger/logging.rb#50
  def fatal(msg); end

  # source://honeybadger//lib/honeybadger/logging.rb#54
  def fatal?; end

  # source://honeybadger//lib/honeybadger/logging.rb#50
  def info(msg); end

  # source://honeybadger//lib/honeybadger/logging.rb#54
  def info?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/logging.rb#63
  def level; end

  # source://honeybadger//lib/honeybadger/logging.rb#50
  def unknown(msg); end

  # source://honeybadger//lib/honeybadger/logging.rb#54
  def unknown?; end

  # source://honeybadger//lib/honeybadger/logging.rb#50
  def warn(msg); end

  # source://honeybadger//lib/honeybadger/logging.rb#54
  def warn?; end
end

# @api private
#
# source://honeybadger//lib/honeybadger/logging.rb#68
class Honeybadger::Logging::BootLogger < ::Honeybadger::Logging::Base
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @api private
  # @return [BootLogger] a new instance of BootLogger
  #
  # source://honeybadger//lib/honeybadger/logging.rb#71
  def initialize; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/logging.rb#75
  def add(severity, msg); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/logging.rb#79
  def flush(logger); end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

# @api private
#
# source://honeybadger//lib/honeybadger/logging.rb#117
class Honeybadger::Logging::ConfigLogger < ::Honeybadger::Logging::StandardLogger
  # @api private
  # @return [ConfigLogger] a new instance of ConfigLogger
  #
  # source://honeybadger//lib/honeybadger/logging.rb#124
  def initialize(config, logger = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/logging.rb#131
  def add(severity, msg); end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/logging.rb#144
  def debug?; end

  private

  # @api private
  #
  # source://honeybadger//lib/honeybadger/logging.rb#170
  def caller_location; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/logging.rb#158
  def supplement(msg, severity); end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/logging.rb#150
  def suppress_debug?; end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/logging.rb#154
  def suppress_tty?(severity); end
end

# @api private
#
# source://honeybadger//lib/honeybadger/logging.rb#119
Honeybadger::Logging::ConfigLogger::CALLER_LOCATION = T.let(T.unsafe(nil), Regexp)

# @api private
#
# source://honeybadger//lib/honeybadger/logging.rb#122
Honeybadger::Logging::ConfigLogger::DEBUG_SUPPLEMENT = T.let(T.unsafe(nil), String)

# @api private
#
# source://honeybadger//lib/honeybadger/logging.rb#121
Honeybadger::Logging::ConfigLogger::INFO_SUPPLEMENT = T.let(T.unsafe(nil), String)

# @api private
#
# source://honeybadger//lib/honeybadger/logging.rb#118
Honeybadger::Logging::ConfigLogger::LOCATE_CALLER_LOCATION = T.let(T.unsafe(nil), Regexp)

# @api private
#
# source://honeybadger//lib/honeybadger/logging.rb#104
class Honeybadger::Logging::FormattedLogger < ::Honeybadger::Logging::StandardLogger
  # @api private
  #
  # source://honeybadger//lib/honeybadger/logging.rb#105
  def add(severity, msg, progname = T.unsafe(nil)); end

  private

  # @api private
  #
  # source://honeybadger//lib/honeybadger/logging.rb#111
  def format_message(msg); end
end

# Logging helper methods. Requires a Honeybadger::Config @config instance
# variable to exist and/or #logger to be defined. Each method is
# defined/block captured in this module rather than delegating to the
# logger directly to avoid extra object allocation.
#
# @api private
#
# source://honeybadger//lib/honeybadger/logging.rb#16
module Honeybadger::Logging::Helper
  private

  # @api private
  #
  # source://honeybadger//lib/honeybadger/logging.rb#18
  def d(msg = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/logging.rb#18
  def debug(msg = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/logging.rb#37
  def error(msg = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/logging.rb#25
  def info(msg = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/logging.rb#43
  def logger; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/logging.rb#31
  def warn(msg = T.unsafe(nil)); end
end

# @api private
#
# source://honeybadger//lib/honeybadger/logging.rb#10
Honeybadger::Logging::LOGGER_PROG = T.let(T.unsafe(nil), String)

# @api private
#
# source://honeybadger//lib/honeybadger/logging.rb#9
Honeybadger::Logging::PREFIX = T.let(T.unsafe(nil), String)

# @api private
#
# source://honeybadger//lib/honeybadger/logging.rb#87
class Honeybadger::Logging::StandardLogger < ::Honeybadger::Logging::Base
  extend ::Forwardable

  # @api private
  # @raise [ArgumentError]
  # @return [StandardLogger] a new instance of StandardLogger
  #
  # source://honeybadger//lib/honeybadger/logging.rb#90
  def initialize(logger = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/logging.rb#97
  def add(severity, msg, progname = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def debug?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def error?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def info?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def level(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def warn?(*args, **_arg1, &block); end
end

# @api private
#
# source://honeybadger//lib/honeybadger/notice.rb#43
Honeybadger::MAX_EXCEPTION_CAUSES = T.let(T.unsafe(nil), Integer)

# source://honeybadger//lib/honeybadger/metric.rb#2
class Honeybadger::Metric
  # @return [Metric] a new instance of Metric
  #
  # source://honeybadger//lib/honeybadger/metric.rb#18
  def initialize(name, attributes); end

  # Returns the value of attribute attributes.
  #
  # source://honeybadger//lib/honeybadger/metric.rb#3
  def attributes; end

  # source://honeybadger//lib/honeybadger/metric.rb#32
  def base_payload; end

  # source://honeybadger//lib/honeybadger/metric.rb#41
  def event_payloads; end

  # source://honeybadger//lib/honeybadger/metric.rb#24
  def metric_type; end

  # Returns the value of attribute name.
  #
  # source://honeybadger//lib/honeybadger/metric.rb#3
  def name; end

  # Returns the value of attribute samples.
  #
  # source://honeybadger//lib/honeybadger/metric.rb#3
  def samples; end

  # source://honeybadger//lib/honeybadger/metric.rb#28
  def signature; end

  class << self
    # source://honeybadger//lib/honeybadger/metric.rb#5
    def metric_type; end

    # source://honeybadger//lib/honeybadger/metric.rb#13
    def register(registry, metric_name, attributes); end

    # source://honeybadger//lib/honeybadger/metric.rb#9
    def signature(metric_type, name, attributes); end
  end
end

# A concurrent queue to execute plugin collect blocks and registry.
#
# @api private
#
# source://honeybadger//lib/honeybadger/metrics_worker.rb#6
class Honeybadger::MetricsWorker
  include ::Honeybadger::Logging::Helper
  extend ::Forwardable

  # @api private
  # @return [MetricsWorker] a new instance of MetricsWorker
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#17
  def initialize(config); end

  # Blocks until queue is processed up to this point in time.
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#60
  def flush; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#28
  def push(msg); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#35
  def send_now(msg); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#42
  def shutdown(force = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#69
  def start; end

  private

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#97
  def can_start?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#87
  def config; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#87
  def interval_seconds; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#103
  def kill!; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#87
  def marker; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#87
  def mutex; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#87
  def pid; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#87
  def queue; end

  # Release the marker. Important to perform during cleanup when shutting
  # down, otherwise it could end up waiting indefinitely.
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#165
  def release_marker; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#124
  def run; end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#89
  def shutdown?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#169
  def signal_marker(marker); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#87
  def start_at; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#114
  def suspend(interval); end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#93
  def suspended?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#87
  def thread; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/metrics_worker.rb#146
  def work(msg); end
end

# Used to signal the worker to shutdown.
#
# @api private
#
# source://honeybadger//lib/honeybadger/metrics_worker.rb#15
Honeybadger::MetricsWorker::SHUTDOWN = T.let(T.unsafe(nil), Symbol)

# Sub-class thread so we have a named thread (useful for debugging in Thread.list).
#
# @api private
#
# source://honeybadger//lib/honeybadger/metrics_worker.rb#12
class Honeybadger::MetricsWorker::Thread < ::Thread; end

# @api private
#
# source://honeybadger//lib/honeybadger/notice.rb#15
Honeybadger::NOTIFIER = T.let(T.unsafe(nil), Hash)

# A Regexp which matches non-blank characters.
#
# @api private
#
# source://honeybadger//lib/honeybadger/notice.rb#36
Honeybadger::NOT_BLANK = T.let(T.unsafe(nil), Regexp)

# source://honeybadger//lib/honeybadger/notice.rb#49
class Honeybadger::Notice
  include ::Honeybadger::Conversions
  extend ::Forwardable

  # @api private
  # @return [Notice] a new instance of Notice
  #
  # source://honeybadger//lib/honeybadger/notice.rb#187
  def initialize(config, opts = T.unsafe(nil)); end

  # The action (if any) that was called in this request.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#124
  def action; end

  # The action (if any) that was called in this request.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#124
  def action=(_arg0); end

  # The API key used to deliver this notice.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#136
  def api_key; end

  # The API key used to deliver this notice.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#136
  def api_key=(_arg0); end

  # Template used to create JSON payload.
  #
  # @api private
  # @return [Hash] JSON representation of notice.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#236
  def as_json(*args); end

  # The backtrace from the given exception or hash.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#91
  def backtrace; end

  # The backtrace from the given exception or hash.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#91
  def backtrace=(_arg0); end

  # @return [Breadcrumbs::Collector] The collection of captured breadcrumbs
  #
  # source://honeybadger//lib/honeybadger/notice.rb#142
  def breadcrumbs; end

  # @return [Breadcrumbs::Collector] The collection of captured breadcrumbs
  #
  # source://honeybadger//lib/honeybadger/notice.rb#142
  def breadcrumbs=(_arg0); end

  # The exception cause if available.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#81
  def cause; end

  # source://honeybadger//lib/honeybadger/notice.rb#82
  def cause=(cause); end

  # @return [Cause] A list of exception causes (see {Cause})
  #
  # source://honeybadger//lib/honeybadger/notice.rb#88
  def causes; end

  # CGI variables such as HTTP_METHOD.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#112
  def cgi_data; end

  # CGI variables such as HTTP_METHOD.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#112
  def cgi_data=(_arg0); end

  # The component (if any) which was used in this request (usually the controller).
  #
  # source://honeybadger//lib/honeybadger/notice.rb#119
  def component; end

  # The component (if any) which was used in this request (usually the controller).
  #
  # source://honeybadger//lib/honeybadger/notice.rb#119
  def component=(_arg0); end

  # The context Hash.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#109
  def context; end

  # The context Hash.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#109
  def context=(_arg0); end

  # The component (if any) which was used in this request (usually the controller).
  #
  # source://honeybadger//lib/honeybadger/notice.rb#119
  def controller; end

  # The component (if any) which was used in this request (usually the controller).
  #
  # source://honeybadger//lib/honeybadger/notice.rb#119
  def controller=(_arg0); end

  # Custom details data
  #
  # source://honeybadger//lib/honeybadger/notice.rb#145
  def details; end

  # Custom details data
  #
  # source://honeybadger//lib/honeybadger/notice.rb#145
  def details=(_arg0); end

  # The name of the class of error (example: RuntimeError).
  #
  # source://honeybadger//lib/honeybadger/notice.rb#103
  def error_class; end

  # The name of the class of error (example: RuntimeError).
  #
  # source://honeybadger//lib/honeybadger/notice.rb#103
  def error_class=(_arg0); end

  # The message from the exception, or a general description of the error.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#106
  def error_message; end

  # The message from the exception, or a general description of the error.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#106
  def error_message=(_arg0); end

  # The exception that caused this notice, if any.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#78
  def exception; end

  # Custom fingerprint for error, used to group similar errors together.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#94
  def fingerprint; end

  # Custom fingerprint for error, used to group similar errors together.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#94
  def fingerprint=(_arg0); end

  # Halts the notice and the before_notify callback chain.
  #
  # Returns nothing.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#284
  def halt!; end

  # Determines if this notice will be discarded.
  #
  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/notice.rb#290
  def halted?; end

  # The unique ID of this notice which can be used to reference the error in
  # Honeybadger.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#75
  def id; end

  # Determines if this notice should be ignored.
  #
  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/notice.rb#277
  def ignore?; end

  # Local variables are extracted from first frame of backtrace.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#133
  def local_variables; end

  # Local variables are extracted from first frame of backtrace.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#133
  def local_variables=(_arg0); end

  # A hash of parameters from the query string or post body.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#115
  def parameters; end

  # A hash of parameters from the query string or post body.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#115
  def params; end

  # A hash of parameters from the query string or post body.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#115
  def params=(_arg0); end

  # The parsed exception backtrace. Lines in this backtrace that are from installed gems
  # have the base path for gem installs replaced by "[GEM_ROOT]", while those in the project
  # have "[PROJECT_ROOT]".
  #
  # @return [Array<{:number, :file, :method => String}>]
  #
  # source://honeybadger//lib/honeybadger/notice.rb#151
  def parsed_backtrace; end

  # A hash of session data from the request.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#127
  def session; end

  # A hash of session data from the request.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#127
  def session=(_arg0); end

  # Deprecated: Excerpt from source file.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#139
  def source; end

  # Tags which will be applied to error.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#97
  def tags; end

  # source://honeybadger//lib/honeybadger/notice.rb#98
  def tags=(tags); end

  # Converts the notice to JSON.
  #
  # @return [Hash] The JSON representation of the notice.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#271
  def to_json(*a); end

  # The URL at which the error occurred (if any).
  #
  # source://honeybadger//lib/honeybadger/notice.rb#130
  def url; end

  # The URL at which the error occurred (if any).
  #
  # source://honeybadger//lib/honeybadger/notice.rb#130
  def url=(_arg0); end

  private

  # Returns the value of attribute config.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#296
  def config; end

  # source://honeybadger//lib/honeybadger/notice.rb#361
  def construct_backtrace_filters(opts); end

  # source://honeybadger//lib/honeybadger/notice.rb#411
  def construct_context_hash(opts, exception); end

  # Construct the request data.
  #
  # Returns Hash request data.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#374
  def construct_request_hash; end

  # source://honeybadger//lib/honeybadger/notice.rb#435
  def construct_tags(tags); end

  # Gets a property named "attribute" of an exception, either from
  # the #args hash or actual exception (in order of precedence).
  #
  # attribute - A Symbol existing as a key in #args and/or attribute on
  #             Exception.
  # default   - Default value if no other value is found (optional).
  # block     - An optional block which receives an Exception and returns the
  #             desired value.
  #
  # Returns attribute value from args or exception, otherwise default.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#320
  def exception_attribute(attribute, default = T.unsafe(nil), &block); end

  # Fetch cause from exception.
  #
  # exception - Exception to fetch cause from.
  #
  # Returns the Exception cause.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#528
  def exception_cause(exception); end

  # Get optional context from exception.
  #
  # Returns the Hash context.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#391
  def exception_context(exception); end

  # source://honeybadger//lib/honeybadger/notice.rb#419
  def fingerprint_from_opts(opts); end

  # source://honeybadger//lib/honeybadger/notice.rb#430
  def fingerprint_hash; end

  # Gets a property named +attribute+ from an exception.
  #
  # If a block is given, it will be used when getting the property from an
  # exception. The block should accept and exception and return the value for
  # the property.
  #
  # If no block is given, a method with the same name as +attribute+ will be
  # invoked for the value.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#332
  def from_exception(attribute); end

  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/notice.rb#305
  def ignore_by_callbacks?; end

  # Determines if error class should be ignored.
  #
  # ignored_class_name - The name of the ignored class. May be a
  # string or regexp (optional).
  #
  # Returns true or false.
  #
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/notice.rb#348
  def ignore_by_class?(ignored_class = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/notice.rb#299
  def ignore_by_origin?; end

  # Fetch local variables from first frame of backtrace.
  #
  # exception - The Exception containing the bindings stack.
  #
  # Returns a Hash of local variables.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#456
  def local_variables_from_exception(exception, config); end

  # Returns the value of attribute now.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#296
  def now; end

  # Returns the value of attribute opts.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#296
  def opts; end

  # source://honeybadger//lib/honeybadger/notice.rb#571
  def params_filters; end

  # Parse Backtrace from exception backtrace.
  #
  # backtrace - The Array backtrace from exception.
  #
  # Returns the Backtrace.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#503
  def parse_backtrace(backtrace); end

  # Returns the value of attribute pid.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#296
  def pid; end

  # Convert list of causes into payload format.
  #
  # causes - Array of Cause instances.
  #
  # Returns the Array of causes in Hash payload format.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#561
  def prepare_causes(causes); end

  # Returns the value of attribute rack_env.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#296
  def rack_env; end

  # source://honeybadger//lib/honeybadger/notice.rb#575
  def rails_params_filters; end

  # source://honeybadger//lib/honeybadger/notice.rb#367
  def request_hash; end

  # Returns the value of attribute request_sanitizer.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#296
  def request_sanitizer; end

  # source://honeybadger//lib/honeybadger/notice.rb#447
  def s(data); end

  # Sanitize metadata to keep it at a single level and remove any filtered
  # parameters
  #
  # source://honeybadger//lib/honeybadger/notice.rb#402
  def sanitized_breadcrumbs; end

  # Should local variables be sent?
  #
  # Returns true to send local_variables.
  #
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/notice.rb#494
  def send_local_variables?(config); end

  # Returns the value of attribute stats.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#296
  def stats; end

  # Create a list of causes.
  #
  # cause - The first cause to unwrap.
  #
  # Returns the Array of Cause instances.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#544
  def unwrap_causes(cause); end

  # Unwrap the exception so that original exception is ignored or
  # reported.
  #
  # exception - The exception which was rescued.
  #
  # Returns the Exception to report.
  #
  # source://honeybadger//lib/honeybadger/notice.rb#518
  def unwrap_exception(exception); end
end

# A list of backtrace filters to run all the time.
#
# @api private
#
# source://honeybadger//lib/honeybadger/notice.rb#165
Honeybadger::Notice::BACKTRACE_FILTERS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://honeybadger//lib/honeybadger/notice.rb#63
class Honeybadger::Notice::Cause
  # @api private
  # @return [Cause] a new instance of Cause
  #
  # source://honeybadger//lib/honeybadger/notice.rb#66
  def initialize(cause); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/notice.rb#64
  def backtrace; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/notice.rb#64
  def backtrace=(_arg0); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/notice.rb#64
  def error_class; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/notice.rb#64
  def error_class=(_arg0); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/notice.rb#64
  def error_message; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/notice.rb#64
  def error_message=(_arg0); end
end

# Cache gem path substitutions for backtrace lines.
#
# @api private
#
# source://honeybadger//lib/honeybadger/notice.rb#161
Honeybadger::Notice::GEM_ROOT_CACHE = T.let(T.unsafe(nil), Hash)

# Cache project path substitutions for backtrace lines.
#
# @api private
#
# source://honeybadger//lib/honeybadger/notice.rb#157
Honeybadger::Notice::PROJECT_ROOT_CACHE = T.let(T.unsafe(nil), Hash)

# The Regexp used to strip invalid characters from individual tags.
#
# @api private
#
# source://honeybadger//lib/honeybadger/notice.rb#60
Honeybadger::Notice::TAG_SANITIZER = T.let(T.unsafe(nil), Regexp)

# The String character used to split tag strings.
#
# @api private
#
# source://honeybadger//lib/honeybadger/notice.rb#56
Honeybadger::Notice::TAG_SEPERATOR = T.let(T.unsafe(nil), Regexp)

# Substitution for project root in backtrace lines.
#
# @api private
#
# source://honeybadger//lib/honeybadger/notice.rb#28
Honeybadger::PROJECT_ROOT = T.let(T.unsafe(nil), String)

# +Honeybadger::Plugin+ defines the API for registering plugins with
# Honeybadger. Each plugin has requirements which must be satisfied before
# executing the plugin's execution block(s). This allows us to detect
# optional dependencies and load the plugin for each dependency only if it's
# present in the application.
#
# Plugins may also define a collect block that is repeatedly called from
# within a thread. The MetricsWorker contains a loop that will call all
# enabled plugins' collect method, and then sleep for 1 second. This block
# is useful for collecting and/or sending metrics at regular intervals.
#
# See the plugins/ directory for examples of official plugins. If you're
# interested in developing a plugin for Honeybadger, see the Integration
# Guide: https://docs.honeybadger.io/ruby/gem-reference/integration.html
#
# @example
#
#   require 'honeybadger/plugin'
#   require 'honeybadger/ruby'
#
#   module Honeybadger
#   module Plugins
#   # Register your plugin with an optional name. If the name (such as
#   # "my_framework") is not provided, Honeybadger will try to infer the name
#   # from the current file.
#   Plugin.register 'my_framework' do
#   requirement do
#   # Check to see if the thing you're integrating with is loaded. Return true
#   # if it is, or false if it isn't. An exception in this block is equivalent
#   # to returning false. Multiple requirement blocks are supported.
#   defined?(MyFramework)
#   end
#
#   execution do
#   # Write your integration. This code will be executed only if all requirement
#   # blocks return true. An exception in this block will disable the plugin.
#   # Multiple execution blocks are supported.
#   MyFramework.on_exception do |exception|
#   Honeybadger.notify(exception)
#   end
#   end
#
#   collect do
#   # This block will be periodically called at regular intervals. Here you can
#   # gather metrics or inspect services. See the Honeybadger::InstrumentationHelper
#   # module to see availble methods for metric collection.
#   gauge 'scheduled_jobs', -> { MyFramework.stats.scheduled_jobs.count }
#   gauge 'latency', -> { MyFramework.stats.latency }
#   end
#   end
#   end
#   end
#
# source://honeybadger//lib/honeybadger/plugin.rb#57
class Honeybadger::Plugin
  # @api private
  # @return [Plugin] a new instance of Plugin
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#159
  def initialize(name); end

  # Define an collect block. Collect blocks will be added to an execution
  # queue if requirement blocks return +true+. The block will be called as frequently
  # as once per second, but can be configured to increase it's interval.
  #
  # @example
  #
  #   Honeybadger::Plugin.register 'my_framework' do
  #   requirement { defined?(MyFramework) }
  #
  #   collect do
  #   stats = MyFramework.stats
  #   gauge 'capacity', -> { stats.capcity }
  #   end
  #
  #   collect(interval: 10) do
  #   stats = MyFramework.more_expensive_stats
  #   gauge 'other_stat', -> { stats.expensive_metric }
  #   end
  #   end
  # @return nil
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#234
  def collect(options = T.unsafe(nil), &block); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#268
  def collectors; end

  # Define an execution block. Execution blocks will be executed if all
  # requirement blocks return +true+.
  #
  # @example
  #
  #   Honeybadger::Plugin.register 'my_framework' do
  #   requirement { defined?(MyFramework) }
  #
  #   execution do
  #   MyFramework.on_exception {|err| Honeybadger.notify(err) }
  #   end
  #
  #   execution do
  #   # Honeybadger's configuration object is available inside
  #   # execution blocks. It should generally not be used outside of
  #   # internal plugins. See +Config+.
  #   MyFramework.use_middleware(MyMiddleware) if config[:'my_framework.use_middleware']
  #   end
  #   end
  # @return nil
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#209
  def execution(&block); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#284
  def executions; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#247
  def load!(config); end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#273
  def loaded?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#284
  def name; end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#239
  def ok?(config); end

  # Define a requirement. All requirement blocks must return +true+ for the
  # plugin to be executed.
  #
  # @example
  #
  #   Honeybadger::Plugin.register 'my_framework' do
  #   requirement { defined?(MyFramework) }
  #
  #   # Honeybadger's configuration object is available inside
  #   # requirement blocks. It should generally not be used outside of
  #   # internal plugins. See +Config+.
  #   requirement { config[:'my_framework.enabled'] }
  #
  #   execution { }
  #   end
  # @return nil
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#184
  def requirement(&block); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#284
  def requirements; end

  # Used for testing only; don't normally call this. :)
  #
  # @private
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#279
  def reset!; end

  class << self
    # @api private
    #
    # source://honeybadger//lib/honeybadger/plugin.rb#66
    def instances; end

    # @api private
    #
    # source://honeybadger//lib/honeybadger/plugin.rb#93
    def load!(config); end

    # @api private
    #
    # source://honeybadger//lib/honeybadger/plugin.rb#104
    def name_from_caller(caller); end

    # Register a new plugin with Honeybadger. See {#requirement}, {#execution}, and
    # {#collect}..
    #
    # @example
    #
    #   Honeybadger::Plugin.register 'my_framework' do
    #   requirement { }
    #   execution { }
    #   collect { }
    #   end
    # @param name [String, Symbol] The optional name of the plugin. Should use
    #   +snake_case+. The name is inferred from the current file name if omitted.
    # @return nil
    #
    # source://honeybadger//lib/honeybadger/plugin.rb#85
    def register(name = T.unsafe(nil), &block); end
  end
end

# @api private
#
# source://honeybadger//lib/honeybadger/plugin.rb#59
Honeybadger::Plugin::CALLER_FILE = T.let(T.unsafe(nil), Regexp)

# @api private
#
# source://honeybadger//lib/honeybadger/plugin.rb#131
class Honeybadger::Plugin::CollectorExecution < ::Honeybadger::Plugin::Execution
  include ::Honeybadger::InstrumentationHelper

  # @api private
  # @return [CollectorExecution] a new instance of CollectorExecution
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#136
  def initialize(name, config, options, &block); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#153
  def register!; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#149
  def reset; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#145
  def tick; end
end

# @api private
#
# source://honeybadger//lib/honeybadger/plugin.rb#134
Honeybadger::Plugin::CollectorExecution::DEFAULT_COLLECTION_INTERVAL = T.let(T.unsafe(nil), Integer)

# @api private
#
# source://honeybadger//lib/honeybadger/plugin.rb#112
class Honeybadger::Plugin::Execution
  extend ::Forwardable

  # @api private
  # @return [Execution] a new instance of Execution
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#115
  def initialize(config, &block); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#120
  def call; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def logger(*args, **_arg1, &block); end

  private

  # @api private
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#126
  def block; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/plugin.rb#126
  def config; end
end

# @api private
#
# source://honeybadger//lib/honeybadger/const.rb#14
module Honeybadger::Plugins; end

# Matches lines beginning with ./
#
# @api private
#
# source://honeybadger//lib/honeybadger/notice.rb#40
Honeybadger::RELATIVE_ROOT = T.let(T.unsafe(nil), Regexp)

# source://honeybadger//lib/honeybadger/const.rb#4
module Honeybadger::Rack; end

# Middleware for Rack applications. Any errors raised by the upstream
# application will be delivered to Honeybadger and re-raised.
#
# @example
#   require 'honeybadger/rack/error_notifier'
#
#   app = Rack::Builder.app do
#   run lambda { |env| raise "Rack down" }
#   end
#
#   use Honeybadger::Rack::ErrorNotifier
#
#   run app
#
# source://honeybadger//lib/honeybadger/rack/error_notifier.rb#21
class Honeybadger::Rack::ErrorNotifier
  extend ::Forwardable

  # @return [ErrorNotifier] a new instance of ErrorNotifier
  #
  # source://honeybadger//lib/honeybadger/rack/error_notifier.rb#24
  def initialize(app, agent = T.unsafe(nil)); end

  # source://honeybadger//lib/honeybadger/rack/error_notifier.rb#29
  def call(env); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def config(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def logger(*args, **_arg1, &block); end

  private

  # source://honeybadger//lib/honeybadger/rack/error_notifier.rb#55
  def agent; end

  # source://honeybadger//lib/honeybadger/rack/error_notifier.rb#86
  def framework_exception(env); end

  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/rack/error_notifier.rb#59
  def ignored_user_agent?(env); end

  # source://honeybadger//lib/honeybadger/rack/error_notifier.rb#65
  def notify_honeybadger(exception, env); end
end

# Middleware for Rack applications. Adds a feedback form to the Rack
# response when an error has occurred.
#
# source://honeybadger//lib/honeybadger/rack/user_feedback.rb#21
class Honeybadger::Rack::UserFeedback
  extend ::Forwardable

  # @return [UserFeedback] a new instance of UserFeedback
  #
  # source://honeybadger//lib/honeybadger/rack/user_feedback.rb#24
  def initialize(app, agent = T.unsafe(nil)); end

  # @private
  # @todo Make this method and others actually private.
  #
  # source://honeybadger//lib/honeybadger/rack/user_feedback.rb#45
  def action; end

  # source://honeybadger//lib/honeybadger/rack/user_feedback.rb#29
  def call(env); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def config(*args, **_arg1, &block); end

  # @private
  #
  # source://honeybadger//lib/honeybadger/rack/user_feedback.rb#58
  def custom_template_file; end

  # @private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/rack/user_feedback.rb#63
  def custom_template_file?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def logger(*args, **_arg1, &block); end

  # @private
  #
  # source://honeybadger//lib/honeybadger/rack/user_feedback.rb#52
  def render_form(error_id, action = T.unsafe(nil)); end

  # @private
  #
  # source://honeybadger//lib/honeybadger/rack/user_feedback.rb#68
  def template_file; end

  private

  # source://honeybadger//lib/honeybadger/rack/user_feedback.rb#81
  def agent; end
end

# Middleware for Rack applications. Adds an error ID to the Rack response
# when an error has occurred.
#
# source://honeybadger//lib/honeybadger/rack/user_informer.rb#7
class Honeybadger::Rack::UserInformer
  extend ::Forwardable

  # @return [UserInformer] a new instance of UserInformer
  #
  # source://honeybadger//lib/honeybadger/rack/user_informer.rb#10
  def initialize(app, agent = T.unsafe(nil)); end

  # source://honeybadger//lib/honeybadger/rack/user_informer.rb#19
  def call(env); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def config(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def logger(*args, **_arg1, &block); end

  # source://honeybadger//lib/honeybadger/rack/user_informer.rb#15
  def replacement(with); end

  private

  # source://honeybadger//lib/honeybadger/rack/user_informer.rb#39
  def agent; end
end

# Patch Rake::Application to handle errors with Honeybadger
#
# @api private
#
# source://honeybadger//lib/honeybadger/init/rake.rb#6
module Honeybadger::RakeHandler
  # @api private
  #
  # source://honeybadger//lib/honeybadger/init/rake.rb#15
  def display_error_message_with_honeybadger(ex); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/init/rake.rb#22
  def reconstruct_command_line; end

  class << self
    # @api private
    # @private
    #
    # source://honeybadger//lib/honeybadger/init/rake.rb#7
    def included(klass); end
  end
end

# This module brings Rake 0.8.7 error handling to 0.9.0 standards
#
# @api private
#
# source://honeybadger//lib/honeybadger/init/rake.rb#27
module Honeybadger::RakeHandler::Rake087Methods
  # Method extracted from Rake 0.8.7 source
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/init/rake.rb#48
  def display_error_message(ex); end

  # Method taken from Rake 0.9.0 source
  #
  # Provide standard exception handling for the given block.
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/init/rake.rb#31
  def standard_exception_handling; end
end

# source://honeybadger//lib/honeybadger/registry.rb#2
class Honeybadger::Registry
  # @return [Registry] a new instance of Registry
  #
  # source://honeybadger//lib/honeybadger/registry.rb#3
  def initialize; end

  # source://honeybadger//lib/honeybadger/registry.rb#20
  def flush; end

  # source://honeybadger//lib/honeybadger/registry.rb#14
  def get(metric_type, name, attributes); end

  # source://honeybadger//lib/honeybadger/registry.rb#26
  def metrics; end

  # source://honeybadger//lib/honeybadger/registry.rb#8
  def register(metric); end
end

# source://honeybadger//lib/honeybadger/registry_execution.rb#2
class Honeybadger::RegistryExecution
  # @return [RegistryExecution] a new instance of RegistryExecution
  #
  # source://honeybadger//lib/honeybadger/registry_execution.rb#3
  def initialize(registry, config, options); end

  # source://honeybadger//lib/honeybadger/registry_execution.rb#20
  def call; end

  # source://honeybadger//lib/honeybadger/registry_execution.rb#15
  def reset; end

  # source://honeybadger//lib/honeybadger/registry_execution.rb#11
  def tick; end
end

# Empty String (used for equality comparisons and assignment).
#
# @api private
#
# source://honeybadger//lib/honeybadger/notice.rb#32
Honeybadger::STRING_EMPTY = T.let(T.unsafe(nil), String)

# source://honeybadger//lib/honeybadger/timer.rb#4
class Honeybadger::Timer < ::Honeybadger::Gauge; end

# @api private
#
# source://honeybadger//lib/honeybadger/const.rb#18
module Honeybadger::Util; end

# @api private
#
# source://honeybadger//lib/honeybadger/util/http.rb#12
class Honeybadger::Util::HTTP
  include ::Honeybadger::Logging::Helper
  extend ::Forwardable

  # @api private
  # @return [HTTP] a new instance of HTTP
  #
  # source://honeybadger//lib/honeybadger/util/http.rb#36
  def initialize(config); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/util/http.rb#40
  def get(endpoint); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/util/http.rb#46
  def post(endpoint, payload, headers = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/util/http.rb#52
  def post_newline_delimited(endpoint, payload, headers = T.unsafe(nil)); end

  private

  # @api private
  #
  # source://honeybadger//lib/honeybadger/util/http.rb#93
  def compress(string, level = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/util/http.rb#60
  def config; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/util/http.rb#62
  def http_connection; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/util/http.rb#66
  def http_headers(headers = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/util/http.rb#74
  def setup_http_connection; end
end

# @api private
#
# source://honeybadger//lib/honeybadger/util/http.rb#24
Honeybadger::Util::HTTP::ERRORS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://honeybadger//lib/honeybadger/util/http.rb#17
Honeybadger::Util::HTTP::HEADERS = T.let(T.unsafe(nil), Hash)

# Constructs a request hash from a Rack::Request matching the /v1/notices
# API specification.
#
# @api private
#
# source://honeybadger//lib/honeybadger/util/request_hash.rb#7
module Honeybadger::Util::RequestHash
  class << self
    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/request_hash.rb#64
    def extract_cgi_data(request); end

    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/request_hash.rb#49
    def extract_params(request); end

    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/request_hash.rb#55
    def extract_session(request); end

    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/request_hash.rb#43
    def extract_url(request); end

    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/request_hash.rb#27
    def from_env(env); end
  end
end

# @api private
#
# source://honeybadger//lib/honeybadger/util/request_hash.rb#10
Honeybadger::Util::RequestHash::CGI_WHITELIST = T.let(T.unsafe(nil), Array)

# @api private
#
# source://honeybadger//lib/honeybadger/util/request_hash.rb#8
Honeybadger::Util::RequestHash::HTTP_HEADER_PREFIX = T.let(T.unsafe(nil), String)

# Constructs/sanitizes request data for notices
#
# @api private
#
# source://honeybadger//lib/honeybadger/util/request_payload.rb#6
module Honeybadger::Util::RequestPayload
  class << self
    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/request_payload.rb#23
    def build(opts = T.unsafe(nil)); end
  end
end

# Default values to use for request data.
#
# @api private
#
# source://honeybadger//lib/honeybadger/util/request_payload.rb#8
Honeybadger::Util::RequestPayload::DEFAULTS = T.let(T.unsafe(nil), Hash)

# The cgi_data key where the raw Cookie header is stored.
#
# @api private
#
# source://honeybadger//lib/honeybadger/util/request_payload.rb#21
Honeybadger::Util::RequestPayload::HTTP_COOKIE_KEY = T.let(T.unsafe(nil), String)

# Allowed keys.
#
# @api private
#
# source://honeybadger//lib/honeybadger/util/request_payload.rb#18
Honeybadger::Util::RequestPayload::KEYS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://honeybadger//lib/honeybadger/util/revision.rb#3
class Honeybadger::Util::Revision
  class << self
    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/revision.rb#5
    def detect(root = T.unsafe(nil)); end

    private

    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/revision.rb#26
    def from_capistrano(root); end

    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/revision.rb#32
    def from_git; end

    # Requires (currently) alpha platform feature `heroku labs:enable
    # runtime-dyno-metadata`
    #
    # See https://devcenter.heroku.com/articles/dyno-metadata
    #
    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/revision.rb#22
    def from_heroku; end
  end
end

# @api private
#
# source://honeybadger//lib/honeybadger/util/sql.rb#3
class Honeybadger::Util::SQL
  class << self
    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/sql.rb#21
    def force_utf_8(string); end

    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/sql.rb#10
    def obfuscate(sql, adapter); end
  end
end

# @api private
#
# source://honeybadger//lib/honeybadger/util/sql.rb#8
Honeybadger::Util::SQL::DOUBLE_QUOTERS = T.let(T.unsafe(nil), Regexp)

# @api private
#
# source://honeybadger//lib/honeybadger/util/sql.rb#6
Honeybadger::Util::SQL::DQUOTE_DATA = T.let(T.unsafe(nil), Regexp)

# @api private
#
# source://honeybadger//lib/honeybadger/util/sql.rb#4
Honeybadger::Util::SQL::ESCAPE_QUOTES = T.let(T.unsafe(nil), Regexp)

# @api private
#
# source://honeybadger//lib/honeybadger/util/sql.rb#7
Honeybadger::Util::SQL::NUMBER_DATA = T.let(T.unsafe(nil), Regexp)

# @api private
#
# source://honeybadger//lib/honeybadger/util/sql.rb#5
Honeybadger::Util::SQL::SQUOTE_DATA = T.let(T.unsafe(nil), Regexp)

# Sanitizer sanitizes data for sending to Honeybadger's API. The filters
# are based on Rails' HTTP parameter filter.
#
# @api private
#
# source://honeybadger//lib/honeybadger/util/sanitizer.rb#9
class Honeybadger::Util::Sanitizer
  # @api private
  # @return [Sanitizer] a new instance of Sanitizer
  #
  # source://honeybadger//lib/honeybadger/util/sanitizer.rb#34
  def initialize(max_depth: T.unsafe(nil), filters: T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/util/sanitizer.rb#132
  def filter_cookies(raw_cookies); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/util/sanitizer.rb#146
  def filter_url(url); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/util/sanitizer.rb#58
  def sanitize(data, depth = T.unsafe(nil), stack = T.unsafe(nil), parents = T.unsafe(nil)); end

  private

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/util/sanitizer.rb#196
  def basic_object?(object); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/util/sanitizer.rb#161
  def blocks; end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/util/sanitizer.rb#204
  def can_dup?(obj); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/util/sanitizer.rb#161
  def deep_regexps; end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/util/sanitizer.rb#167
  def filter_key?(key, parents = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/util/sanitizer.rb#163
  def filters?; end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/util/sanitizer.rb#208
  def inspected?(string); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/util/sanitizer.rb#161
  def max_depth; end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/util/sanitizer.rb#192
  def recursive?(data); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/util/sanitizer.rb#161
  def regexps; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/util/sanitizer.rb#174
  def sanitize_string(string); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/util/sanitizer.rb#187
  def valid_encoding(string); end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/util/sanitizer.rb#180
  def valid_encoding?(string); end

  class << self
    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/sanitizer.rb#29
    def sanitize(data); end
  end
end

# @api private
#
# source://honeybadger//lib/honeybadger/util/sanitizer.rb#16
Honeybadger::Util::Sanitizer::BASIC_OBJECT = T.let(T.unsafe(nil), String)

# @api private
#
# source://honeybadger//lib/honeybadger/util/sanitizer.rb#10
Honeybadger::Util::Sanitizer::COOKIE_PAIRS = T.let(T.unsafe(nil), Regexp)

# @api private
#
# source://honeybadger//lib/honeybadger/util/sanitizer.rb#12
Honeybadger::Util::Sanitizer::COOKIE_PAIR_SEP = T.let(T.unsafe(nil), String)

# @api private
#
# source://honeybadger//lib/honeybadger/util/sanitizer.rb#11
Honeybadger::Util::Sanitizer::COOKIE_SEP = T.let(T.unsafe(nil), String)

# @api private
#
# source://honeybadger//lib/honeybadger/util/sanitizer.rb#17
Honeybadger::Util::Sanitizer::DEPTH = T.let(T.unsafe(nil), String)

# @api private
#
# source://honeybadger//lib/honeybadger/util/sanitizer.rb#14
Honeybadger::Util::Sanitizer::ENCODE_OPTS = T.let(T.unsafe(nil), Hash)

# @api private
#
# source://honeybadger//lib/honeybadger/util/sanitizer.rb#18
Honeybadger::Util::Sanitizer::FILTERED = T.let(T.unsafe(nil), String)

# @api private
#
# source://honeybadger//lib/honeybadger/util/sanitizer.rb#23
Honeybadger::Util::Sanitizer::IMMUTABLE = T.let(T.unsafe(nil), Array)

# @api private
#
# source://honeybadger//lib/honeybadger/util/sanitizer.rb#25
Honeybadger::Util::Sanitizer::MAX_STRING_SIZE = T.let(T.unsafe(nil), Integer)

# @api private
#
# source://honeybadger//lib/honeybadger/util/sanitizer.rb#19
Honeybadger::Util::Sanitizer::RAISED = T.let(T.unsafe(nil), String)

# @api private
#
# source://honeybadger//lib/honeybadger/util/sanitizer.rb#20
Honeybadger::Util::Sanitizer::RECURSION = T.let(T.unsafe(nil), String)

# @api private
#
# source://honeybadger//lib/honeybadger/util/sanitizer.rb#21
Honeybadger::Util::Sanitizer::TRUNCATED = T.let(T.unsafe(nil), String)

# @api private
#
# source://honeybadger//lib/honeybadger/util/sanitizer.rb#27
Honeybadger::Util::Sanitizer::VALID_ENCODINGS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://honeybadger//lib/honeybadger/util/stats.rb#3
class Honeybadger::Util::Stats
  class << self
    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/stats.rb#8
    def all; end

    # From https://github.com/bloopletech/webstats/blob/master/server/data_providers/cpu_info.rb
    #
    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/stats.rb#23
    def load; end

    # From https://github.com/bloopletech/webstats/blob/master/server/data_providers/mem_info.rb
    #
    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/stats.rb#13
    def memory; end

    private

    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/stats.rb#41
    def run; end

    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/stats.rb#37
    def run_loadavg; end

    # @api private
    #
    # source://honeybadger//lib/honeybadger/util/stats.rb#33
    def run_meminfo; end
  end
end

# @api private
#
# source://honeybadger//lib/honeybadger/util/stats.rb#5
Honeybadger::Util::Stats::HAS_LOAD = T.let(T.unsafe(nil), TrueClass)

# @api private
#
# source://honeybadger//lib/honeybadger/util/stats.rb#4
Honeybadger::Util::Stats::HAS_MEM = T.let(T.unsafe(nil), TrueClass)

# The current String Honeybadger version.
#
# source://honeybadger//lib/honeybadger/version.rb#3
Honeybadger::VERSION = T.let(T.unsafe(nil), String)

# A concurrent queue to notify the backend.
#
# @api private
#
# source://honeybadger//lib/honeybadger/worker.rb#9
class Honeybadger::Worker
  include ::Honeybadger::Logging::Helper
  extend ::Forwardable

  # @api private
  # @return [Worker] a new instance of Worker
  #
  # source://honeybadger//lib/honeybadger/worker.rb#25
  def initialize(config); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def backend(*args, **_arg1, &block); end

  # Blocks until queue is processed up to this point in time.
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#77
  def flush; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#37
  def push(msg); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#48
  def send_now(msg); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#52
  def shutdown(force = T.unsafe(nil)); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#86
  def start; end

  private

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#192
  def calc_throttle_interval; end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/worker.rb#117
  def can_start?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#104
  def config; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#204
  def dec_throttle; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#213
  def handle_response(msg, response); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#196
  def inc_throttle; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#127
  def kill!; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#104
  def marker; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#104
  def mutex; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#187
  def notify_backend(payload); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#104
  def pid; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#104
  def queue; end

  # Release the marker. Important to perform during cleanup when shutting
  # down, otherwise it could end up waiting indefinitely.
  #
  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#246
  def release_marker; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#148
  def run; end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/worker.rb#109
  def shutdown?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#250
  def signal_marker(marker); end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#104
  def start_at; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#138
  def suspend(interval); end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/worker.rb#113
  def suspended?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#104
  def thread; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#104
  def throttle; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#104
  def throttle_interval; end

  # @api private
  # @return [Boolean]
  #
  # source://honeybadger//lib/honeybadger/worker.rb#123
  def throttled?; end

  # @api private
  #
  # source://honeybadger//lib/honeybadger/worker.rb#170
  def work(msg); end
end

# The base number for the exponential backoff formula when calculating the
# throttle interval. `1.05 ** throttle` will reach an interval of 2 minutes
# after around 100 429 responses from the server.
#
# @api private
#
# source://honeybadger//lib/honeybadger/worker.rb#23
Honeybadger::Worker::BASE_THROTTLE = T.let(T.unsafe(nil), Float)

# Used to signal the worker to shutdown.
#
# @api private
#
# source://honeybadger//lib/honeybadger/worker.rb#18
Honeybadger::Worker::SHUTDOWN = T.let(T.unsafe(nil), Symbol)

# Sub-class thread so we have a named thread (useful for debugging in Thread.list).
#
# @api private
#
# source://honeybadger//lib/honeybadger/worker.rb#15
class Honeybadger::Worker::Thread < ::Thread; end
