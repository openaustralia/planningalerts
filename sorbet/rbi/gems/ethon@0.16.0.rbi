# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ethon` gem.
# Please instead update this file by running `bin/tapioca gem ethon`.


# Ethon is a very simple libcurl.
# It provides direct access to libcurl functionality
# as well as some helpers for doing http requests.
#
# Ethon was extracted from Typhoeus. If you want to
# see how others use Ethon look at the Typhoeus code.
#
# @note Please update to the latest libcurl version in order
#   to benefit from all features and bugfixes.
#   http://curl.haxx.se/download.html
# @see https://www.github.com/typhoeus/typhoeus Typhoeus
#
# source://ethon//lib/ethon/libc.rb#2
module Ethon
  extend ::Ethon::Loggable
end

# FFI Wrapper module for Curl. Holds constants and required initializers.
#
# @api private
#
# source://ethon//lib/ethon/curl.rb#14
module Ethon::Curl
  extend ::FFI::Library
  extend ::Ethon::Curls::Codes
  extend ::Ethon::Curls::Options
  extend ::Ethon::Curls::Infos
  extend ::Ethon::Curls::FormOptions
  extend ::Ethon::Curls::Messages
  extend ::Ethon::Curls::Functions

  def easy_cleanup(*_arg0); end
  def easy_duphandle(*_arg0); end
  def easy_escape(*_arg0); end

  # source://ffi/1.17.0/lib/ffi/variadic.rb#61
  def easy_getinfo(*args); end

  def easy_init(*_arg0); end
  def easy_perform(*_arg0); end
  def easy_reset(*_arg0); end

  # source://ffi/1.17.0/lib/ffi/variadic.rb#61
  def easy_setopt(*args); end

  def easy_strerror(*_arg0); end

  # source://ffi/1.17.0/lib/ffi/variadic.rb#61
  def formadd(*args); end

  def formfree(*_arg0); end
  def free(*_arg0); end
  def global_cleanup(*_arg0); end
  def global_init(*_arg0); end
  def multi_add_handle(*_arg0); end
  def multi_cleanup(*_arg0); end
  def multi_fdset(*_arg0); end
  def multi_info_read(*_arg0); end
  def multi_init(*_arg0); end
  def multi_perform(*_arg0); end
  def multi_remove_handle(*_arg0); end

  # source://ffi/1.17.0/lib/ffi/variadic.rb#61
  def multi_setopt(*args); end

  def multi_socket_action(*_arg0); end
  def multi_strerror(*_arg0); end
  def multi_timeout(*_arg0); end
  def select(*_arg0); end
  def slist_append(*_arg0); end
  def slist_free_all(*_arg0); end
  def version(*_arg0); end
  def version_info(*_arg0); end

  class << self
    # This function releases resources acquired by curl_global_init.
    # You should call curl_global_cleanup once for each call you make to
    # curl_global_init, after you are done using libcurl.
    # This function is not thread safe. You must not call it when any other thread in the
    # program (i.e. a thread sharing the same memory) is running. This doesn't just
    # mean no other thread that is using libcurl. Because curl_global_cleanup calls functions of other
    # libraries that are similarly thread unsafe, it could conflict with
    # any other thread that uses these other libraries.
    # See the description in libcurl of global environment requirements
    # for details of how to use this function.
    #
    # @api private
    #
    # source://ethon//lib/ethon/curl.rb#78
    def cleanup; end

    def easy_cleanup(*_arg0); end
    def easy_duphandle(*_arg0); end
    def easy_escape(*_arg0); end

    # source://ffi/1.17.0/lib/ffi/variadic.rb#61
    def easy_getinfo(*args); end

    def easy_init(*_arg0); end
    def easy_perform(*_arg0); end
    def easy_reset(*_arg0); end

    # source://ffi/1.17.0/lib/ffi/variadic.rb#61
    def easy_setopt(*args); end

    def easy_strerror(*_arg0); end

    # source://ffi/1.17.0/lib/ffi/variadic.rb#61
    def formadd(*args); end

    def formfree(*_arg0); end
    def free(*_arg0); end
    def global_cleanup(*_arg0); end
    def global_init(*_arg0); end

    # This function sets up the program environment that libcurl needs.
    # Think of it as an extension of the library loader.
    #
    # This function must be called at least once within a program (a program is all the
    # code that shares a memory space) before the program calls any other function in libcurl.
    # The environment it sets up is constant for the life of the program and is the same for
    # every program, so multiple calls have the same effect as one call.
    #
    # The flags option is a bit pattern that tells libcurl exactly what features to init,
    # as described below. Set the desired bits by ORing the values together. In normal
    # operation, you must specify CURL_GLOBAL_ALL. Don't use any other value unless
    # you are familiar with it and mean to control internal operations of libcurl.
    #
    # This function is not thread safe. You must not call it when any other thread in
    # the program (i.e. a thread sharing the same memory) is running. This doesn't just
    # mean no other thread that is using libcurl. Because curl_global_init() calls
    # functions of other libraries that are similarly thread unsafe, it could conflict with
    # any other thread that uses these other libraries.
    #
    # @api private
    # @raise [Ethon::Errors::GlobalInit] If Curl.global_init fails.
    #
    # source://ethon//lib/ethon/curl.rb#58
    def init; end

    def multi_add_handle(*_arg0); end
    def multi_cleanup(*_arg0); end
    def multi_fdset(*_arg0); end
    def multi_info_read(*_arg0); end
    def multi_init(*_arg0); end
    def multi_perform(*_arg0); end
    def multi_remove_handle(*_arg0); end

    # source://ffi/1.17.0/lib/ffi/variadic.rb#61
    def multi_setopt(*args); end

    def multi_socket_action(*_arg0); end
    def multi_strerror(*_arg0); end
    def multi_timeout(*_arg0); end
    def select(*_arg0); end
    def slist_append(*_arg0); end
    def slist_free_all(*_arg0); end
    def version(*_arg0); end
    def version_info(*_arg0); end

    # @api private
    # @return [Boolean]
    #
    # source://ethon//lib/ethon/curl.rb#23
    def windows?; end
  end
end

# Used by curl_debug_callback when setting CURLOPT_DEBUGFUNCTION
# https://github.com/bagder/curl/blob/master/include/curl/curl.h#L378 for details
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#28
Ethon::Curl::DebugInfoType = T.let(T.unsafe(nil), FFI::Enum)

# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#17
Ethon::Curl::EasyCode = T.let(T.unsafe(nil), FFI::Enum)

# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#22
Ethon::Curl::EasyOption = T.let(T.unsafe(nil), FFI::Enum)

# @api private
#
# source://ethon//lib/ethon/curls/classes.rb#27
class Ethon::Curl::FDSet < ::FFI::Struct
  # @api private
  #
  # source://ethon//lib/ethon/curls/classes.rb#50
  def clear; end
end

# https://github.com/typhoeus/ethon/issues/182
#
# @api private
#
# source://ethon//lib/ethon/curls/classes.rb#36
Ethon::Curl::FDSet::FD_SETSIZE = T.let(T.unsafe(nil), Integer)

# Form options, used by FormAdd for temporary storage, refer
# https://github.com/bagder/curl/blob/master/lib/formdata.h#L51 for details
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#39
Ethon::Curl::FormOption = T.let(T.unsafe(nil), FFI::Enum)

# Flag. Initialize everything possible.
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#12
Ethon::Curl::GLOBAL_ALL = T.let(T.unsafe(nil), Integer)

# Flag. Initialize everything by default.
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#14
Ethon::Curl::GLOBAL_DEFAULT = T.let(T.unsafe(nil), Integer)

# Flag. Initialize SSL.
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#8
Ethon::Curl::GLOBAL_SSL = T.let(T.unsafe(nil), Integer)

# Flag. Initialize win32 socket libraries.
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#10
Ethon::Curl::GLOBAL_WIN32 = T.let(T.unsafe(nil), Integer)

# Info details, refer
# https://github.com/bagder/curl/blob/master/src/tool_writeout.c#L66 for details
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#35
Ethon::Curl::Info = T.let(T.unsafe(nil), FFI::Enum)

# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#31
Ethon::Curl::InfoType = T.let(T.unsafe(nil), FFI::Enum)

# @api private
#
# source://ethon//lib/ethon/curls/classes.rb#10
class Ethon::Curl::Msg < ::FFI::Struct; end

# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#42
Ethon::Curl::MsgCode = T.let(T.unsafe(nil), FFI::Enum)

# @api private
#
# source://ethon//lib/ethon/curls/classes.rb#5
class Ethon::Curl::MsgData < ::FFI::Union; end

# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#19
Ethon::Curl::MultiCode = T.let(T.unsafe(nil), FFI::Enum)

# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#24
Ethon::Curl::MultiOption = T.let(T.unsafe(nil), FFI::Enum)

# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#66
Ethon::Curl::PollAction = T.let(T.unsafe(nil), FFI::Enum)

# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#63
Ethon::Curl::SOCKET_BAD = T.let(T.unsafe(nil), Integer)

# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#64
Ethon::Curl::SOCKET_TIMEOUT = T.let(T.unsafe(nil), Integer)

# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#74
Ethon::Curl::SocketReadiness = T.let(T.unsafe(nil), FFI::Bitmask)

# @api private
#
# source://ethon//lib/ethon/curls/classes.rb#55
class Ethon::Curl::Timeval < ::FFI::Struct; end

# asynchronous dns resolves
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#51
Ethon::Curl::VERSION_ASYNCHDNS = T.let(T.unsafe(nil), Integer)

# character conversions supported
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#56
Ethon::Curl::VERSION_CONV = T.let(T.unsafe(nil), Integer)

# debug memory tracking supported
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#57
Ethon::Curl::VERSION_CURLDEBUG = T.let(T.unsafe(nil), Integer)

# built with debug capabilities
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#50
Ethon::Curl::VERSION_DEBUG = T.let(T.unsafe(nil), Integer)

# GSS-API is supported
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#61
Ethon::Curl::VERSION_GSSAPI = T.let(T.unsafe(nil), Integer)

# Negotiate auth supp
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#49
Ethon::Curl::VERSION_GSSNEGOTIATE = T.let(T.unsafe(nil), Integer)

# HTTP2 support built
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#60
Ethon::Curl::VERSION_HTTP2 = T.let(T.unsafe(nil), Integer)

# International Domain Names support
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#54
Ethon::Curl::VERSION_IDN = T.let(T.unsafe(nil), Integer)

# IPv6-enabled
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#44
Ethon::Curl::VERSION_IPV6 = T.let(T.unsafe(nil), Integer)

# kerberos auth is supported
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#45
Ethon::Curl::VERSION_KERBEROS4 = T.let(T.unsafe(nil), Integer)

# supports files bigger than 2GB
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#53
Ethon::Curl::VERSION_LARGEFILE = T.let(T.unsafe(nil), Integer)

# libz features are present
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#47
Ethon::Curl::VERSION_LIBZ = T.let(T.unsafe(nil), Integer)

# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#5
Ethon::Curl::VERSION_NOW = T.let(T.unsafe(nil), Integer)

# NTLM auth is supported
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#48
Ethon::Curl::VERSION_NTLM = T.let(T.unsafe(nil), Integer)

# NTLM delegating to winbind helper
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#59
Ethon::Curl::VERSION_NTLM_WB = T.let(T.unsafe(nil), Integer)

# SPNEGO auth is supported
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#52
Ethon::Curl::VERSION_SPNEGO = T.let(T.unsafe(nil), Integer)

# SSL options are present
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#46
Ethon::Curl::VERSION_SSL = T.let(T.unsafe(nil), Integer)

# SSPI is supported
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#55
Ethon::Curl::VERSION_SSPI = T.let(T.unsafe(nil), Integer)

# TLS-SRP auth is supported
#
# @api private
#
# source://ethon//lib/ethon/curls/constants.rb#58
Ethon::Curl::VERSION_TLSAUTH_SRP = T.let(T.unsafe(nil), Integer)

# @api private
#
# source://ethon//lib/ethon/curls/classes.rb#14
class Ethon::Curl::VersionInfoData < ::FFI::Struct; end

# source://ethon//lib/ethon/curls/codes.rb#3
module Ethon::Curls; end

# This module contains all easy and
# multi return codes.
#
# source://ethon//lib/ethon/curls/codes.rb#7
module Ethon::Curls::Codes
  # Libcurl error codes, refer
  # https://github.com/bagder/curl/blob/master/include/curl/curl.h for details
  #
  # source://ethon//lib/ethon/curls/codes.rb#11
  def easy_codes; end

  # Curl-Multi socket error codes, refer
  # https://github.com/bagder/curl/blob/master/include/curl/multi.h for details
  #
  # source://ethon//lib/ethon/curls/codes.rb#107
  def multi_codes; end
end

# This module contains the available options for forms.
#
# source://ethon//lib/ethon/curls/form_options.rb#6
module Ethon::Curls::FormOptions
  # Form options, used by FormAdd for temporary storage, refer
  # https://github.com/bagder/curl/blob/master/lib/formdata.h#L51 for details
  #
  # source://ethon//lib/ethon/curls/form_options.rb#10
  def form_options; end
end

# This module contains the functions to be attached in order to work with
# libcurl.
#
# source://ethon//lib/ethon/curls/functions.rb#7
module Ethon::Curls::Functions
  class << self
    # source://ethon//lib/ethon/curls/functions.rb#10
    def extended(base); end
  end
end

# This module contains logic for the available informations
# on an easy, eg.: connect_time.
#
# source://ethon//lib/ethon/curls/infos.rb#7
module Ethon::Curls::Infos
  # http://curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTDEBUGFUNCTION
  # https://github.com/bagder/curl/blob/master/include/curl/curl.h#L378
  #
  # @example Return debug info types.
  #   Ethon::Curl.debug_info_types
  # @return [Hash] The info types available to curl_debug_callback.
  #
  # source://ethon//lib/ethon/curls/infos.rb#31
  def debug_info_types; end

  # Return info as float
  #
  # @example Return info.
  #   Curl.get_info_double(:response_code, easy)
  # @param option [Symbol] The option name.
  # @param handle [::FFI::Pointer] The easy handle.
  # @return [Float] The info.
  #
  # source://ethon//lib/ethon/curls/infos.rb#142
  def get_info_double(option, handle); end

  # Return info as integer.
  #
  # @example Return info.
  #   Curl.get_info_long(:response_code, easy)
  # @param option [Symbol] The option name.
  # @param handle [::FFI::Pointer] The easy handle.
  # @return [Integer] The info.
  #
  # source://ethon//lib/ethon/curls/infos.rb#125
  def get_info_long(option, handle); end

  # Return info as string.
  #
  # @example Return info.
  #   Curl.get_info_string(:primary_ip, easy)
  # @param option [Symbol] The option name.
  # @param handle [::FFI::Pointer] The easy handle.
  # @return [String] The info.
  #
  # source://ethon//lib/ethon/curls/infos.rb#107
  def get_info_string(option, handle); end

  # Return info types.
  #
  # @example Return info types.
  #   Ethon::Curl.info_types
  # @return [Hash] The info types.
  #
  # source://ethon//lib/ethon/curls/infos.rb#15
  def info_types; end

  # Return Info details, refer
  # https://github.com/bagder/curl/blob/master/src/tool_writeout.c#L66 for details
  #
  # @example Return infos.
  #   Ethon::Curl.infos
  # @return [Hash] The infos.
  #
  # source://ethon//lib/ethon/curls/infos.rb#50
  def infos; end
end

# This module contains available message codes.
#
# source://ethon//lib/ethon/curls/messages.rb#6
module Ethon::Curls::Messages
  # Return message codes.
  #
  # @example Return message codes.
  #   Ethon::Curl.msg_codes
  # @return [Array] The messages codes.
  #
  # source://ethon//lib/ethon/curls/messages.rb#14
  def msg_codes; end
end

# This module contains logic for setting options on
# easy or multi interface.
#
# source://ethon//lib/ethon/curls/options.rb#7
module Ethon::Curls::Options
  # source://ethon//lib/ethon/curls/options.rb#208
  def easy_options(rt); end

  # source://ethon//lib/ethon/curls/options.rb#208
  def multi_options(rt); end

  # Sets appropriate option for easy, depending on value type.
  #
  # @raise [NameError]
  #
  # source://ethon//lib/ethon/curls/options.rb#13
  def set_option(option, value, handle, type = T.unsafe(nil)); end

  class << self
    # source://ethon//lib/ethon/curls/options.rb#153
    def option(ftype, name, type, num, opts = T.unsafe(nil)); end

    # source://ethon//lib/ethon/curls/options.rb#200
    def option_alias(ftype, name, *aliases); end

    # source://ethon//lib/ethon/curls/options.rb#205
    def option_type(type); end
  end
end

# source://ethon//lib/ethon/curls/options.rb#207
Ethon::Curls::Options::EASY_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://ethon//lib/ethon/curls/options.rb#10
Ethon::Curls::Options::FOPTION_STRINGS = T.let(T.unsafe(nil), Hash)

# source://ethon//lib/ethon/curls/options.rb#11
Ethon::Curls::Options::FUNCS = T.let(T.unsafe(nil), Hash)

# source://ethon//lib/ethon/curls/options.rb#207
Ethon::Curls::Options::MULTI_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://ethon//lib/ethon/curls/options.rb#9
Ethon::Curls::Options::OPTION_STRINGS = T.let(T.unsafe(nil), Hash)

# source://ethon//lib/ethon/curls/options.rb#111
Ethon::Curls::Options::OPTION_TYPE_BASE = T.let(T.unsafe(nil), Hash)

# source://ethon//lib/ethon/curls/options.rb#117
Ethon::Curls::Options::OPTION_TYPE_MAP = T.let(T.unsafe(nil), Hash)

# This is the class representing the libcurl easy interface
# See http://curl.haxx.se/libcurl/c/libcurl-easy.html for more informations.
#
# @example You can access the libcurl easy interface through this class, every request is based on it. The simplest setup looks like that:
#
#   e = Ethon::Easy.new(url: "www.example.com")
#   e.perform
#   #=> :ok
# @example You can the reuse this Easy for the next request:
#
#   e.reset # reset easy handle
#   e.url = "www.google.com"
#   e.followlocation = true
#   e.perform
#   #=> :ok
# @see initialize
#
# source://ethon//lib/ethon/easy/informations.rb#3
class Ethon::Easy
  include ::Ethon::Easy::Informations
  include ::Ethon::Easy::Callbacks
  include ::Ethon::Easy::Options
  include ::Ethon::Easy::Header
  include ::Ethon::Easy::Http
  include ::Ethon::Easy::Operations
  include ::Ethon::Easy::ResponseCallbacks
  extend ::Ethon::Easy::Features

  # Initialize a new Easy.
  # It initializes curl, if not already done and applies the provided options.
  # Look into {Ethon::Easy::Options Options} to see what you can provide in the
  # options hash.
  #
  # @example Create a new Easy.
  #   Easy.new(url: "www.google.de")
  # @option options
  # @param options [Hash] The options to set.
  # @return [Easy] A new Easy.
  # @see Ethon::Easy::Options
  # @see http://curl.haxx.se/libcurl/c/curl_easy_setopt.html
  #
  # source://ethon//lib/ethon/easy.rb#218
  def initialize(options = T.unsafe(nil)); end

  # source://ethon//lib/ethon/easy/callbacks.rb#13
  def debug_info; end

  # source://ethon//lib/ethon/easy/callbacks.rb#13
  def debug_info=(_arg0); end

  # Clones libcurl session handle. This means that all options that is set in
  #   the current handle will be set on duplicated handle.
  #
  # source://ethon//lib/ethon/easy.rb#265
  def dup; end

  # Url escapes the value.
  #
  # @api private
  # @example Url escape.
  #   easy.escape(value)
  # @param value [String] The value to escape.
  # @return [String] The escaped value.
  #
  # source://ethon//lib/ethon/easy.rb#285
  def escape(value); end

  # Return pretty log out.
  #
  # @example Return log out.
  #   easy.log_inspect
  # @return [String] The log out.
  #
  # source://ethon//lib/ethon/easy.rb#311
  def log_inspect; end

  # source://ethon//lib/ethon/easy.rb#301
  def mirror; end

  # Reset easy. This means resetting all options and instance variables.
  # Also the easy handle is resetted.
  #
  # @example Reset.
  #   easy.reset
  #
  # source://ethon//lib/ethon/easy.rb#249
  def reset; end

  # source://ethon//lib/ethon/easy/callbacks.rb#13
  def response_body; end

  # source://ethon//lib/ethon/easy/callbacks.rb#13
  def response_body=(_arg0); end

  # source://ethon//lib/ethon/easy/callbacks.rb#13
  def response_headers; end

  # source://ethon//lib/ethon/easy/callbacks.rb#13
  def response_headers=(_arg0); end

  # Returns the curl return code.
  #
  # @return [Symbol] The return code.
  #   * :ok: All fine. Proceed as usual.
  #   * :unsupported_protocol: The URL you passed to libcurl used a
  #   protocol that this libcurl does not support. The support
  #   might be a compile-time option that you didn't use, it can
  #   be a misspelled protocol string or just a protocol
  #   libcurl has no code for.
  #   * :failed_init: Very early initialization code failed. This
  #   is likely to be an internal error or problem, or a
  #   resource problem where something fundamental couldn't
  #   get done at init time.
  #   * :url_malformat: The URL was not properly formatted.
  #   * :not_built_in: A requested feature, protocol or option
  #   was not found built-in in this libcurl due to a build-time
  #   decision. This means that a feature or option was not enabled
  #   or explicitly disabled when libcurl was built and in
  #   order to get it to function you have to get a rebuilt libcurl.
  #   * :couldnt_resolve_proxy: Couldn't resolve proxy. The given
  #   proxy host could not be resolved.
  #   * :couldnt_resolve_host: Couldn't resolve host. The given remote
  #   host was not resolved.
  #   * :couldnt_connect: Failed to connect() to host or proxy.
  #   * :ftp_weird_server_reply: After connecting to a FTP server,
  #   libcurl expects to get a certain reply back. This error
  #   code implies that it got a strange or bad reply. The given
  #   remote server is probably not an OK FTP server.
  #   * :remote_access_denied: We were denied access to the resource
  #   given in the URL. For FTP, this occurs while trying to
  #   change to the remote directory.
  #   * :ftp_accept_failed: While waiting for the server to connect
  #   back when an active FTP session is used, an error code was
  #   sent over the control connection or similar.
  #   * :ftp_weird_pass_reply: After having sent the FTP password to
  #   the server, libcurl expects a proper reply. This error code
  #   indicates that an unexpected code was returned.
  #   * :ftp_accept_timeout: During an active FTP session while
  #   waiting for the server to connect, the CURLOPT_ACCEPTTIMOUT_MS
  #   (or the internal default) timeout expired.
  #   * :ftp_weird_pasv_reply: libcurl failed to get a sensible result
  #   back from the server as a response to either a PASV or a
  #   EPSV command. The server is flawed.
  #   * :ftp_weird_227_format: FTP servers return a 227-line as a response
  #   to a PASV command. If libcurl fails to parse that line,
  #   this return code is passed back.
  #   * :ftp_cant_get_host: An internal failure to lookup the host used
  #   for the new connection.
  #   * :ftp_couldnt_set_type: Received an error when trying to set
  #   the transfer mode to binary or ASCII.
  #   * :partial_file: A file transfer was shorter or larger than
  #   expected. This happens when the server first reports an expected
  #   transfer size, and then delivers data that doesn't match the
  #   previously given size.
  #   * :ftp_couldnt_retr_file: This was either a weird reply to a
  #   'RETR' command or a zero byte transfer complete.
  #   * :quote_error: When sending custom "QUOTE" commands to the
  #   remote server, one of the commands returned an error code that
  #   was 400 or higher (for FTP) or otherwise indicated unsuccessful
  #   completion of the command.
  #   * :http_returned_error: This is returned if CURLOPT_FAILONERROR is
  #   set TRUE and the HTTP server returns an error code that is >= 400.
  #   * :write_error: An error occurred when writing received data to a
  #   local file, or an error was returned to libcurl from a write callback.
  #   * :upload_failed: Failed starting the upload. For FTP, the server
  #   typically denied the STOR command. The error buffer usually
  #   contains the server's explanation for this.
  #   * :read_error: There was a problem reading a local file or an error
  #   returned by the read callback.
  #   * :out_of_memory: A memory allocation request failed. This is serious
  #   badness and things are severely screwed up if this ever occurs.
  #   * :operation_timedout: Operation timeout. The specified time-out
  #   period was reached according to the conditions.
  #   * :ftp_port_failed: The FTP PORT command returned error. This mostly
  #   happens when you haven't specified a good enough address for
  #   libcurl to use. See CURLOPT_FTPPORT.
  #   * :ftp_couldnt_use_rest: The FTP REST command returned error. This
  #   should never happen if the server is sane.
  #   * :range_error: The server does not support or accept range requests.
  #   * :http_post_error: This is an odd error that mainly occurs due to
  #   internal confusion.
  #   * :ssl_connect_error: A problem occurred somewhere in the SSL/TLS
  #   handshake. You really want the error buffer and read the message
  #   there as it pinpoints the problem slightly more. Could be
  #   certificates (file formats, paths, permissions), passwords, and others.
  #   * :bad_download_resume: The download could not be resumed because
  #   the specified offset was out of the file boundary.
  #   * :file_couldnt_read_file: A file given with FILE:// couldn't be
  #   opened. Most likely because the file path doesn't identify an
  #   existing file. Did you check file permissions?
  #   * :ldap_cannot_bind: LDAP cannot bind. LDAP bind operation failed.
  #   * :ldap_search_failed: LDAP search failed.
  #   * :function_not_found: Function not found. A required zlib function was not found.
  #   * :aborted_by_callback: Aborted by callback. A callback returned
  #   "abort" to libcurl.
  #   * :bad_function_argument: Internal error. A function was called with
  #   a bad parameter.
  #   * :interface_failed: Interface error. A specified outgoing interface
  #   could not be used. Set which interface to use for outgoing
  #   connections' source IP address with CURLOPT_INTERFACE.
  #   * :too_many_redirects: Too many redirects. When following redirects,
  #   libcurl hit the maximum amount. Set your limit with CURLOPT_MAXREDIRS.
  #   * :unknown_option: An option passed to libcurl is not recognized/known.
  #   Refer to the appropriate documentation. This is most likely a
  #   problem in the program that uses libcurl. The error buffer might
  #   contain more specific information about which exact option it concerns.
  #   * :telnet_option_syntax: A telnet option string was Illegally formatted.
  #   * :peer_failed_verification: The remote server's SSL certificate or
  #   SSH md5 fingerprint was deemed not OK.
  #   * :got_nothing: Nothing was returned from the server, and under the
  #   circumstances, getting nothing is considered an error.
  #   * :ssl_engine_notfound: The specified crypto engine wasn't found.
  #   * :ssl_engine_setfailed: Failed setting the selected SSL crypto engine as default!
  #   * :send_error: Failed sending network data.
  #   * :recv_error: Failure with receiving network data.
  #   * :ssl_certproblem: problem with the local client certificate.
  #   * :ssl_cipher: Couldn't use specified cipher.
  #   * :bad_content_encoding: Unrecognized transfer encoding.
  #   * :ldap_invalid_url: Invalid LDAP URL.
  #   * :filesize_exceeded: Maximum file size exceeded.
  #   * :use_ssl_failed: Requested FTP SSL level failed.
  #   * :send_fail_rewind: When doing a send operation curl had to rewind the data to
  #   retransmit, but the rewinding operation failed.
  #   * :ssl_engine_initfailed: Initiating the SSL Engine failed.
  #   * :login_denied: The remote server denied curl to login
  #   * :tftp_notfound: File not found on TFTP server.
  #   * :tftp_perm: Permission problem on TFTP server.
  #   * :remote_disk_full: Out of disk space on the server.
  #   * :tftp_illegal: Illegal TFTP operation.
  #   * :tftp_unknownid: Unknown TFTP transfer ID.
  #   * :remote_file_exists: File already exists and will not be overwritten.
  #   * :tftp_nosuchuser: This error should never be returned by a properly
  #   functioning TFTP server.
  #   * :conv_failed: Character conversion failed.
  #   * :conv_reqd: Caller must register conversion callbacks.
  #   * :ssl_cacert_badfile: Problem with reading the SSL CA cert (path? access rights?):
  #   * :remote_file_not_found: The resource referenced in the URL does not exist.
  #   * :ssh: An unspecified error occurred during the SSH session.
  #   * :ssl_shutdown_failed: Failed to shut down the SSL connection.
  #   * :again: Socket is not ready for send/recv wait till it's ready and try again.
  #   This return code is only returned from curl_easy_recv(3) and curl_easy_send(3)
  #   * :ssl_crl_badfile: Failed to load CRL file
  #   * :ssl_issuer_error: Issuer check failed
  #   * :ftp_pret_failed: The FTP server does not understand the PRET command at
  #   all or does not support the given argument. Be careful when
  #   using CURLOPT_CUSTOMREQUEST, a custom LIST command will be sent with PRET CMD
  #   before PASV as well.
  #   * :rtsp_cseq_error: Mismatch of RTSP CSeq numbers.
  #   * :rtsp_session_error: Mismatch of RTSP Session Identifiers.
  #   * :ftp_bad_file_list: Unable to parse FTP file list (during FTP wildcard downloading).
  #   * :chunk_failed: Chunk callback reported error.
  #   * :obsolete: These error codes will never be returned. They were used in an old
  #   libcurl version and are currently unused.
  # @see http://curl.haxx.se/libcurl/c/libcurl-errors.html
  #
  # source://ethon//lib/ethon/easy.rb#201
  def return_code; end

  # Returns the curl return code.
  #
  # @return [Symbol] The return code.
  #   * :ok: All fine. Proceed as usual.
  #   * :unsupported_protocol: The URL you passed to libcurl used a
  #   protocol that this libcurl does not support. The support
  #   might be a compile-time option that you didn't use, it can
  #   be a misspelled protocol string or just a protocol
  #   libcurl has no code for.
  #   * :failed_init: Very early initialization code failed. This
  #   is likely to be an internal error or problem, or a
  #   resource problem where something fundamental couldn't
  #   get done at init time.
  #   * :url_malformat: The URL was not properly formatted.
  #   * :not_built_in: A requested feature, protocol or option
  #   was not found built-in in this libcurl due to a build-time
  #   decision. This means that a feature or option was not enabled
  #   or explicitly disabled when libcurl was built and in
  #   order to get it to function you have to get a rebuilt libcurl.
  #   * :couldnt_resolve_proxy: Couldn't resolve proxy. The given
  #   proxy host could not be resolved.
  #   * :couldnt_resolve_host: Couldn't resolve host. The given remote
  #   host was not resolved.
  #   * :couldnt_connect: Failed to connect() to host or proxy.
  #   * :ftp_weird_server_reply: After connecting to a FTP server,
  #   libcurl expects to get a certain reply back. This error
  #   code implies that it got a strange or bad reply. The given
  #   remote server is probably not an OK FTP server.
  #   * :remote_access_denied: We were denied access to the resource
  #   given in the URL. For FTP, this occurs while trying to
  #   change to the remote directory.
  #   * :ftp_accept_failed: While waiting for the server to connect
  #   back when an active FTP session is used, an error code was
  #   sent over the control connection or similar.
  #   * :ftp_weird_pass_reply: After having sent the FTP password to
  #   the server, libcurl expects a proper reply. This error code
  #   indicates that an unexpected code was returned.
  #   * :ftp_accept_timeout: During an active FTP session while
  #   waiting for the server to connect, the CURLOPT_ACCEPTTIMOUT_MS
  #   (or the internal default) timeout expired.
  #   * :ftp_weird_pasv_reply: libcurl failed to get a sensible result
  #   back from the server as a response to either a PASV or a
  #   EPSV command. The server is flawed.
  #   * :ftp_weird_227_format: FTP servers return a 227-line as a response
  #   to a PASV command. If libcurl fails to parse that line,
  #   this return code is passed back.
  #   * :ftp_cant_get_host: An internal failure to lookup the host used
  #   for the new connection.
  #   * :ftp_couldnt_set_type: Received an error when trying to set
  #   the transfer mode to binary or ASCII.
  #   * :partial_file: A file transfer was shorter or larger than
  #   expected. This happens when the server first reports an expected
  #   transfer size, and then delivers data that doesn't match the
  #   previously given size.
  #   * :ftp_couldnt_retr_file: This was either a weird reply to a
  #   'RETR' command or a zero byte transfer complete.
  #   * :quote_error: When sending custom "QUOTE" commands to the
  #   remote server, one of the commands returned an error code that
  #   was 400 or higher (for FTP) or otherwise indicated unsuccessful
  #   completion of the command.
  #   * :http_returned_error: This is returned if CURLOPT_FAILONERROR is
  #   set TRUE and the HTTP server returns an error code that is >= 400.
  #   * :write_error: An error occurred when writing received data to a
  #   local file, or an error was returned to libcurl from a write callback.
  #   * :upload_failed: Failed starting the upload. For FTP, the server
  #   typically denied the STOR command. The error buffer usually
  #   contains the server's explanation for this.
  #   * :read_error: There was a problem reading a local file or an error
  #   returned by the read callback.
  #   * :out_of_memory: A memory allocation request failed. This is serious
  #   badness and things are severely screwed up if this ever occurs.
  #   * :operation_timedout: Operation timeout. The specified time-out
  #   period was reached according to the conditions.
  #   * :ftp_port_failed: The FTP PORT command returned error. This mostly
  #   happens when you haven't specified a good enough address for
  #   libcurl to use. See CURLOPT_FTPPORT.
  #   * :ftp_couldnt_use_rest: The FTP REST command returned error. This
  #   should never happen if the server is sane.
  #   * :range_error: The server does not support or accept range requests.
  #   * :http_post_error: This is an odd error that mainly occurs due to
  #   internal confusion.
  #   * :ssl_connect_error: A problem occurred somewhere in the SSL/TLS
  #   handshake. You really want the error buffer and read the message
  #   there as it pinpoints the problem slightly more. Could be
  #   certificates (file formats, paths, permissions), passwords, and others.
  #   * :bad_download_resume: The download could not be resumed because
  #   the specified offset was out of the file boundary.
  #   * :file_couldnt_read_file: A file given with FILE:// couldn't be
  #   opened. Most likely because the file path doesn't identify an
  #   existing file. Did you check file permissions?
  #   * :ldap_cannot_bind: LDAP cannot bind. LDAP bind operation failed.
  #   * :ldap_search_failed: LDAP search failed.
  #   * :function_not_found: Function not found. A required zlib function was not found.
  #   * :aborted_by_callback: Aborted by callback. A callback returned
  #   "abort" to libcurl.
  #   * :bad_function_argument: Internal error. A function was called with
  #   a bad parameter.
  #   * :interface_failed: Interface error. A specified outgoing interface
  #   could not be used. Set which interface to use for outgoing
  #   connections' source IP address with CURLOPT_INTERFACE.
  #   * :too_many_redirects: Too many redirects. When following redirects,
  #   libcurl hit the maximum amount. Set your limit with CURLOPT_MAXREDIRS.
  #   * :unknown_option: An option passed to libcurl is not recognized/known.
  #   Refer to the appropriate documentation. This is most likely a
  #   problem in the program that uses libcurl. The error buffer might
  #   contain more specific information about which exact option it concerns.
  #   * :telnet_option_syntax: A telnet option string was Illegally formatted.
  #   * :peer_failed_verification: The remote server's SSL certificate or
  #   SSH md5 fingerprint was deemed not OK.
  #   * :got_nothing: Nothing was returned from the server, and under the
  #   circumstances, getting nothing is considered an error.
  #   * :ssl_engine_notfound: The specified crypto engine wasn't found.
  #   * :ssl_engine_setfailed: Failed setting the selected SSL crypto engine as default!
  #   * :send_error: Failed sending network data.
  #   * :recv_error: Failure with receiving network data.
  #   * :ssl_certproblem: problem with the local client certificate.
  #   * :ssl_cipher: Couldn't use specified cipher.
  #   * :bad_content_encoding: Unrecognized transfer encoding.
  #   * :ldap_invalid_url: Invalid LDAP URL.
  #   * :filesize_exceeded: Maximum file size exceeded.
  #   * :use_ssl_failed: Requested FTP SSL level failed.
  #   * :send_fail_rewind: When doing a send operation curl had to rewind the data to
  #   retransmit, but the rewinding operation failed.
  #   * :ssl_engine_initfailed: Initiating the SSL Engine failed.
  #   * :login_denied: The remote server denied curl to login
  #   * :tftp_notfound: File not found on TFTP server.
  #   * :tftp_perm: Permission problem on TFTP server.
  #   * :remote_disk_full: Out of disk space on the server.
  #   * :tftp_illegal: Illegal TFTP operation.
  #   * :tftp_unknownid: Unknown TFTP transfer ID.
  #   * :remote_file_exists: File already exists and will not be overwritten.
  #   * :tftp_nosuchuser: This error should never be returned by a properly
  #   functioning TFTP server.
  #   * :conv_failed: Character conversion failed.
  #   * :conv_reqd: Caller must register conversion callbacks.
  #   * :ssl_cacert_badfile: Problem with reading the SSL CA cert (path? access rights?):
  #   * :remote_file_not_found: The resource referenced in the URL does not exist.
  #   * :ssh: An unspecified error occurred during the SSH session.
  #   * :ssl_shutdown_failed: Failed to shut down the SSL connection.
  #   * :again: Socket is not ready for send/recv wait till it's ready and try again.
  #   This return code is only returned from curl_easy_recv(3) and curl_easy_send(3)
  #   * :ssl_crl_badfile: Failed to load CRL file
  #   * :ssl_issuer_error: Issuer check failed
  #   * :ftp_pret_failed: The FTP server does not understand the PRET command at
  #   all or does not support the given argument. Be careful when
  #   using CURLOPT_CUSTOMREQUEST, a custom LIST command will be sent with PRET CMD
  #   before PASV as well.
  #   * :rtsp_cseq_error: Mismatch of RTSP CSeq numbers.
  #   * :rtsp_session_error: Mismatch of RTSP Session Identifiers.
  #   * :ftp_bad_file_list: Unable to parse FTP file list (during FTP wildcard downloading).
  #   * :chunk_failed: Chunk callback reported error.
  #   * :obsolete: These error codes will never be returned. They were used in an old
  #   libcurl version and are currently unused.
  # @see http://curl.haxx.se/libcurl/c/libcurl-errors.html
  #
  # source://ethon//lib/ethon/easy.rb#201
  def return_code=(_arg0); end

  # Set given options.
  #
  # @example Set options.
  #   easy.set_attributes(options)
  # @param options [Hash] The options.
  # @raise InvalidOption
  # @see initialize
  #
  # source://ethon//lib/ethon/easy.rb#234
  def set_attributes(options); end

  # Returns the informations available through libcurl as
  # a hash.
  #
  # @return [Hash] The informations hash.
  #
  # source://ethon//lib/ethon/easy.rb#296
  def to_hash; end
end

# This module contains all the logic around the callbacks,
# which are needed to interact with libcurl.
#
# @api private
#
# source://ethon//lib/ethon/easy/callbacks.rb#9
module Ethon::Easy::Callbacks
  # Returns the body write callback.
  #
  # @api private
  # @example Return the callback.
  #   easy.body_write_callback
  # @return [Proc] The callback.
  #
  # source://ethon//lib/ethon/easy/callbacks.rb#38
  def body_write_callback; end

  # Returns the debug callback. This callback is currently used
  # write the raw http request headers.
  #
  # @api private
  # @example Return the callback.
  #   easy.debug_callback
  # @return [Proc] The callback.
  #
  # source://ethon//lib/ethon/easy/callbacks.rb#68
  def debug_callback; end

  # Returns the header write callback.
  #
  # @api private
  # @example Return the callback.
  #   easy.header_write_callback
  # @return [Proc] The callback.
  #
  # source://ethon//lib/ethon/easy/callbacks.rb#53
  def header_write_callback; end

  # Returns the progress callback.
  #
  # @api private
  # @example Return the callback.
  #   easy.progress_callback
  # @return [Proc] The callback.
  #
  # source://ethon//lib/ethon/easy/callbacks.rb#91
  def progress_callback; end

  # Returns the body read callback.
  #
  # @api private
  # @example Return the callback.
  #   easy.read_callback
  # @return [Proc] The callback.
  #
  # source://ethon//lib/ethon/easy/callbacks.rb#144
  def read_callback; end

  # Set writefunction and headerfunction callback.
  # They are called by libcurl in order to provide the header and
  # the body from the request.
  #
  # @api private
  # @example Set callbacks.
  #   easy.set_callbacks
  #
  # source://ethon//lib/ethon/easy/callbacks.rb#22
  def set_callbacks; end

  # @api private
  #
  # source://ethon//lib/ethon/easy/callbacks.rb#77
  def set_progress_callback; end

  # Set the read callback. This callback is used by libcurl to
  # read data when performing a PUT request.
  #
  # @api private
  # @example Set the callback.
  #   easy.set_read_callback("a=1")
  # @param body [String] The body.
  #
  # source://ethon//lib/ethon/easy/callbacks.rb#105
  def set_read_callback(body); end

  class << self
    # @api private
    #
    # source://ethon//lib/ethon/easy/callbacks.rb#12
    def included(base); end
  end
end

# This class is used to store and retreive debug information,
# which is only saved when verbose is set to true.
#
# @api private
#
# source://ethon//lib/ethon/easy/debug_info.rb#9
class Ethon::Easy::DebugInfo
  # @api private
  # @return [DebugInfo] a new instance of DebugInfo
  #
  # source://ethon//lib/ethon/easy/debug_info.rb#22
  def initialize; end

  # @api private
  #
  # source://ethon//lib/ethon/easy/debug_info.rb#26
  def add(type, message); end

  def data_in; end
  def data_out; end
  def header_in; end
  def header_out; end

  # @api private
  #
  # source://ethon//lib/ethon/easy/debug_info.rb#30
  def messages_for(type); end

  def ssl_data_in; end
  def ssl_data_out; end
  def text; end

  # @api private
  #
  # source://ethon//lib/ethon/easy/debug_info.rb#38
  def to_a; end

  # @api private
  #
  # source://ethon//lib/ethon/easy/debug_info.rb#42
  def to_h; end
end

# @api private
#
# source://ethon//lib/ethon/easy/debug_info.rb#11
Ethon::Easy::DebugInfo::MESSAGE_TYPES = T.let(T.unsafe(nil), Array)

# @api private
#
# source://ethon//lib/ethon/easy/debug_info.rb#13
class Ethon::Easy::DebugInfo::Message
  # @api private
  # @return [Message] a new instance of Message
  #
  # source://ethon//lib/ethon/easy/debug_info.rb#16
  def initialize(type, message); end

  # @api private
  #
  # source://ethon//lib/ethon/easy/debug_info.rb#14
  def message; end

  # @api private
  #
  # source://ethon//lib/ethon/easy/debug_info.rb#14
  def type; end
end

# This module contains class methods for feature checks
#
# source://ethon//lib/ethon/easy/features.rb#6
module Ethon::Easy::Features
  # Returns true if this curl version supports AsynchDNS.
  #
  # @example
  #   Ethon::Easy.supports_asynch_dns?
  # @return [Boolean] True if supported, else false.
  #
  # source://ethon//lib/ethon/easy/features.rb#23
  def supports_asynch_dns?; end

  # Returns true if this curl version supports AsynchDNS.
  #
  # @example
  #   Ethon::Easy.supports_asynch_dns?
  # @return [Boolean] True if supported, else false.
  #
  # source://ethon//lib/ethon/easy/features.rb#23
  def supports_timeout_ms?; end

  # Returns true if this curl version supports zlib.
  #
  # @example Return wether zlib is supported.
  #   Ethon::Easy.supports_zlib?
  # @return [Boolean] True if supported, else false.
  #
  # source://ethon//lib/ethon/easy/features.rb#13
  def supports_zlib?; end
end

# This class represents a form and is used to send a payload in the
# request body via POST/PUT.
# It handles multipart forms, too.
#
# @api private
#
# source://ethon//lib/ethon/easy/form.rb#13
class Ethon::Easy::Form
  include ::Ethon::Easy::Util
  include ::Ethon::Easy::Queryable

  # Return a new Form.
  #
  # @api private
  # @example Return a new Form.
  #   Form.new({})
  # @param params [Hash] The parameter with which to initialize the form.
  # @return [Form] A new Form.
  #
  # source://ethon//lib/ethon/easy/form.rb#25
  def initialize(easy, params, multipart = T.unsafe(nil)); end

  # source://ethon//lib/ethon/easy/queryable.rb#11
  def escape; end

  # source://ethon//lib/ethon/easy/queryable.rb#11
  def escape=(_arg0); end

  # Return a pointer to the first form element in libcurl.
  #
  # @api private
  # @example Return the first form element.
  #   form.first
  # @return [FFI::Pointer] The first element.
  #
  # source://ethon//lib/ethon/easy/form.rb#37
  def first; end

  # Return a pointer to the last form element in libcurl.
  #
  # @api private
  # @example Return the last form element.
  #   form.last
  # @return [FFI::Pointer] The last element.
  #
  # source://ethon//lib/ethon/easy/form.rb#47
  def last; end

  # Add form elements to libcurl.
  #
  # @api private
  # @example Add form to libcurl.
  #   form.materialize
  #
  # source://ethon//lib/ethon/easy/form.rb#67
  def materialize; end

  # Return if form is multipart. The form is multipart
  # when it contains a file or multipart option is set on the form during creation.
  #
  # @api private
  # @example Return if form is multipart.
  #   form.multipart?
  # @return [Boolean] True if form is multipart, else false.
  #
  # source://ethon//lib/ethon/easy/form.rb#58
  def multipart?; end

  # source://ethon//lib/ethon/easy/queryable.rb#12
  def params_encoding; end

  # source://ethon//lib/ethon/easy/queryable.rb#12
  def params_encoding=(_arg0); end

  private

  # @api private
  #
  # source://ethon//lib/ethon/easy/form.rb#73
  def form_add(name, content); end

  # @api private
  #
  # source://ethon//lib/ethon/easy/form.rb#97
  def setup_garbage_collection; end
end

# This module contains the logic around adding headers to libcurl.
#
# @api private
#
# source://ethon//lib/ethon/easy/header.rb#7
module Ethon::Easy::Header
  # Compose libcurl header string from key and value.
  # Also replaces null bytes, because libcurl will complain
  # otherwise.
  #
  # @api private
  # @example Compose header.
  #   easy.compose_header('User-Agent', 'Ethon')
  # @param key [String] The header name.
  # @param value [String] The header value.
  # @return [String] The composed header.
  #
  # source://ethon//lib/ethon/easy/header.rb#56
  def compose_header(key, value); end

  # Return header_list.
  #
  # @api private
  # @example Return header_list.
  #   easy.header_list
  # @return [FFI::Pointer] The header list.
  #
  # source://ethon//lib/ethon/easy/header.rb#41
  def header_list; end

  # Return headers, return empty hash if none.
  #
  # @api private
  # @example Return the headers.
  #   easy.headers
  # @return [Hash] The headers.
  #
  # source://ethon//lib/ethon/easy/header.rb#14
  def headers; end

  # Set the headers.
  #
  # @api private
  # @example Set the headers.
  #   easy.headers = {'User-Agent' => 'ethon'}
  # @param headers [Hash] The headers.
  #
  # source://ethon//lib/ethon/easy/header.rb#24
  def headers=(headers); end
end

# This module contains logic about making valid HTTP requests.
#
# source://ethon//lib/ethon/easy/http/putable.rb#4
module Ethon::Easy::Http
  # Set specified options in order to make a HTTP request.
  # Look at {Ethon::Easy::Options Options} to see what you can
  # provide in the options hash.
  #
  # @example Set options for HTTP request.
  #   easy.http_request("www.google.com", :get, {})
  # @option options
  # @option options
  # @option options
  # @param url [String] The url.
  # @param action_name [String] The HTTP action name.
  # @param options [Hash] The options hash.
  # @return [void]
  # @see Ethon::Easy::Options
  #
  # source://ethon//lib/ethon/easy/http.rb#39
  def http_request(url, action_name, options = T.unsafe(nil)); end

  private

  # Return the corresponding action class.
  #
  # @example Return the action.
  #   Action.fabricate(:get)
  #   Action.fabricate(:smash)
  # @param url [String] The url.
  # @param action_name [String] The HTTP action name.
  # @param options [Hash] The option hash.
  # @return [Easy::Ethon::Actionable] The request instance.
  #
  # source://ethon//lib/ethon/easy/http.rb#56
  def fabricate(url, action_name, options); end
end

# This module represents a Http Action and is a factory
# for more real actions like GET, HEAD, POST and PUT.
#
# source://ethon//lib/ethon/easy/http/actionable.rb#10
module Ethon::Easy::Http::Actionable
  # Create a new action.
  #
  # @example Create a new action.
  #   Action.new("www.example.com", {})
  # @param url [String] The url.
  # @param options [Hash] The options.
  # @return [Action] A new action.
  #
  # source://ethon//lib/ethon/easy/http/actionable.rb#23
  def initialize(url, options); end

  # Return the form.
  #
  # @example Return form.
  #   action.form
  # @return [Form] The form.
  #
  # source://ethon//lib/ethon/easy/http/actionable.rb#74
  def form; end

  # Return the options hash.
  #
  # @example Return options.
  #   action.options
  # @return [Hash] The options.
  #
  # source://ethon//lib/ethon/easy/http/actionable.rb#44
  def options; end

  # Return the params.
  #
  # @example Return params.
  #   action.params
  # @return [Params] The params.
  #
  # source://ethon//lib/ethon/easy/http/actionable.rb#64
  def params; end

  # Get the requested array encoding. By default it's
  # :typhoeus, but it can also be set to :rack.
  #
  # @example Get encoding from options
  #   action.params_encoding
  #
  # source://ethon//lib/ethon/easy/http/actionable.rb#84
  def params_encoding; end

  # Returns the query options hash.
  #
  # @example Return query options.
  #   action.query_options
  # @return [Hash] The query options.
  #
  # source://ethon//lib/ethon/easy/http/actionable.rb#54
  def query_options; end

  # Setup request with form.
  #
  # @example Setup nothing.
  #   action.set_form(easy)
  # @param easy [Easy] The easy to setup.
  #
  # source://ethon//lib/ethon/easy/http/actionable.rb#136
  def set_form(easy); end

  # Setup request with params.
  #
  # @example Setup nothing.
  #   action.set_params(easy)
  # @param easy [Easy] The easy to setup.
  #
  # source://ethon//lib/ethon/easy/http/actionable.rb#117
  def set_params(easy); end

  # Setup everything necessary for a proper request.
  #
  # @example setup.
  #   action.setup(easy)
  # @param easy [easy] the easy to setup.
  #
  # source://ethon//lib/ethon/easy/http/actionable.rb#94
  def setup(easy); end

  # Return the url.
  #
  # @example Return url.
  #   action.url
  # @return [String] The url.
  #
  # source://ethon//lib/ethon/easy/http/actionable.rb#34
  def url; end

  private

  # source://ethon//lib/ethon/easy/http/actionable.rb#141
  def parse_options(options); end
end

# source://ethon//lib/ethon/easy/http/actionable.rb#12
Ethon::Easy::Http::Actionable::QUERY_OPTIONS = T.let(T.unsafe(nil), Array)

# This class knows everything about making requests for custom HTTP verbs.
#
# source://ethon//lib/ethon/easy/http/custom.rb#7
class Ethon::Easy::Http::Custom
  include ::Ethon::Easy::Http::Actionable
  include ::Ethon::Easy::Http::Postable

  # @return [Custom] a new instance of Custom
  #
  # source://ethon//lib/ethon/easy/http/custom.rb#11
  def initialize(verb, url, options); end

  # Setup easy to make a request.
  #
  # @example Setup.
  #   custom.set_params(easy)
  # @param easy [Easy] The easy to setup.
  #
  # source://ethon//lib/ethon/easy/http/custom.rb#22
  def setup(easy); end
end

# This class knows everything about making DELETE requests.
#
# source://ethon//lib/ethon/easy/http/delete.rb#7
class Ethon::Easy::Http::Delete
  include ::Ethon::Easy::Http::Actionable
  include ::Ethon::Easy::Http::Postable

  # Setup easy to make a DELETE request.
  #
  # @example Setup customrequest.
  #   delete.setup(easy)
  # @param easy [Easy] The easy to setup.
  #
  # source://ethon//lib/ethon/easy/http/delete.rb#17
  def setup(easy); end
end

# This class knows everything about making GET requests.
#
# source://ethon//lib/ethon/easy/http/get.rb#7
class Ethon::Easy::Http::Get
  include ::Ethon::Easy::Http::Actionable
  include ::Ethon::Easy::Http::Postable

  # Setup easy to make a GET request.
  #
  # @example Setup.
  #   get.set_params(easy)
  # @param easy [Easy] The easy to setup.
  #
  # source://ethon//lib/ethon/easy/http/get.rb#17
  def setup(easy); end
end

# This class knows everything about making HEAD requests.
#
# source://ethon//lib/ethon/easy/http/head.rb#7
class Ethon::Easy::Http::Head
  include ::Ethon::Easy::Http::Actionable
  include ::Ethon::Easy::Http::Postable

  # Setup easy to make a HEAD request.
  #
  # @example Setup.
  #   get.set_params(easy)
  # @param easy [Easy] The easy to setup.
  #
  # source://ethon//lib/ethon/easy/http/head.rb#17
  def setup(easy); end
end

# This class knows everything about making OPTIONS requests.
#
# source://ethon//lib/ethon/easy/http/options.rb#7
class Ethon::Easy::Http::Options
  include ::Ethon::Easy::Http::Actionable
  include ::Ethon::Easy::Http::Postable

  # Setup easy to make a OPTIONS request.
  #
  # @example Setup.
  #   options.setup(easy)
  # @param easy [Easy] The easy to setup.
  #
  # source://ethon//lib/ethon/easy/http/options.rb#17
  def setup(easy); end
end

# This class knows everything about making PATCH requests.
#
# source://ethon//lib/ethon/easy/http/patch.rb#7
class Ethon::Easy::Http::Patch
  include ::Ethon::Easy::Http::Actionable
  include ::Ethon::Easy::Http::Postable

  # Setup easy to make a PATCH request.
  #
  # @example Setup.
  #   patch.setup(easy)
  # @param easy [Easy] The easy to setup.
  #
  # source://ethon//lib/ethon/easy/http/patch.rb#17
  def setup(easy); end
end

# This class knows everything about making POST requests.
#
# source://ethon//lib/ethon/easy/http/post.rb#6
class Ethon::Easy::Http::Post
  include ::Ethon::Easy::Http::Actionable
  include ::Ethon::Easy::Http::Postable

  # Setup easy to make a POST request.
  #
  # @example Setup.
  #   post.setup(easy)
  # @param easy [Easy] The easy to setup.
  #
  # source://ethon//lib/ethon/easy/http/post.rb#16
  def setup(easy); end
end

# This module contains logic for setting up a [multipart] POST body.
#
# source://ethon//lib/ethon/easy/http/postable.rb#7
module Ethon::Easy::Http::Postable
  # Set things up when form is provided.
  # Deals with multipart forms.
  #
  # @example Setup.
  #   post.set_form(easy)
  # @param easy [Easy] The easy to setup.
  #
  # source://ethon//lib/ethon/easy/http/postable.rb#16
  def set_form(easy); end
end

# This class knows everything about making PUT requests.
#
# source://ethon//lib/ethon/easy/http/put.rb#7
class Ethon::Easy::Http::Put
  include ::Ethon::Easy::Http::Actionable
  include ::Ethon::Easy::Http::Putable

  # Setup easy to make a PUT request.
  #
  # @example Setup.
  #   put.setup(easy)
  # @param easy [Easy] The easy to setup.
  #
  # source://ethon//lib/ethon/easy/http/put.rb#17
  def setup(easy); end
end

# This module contains logic about setting up a PUT body.
#
# source://ethon//lib/ethon/easy/http/putable.rb#7
module Ethon::Easy::Http::Putable
  # Set things up when form is provided.
  # Deals with multipart forms.
  #
  # @example Setup.
  #   put.set_form(easy)
  # @param easy [Easy] The easy to setup.
  #
  # source://ethon//lib/ethon/easy/http/putable.rb#15
  def set_form(easy); end
end

# This module contains the methods to return informations
# from the easy handle. See http://curl.haxx.se/libcurl/c/curl_easy_getinfo.html
# for more information.
#
# source://ethon//lib/ethon/easy/informations.rb#8
module Ethon::Easy::Informations
  def appconnect_time; end
  def connect_time; end
  def effective_url; end
  def httpauth_avail; end
  def namelookup_time; end
  def pretransfer_time; end
  def primary_ip; end
  def redirect_count; end
  def redirect_time; end
  def redirect_url; end
  def request_size; end
  def response_code; end
  def size_download; end
  def size_upload; end
  def speed_download; end
  def speed_upload; end
  def starttransfer_time; end

  # Returns true if this curl version supports zlib.
  #
  # @deprecated Please use the static version instead
  # @example Return wether zlib is supported.
  #   easy.supports_zlib?
  # @return [Boolean] True if supported, else false.
  #
  # source://ethon//lib/ethon/easy/informations.rb#109
  def supports_zlib?; end

  def total_time; end
end

# Holds available informations and their type, which is needed to
# request the informations from libcurl.
#
# source://ethon//lib/ethon/easy/informations.rb#12
Ethon::Easy::Informations::AVAILABLE_INFORMATIONS = T.let(T.unsafe(nil), Hash)

# source://ethon//lib/ethon/easy/mirror.rb#4
class Ethon::Easy::Mirror
  # @return [Mirror] a new instance of Mirror
  #
  # source://ethon//lib/ethon/easy/mirror.rb#21
  def initialize(options = T.unsafe(nil)); end

  def appconnect_time; end
  def connect_time; end
  def debug_info; end
  def effective_url; end
  def httpauth_avail; end

  # source://ethon//lib/ethon/easy/mirror.rb#25
  def log_informations; end

  def namelookup_time; end

  # Returns the value of attribute options.
  #
  # source://ethon//lib/ethon/easy/mirror.rb#5
  def options; end

  def pretransfer_time; end
  def primary_ip; end
  def redirect_count; end
  def redirect_time; end
  def redirect_url; end
  def request_size; end
  def response_body; end
  def response_code; end
  def response_headers; end
  def return_code; end
  def size_download; end
  def size_upload; end
  def speed_download; end
  def speed_upload; end
  def starttransfer_time; end

  # Returns the value of attribute options.
  #
  # source://ethon//lib/ethon/easy/mirror.rb#5
  def to_hash; end

  def total_time; end

  class << self
    # source://ethon//lib/ethon/easy/mirror.rb#13
    def from_easy(easy); end
  end
end

# source://ethon//lib/ethon/easy/mirror.rb#11
Ethon::Easy::Mirror::INFORMATIONS_TO_LOG = T.let(T.unsafe(nil), Array)

# source://ethon//lib/ethon/easy/mirror.rb#8
Ethon::Easy::Mirror::INFORMATIONS_TO_MIRROR = T.let(T.unsafe(nil), Array)

# This module contains the logic to prepare and perform
# an easy.
#
# source://ethon//lib/ethon/easy/operations.rb#6
module Ethon::Easy::Operations
  # Clean up the easy.
  #
  # @example Perform clean up.
  #   easy.cleanup
  # @return the result of the free which is nil
  #
  # source://ethon//lib/ethon/easy/operations.rb#44
  def cleanup; end

  # Returns a pointer to the curl easy handle.
  #
  # @example Return the handle.
  #   easy.handle
  # @return [FFI::Pointer] A pointer to the curl easy handle.
  #
  # source://ethon//lib/ethon/easy/operations.rb#13
  def handle; end

  # Sets a pointer to the curl easy handle.
  #
  # @param Easy [::FFI::Pointer] handle that will be assigned.
  #
  # source://ethon//lib/ethon/easy/operations.rb#19
  def handle=(h); end

  # Perform the easy request.
  #
  # @example Perform the request.
  #   easy.perform
  # @return [Integer] The return code.
  #
  # source://ethon//lib/ethon/easy/operations.rb#29
  def perform; end

  # Prepare the easy. Options, headers and callbacks
  # were set.
  #
  # @deprecated It is no longer necessary to call prepare.
  # @example Prepare easy.
  #   easy.prepare
  #
  # source://ethon//lib/ethon/easy/operations.rb#55
  def prepare; end
end

# This module contains the logic and knowledge about the
# available options on easy.
#
# source://ethon//lib/ethon/easy/options.rb#7
module Ethon::Easy::Options
  # source://ethon//lib/ethon/easy/options.rb#35
  def accept_encoding=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def accepttimeout_ms=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def address_scope=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def append=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def autoreferer=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def buffersize=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def cainfo=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def capath=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def certinfo=(value); end

  # source://ethon//lib/ethon/easy/options.rb#41
  def chunk_bgn_function(&block); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def chunk_bgn_function=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def chunk_data=(value); end

  # source://ethon//lib/ethon/easy/options.rb#41
  def chunk_end_function(&block); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def chunk_end_function=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def closesocketdata=(value); end

  # source://ethon//lib/ethon/easy/options.rb#41
  def closesocketfunction(&block); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def closesocketfunction=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def connect_only=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def connecttimeout=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def connecttimeout_ms=(value); end

  # source://ethon//lib/ethon/easy/options.rb#41
  def conv_from_network_function(&block); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def conv_from_network_function=(value); end

  # source://ethon//lib/ethon/easy/options.rb#41
  def conv_from_utf8_function(&block); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def conv_from_utf8_function=(value); end

  # source://ethon//lib/ethon/easy/options.rb#41
  def conv_to_network_function(&block); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def conv_to_network_function=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def cookie=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def cookiefile=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def cookiejar=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def cookielist=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def cookiesession=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def copypostfields=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def crlf=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def crlfile=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def customrequest=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def debugdata=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def debugfunction=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def dirlistonly=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def dns_cache_timeout=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def dns_interface=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def dns_local_ip4=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def dns_servers=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def dns_shuffle_addresses=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def dns_use_global_cache=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def egdsocket=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def encoding=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def errorbuffer=(value); end

  # source://ethon//lib/ethon/easy/options.rb#15
  def escape=(b); end

  # @return [Boolean]
  #
  # source://ethon//lib/ethon/easy/options.rb#19
  def escape?; end

  # source://ethon//lib/ethon/easy/options.rb#35
  def failonerror=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def file=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def filetime=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def fnmatch_data=(value); end

  # source://ethon//lib/ethon/easy/options.rb#41
  def fnmatch_function(&block); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def fnmatch_function=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def followlocation=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def forbid_reuse=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def fresh_connect=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ftp_account=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ftp_alternative_to_user=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ftp_create_missing_dirs=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ftp_filemethod=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ftp_response_timeout=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ftp_skip_pasv_ip=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ftp_ssl=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ftp_ssl_ccc=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ftp_use_eprt=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ftp_use_epsv=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ftp_use_pret=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ftpappend=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ftplistonly=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ftpport=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ftpsslauth=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def gssapi_delegation=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def header=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def headerdata=(value); end

  # source://ethon//lib/ethon/easy/options.rb#41
  def headerfunction(&block); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def headerfunction=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def http200aliases=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def http_content_decoding=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def http_transfer_decoding=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def http_version=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def httpauth=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def httpget=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def httpheader=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def httppost=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def httpproxytunnel=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ignore_content_length=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def infile=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def infilesize=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def infilesize_large=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def interface=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def interleavedata=(value); end

  # source://ethon//lib/ethon/easy/options.rb#41
  def interleavefunction(&block); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def interleavefunction=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ioctldata=(value); end

  # source://ethon//lib/ethon/easy/options.rb#41
  def ioctlfunction(&block); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ioctlfunction=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ipresolve=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def issuercert=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def keypasswd=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def khstat=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def krb4level=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def krblevel=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def localport=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def localportrange=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def low_speed_limit=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def low_speed_time=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def mail_auth=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def mail_from=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def mail_rcpt=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def max_recv_speed_large=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def max_send_speed_large=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def maxconnects=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def maxfilesize=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def maxfilesize_large=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def maxredirs=(value); end

  # source://ethon//lib/ethon/easy/options.rb#24
  def multipart=(b); end

  # @return [Boolean]
  #
  # source://ethon//lib/ethon/easy/options.rb#28
  def multipart?; end

  # source://ethon//lib/ethon/easy/options.rb#35
  def netrc=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def netrc_file=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def new_directory_perms=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def new_file_perms=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def nobody=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def noprogress=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def noproxy=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def nosignal=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def opensocketdata=(value); end

  # source://ethon//lib/ethon/easy/options.rb#41
  def opensocketfunction(&block); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def opensocketfunction=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def password=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def path_as_is=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def pinned_public_key=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def pinnedpublickey=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def pipewait=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def port=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def post301=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def post=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def postfields=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def postfieldsize=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def postfieldsize_large=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def postquote=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def postredir=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def pre_proxy=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def prequote=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def private=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def progressdata=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def progressfunction=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def protocols=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_cainfo=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_capath=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_crlfile=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_issuercert=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_keypasswd=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_pinned_public_key=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_pinnedpublickey=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_ssl_cipher_list=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_ssl_options=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_ssl_verifyhost=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_ssl_verifypeer=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_sslcert=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_sslcertpasswd=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_sslcerttype=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_sslkey=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_sslkeypasswd=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_sslkeytype=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_sslversion=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_tlsauth_password=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_tlsauth_type=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_tlsauth_username=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxy_transfer_mode=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxyauth=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxypassword=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxyport=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxytype=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxyusername=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def proxyuserpwd=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def put=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def quote=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def random_file=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def range=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def readdata=(value); end

  # source://ethon//lib/ethon/easy/options.rb#41
  def readfunction(&block); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def readfunction=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def redir_protocols=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def referer=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def resolve=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def resume_from=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def resume_from_large=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def rtsp_client_cseq=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def rtsp_request=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def rtsp_server_cseq=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def rtsp_session_id=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def rtsp_stream_uri=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def rtsp_transport=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def rtspheader=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def sasl_ir=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def seekdata=(value); end

  # source://ethon//lib/ethon/easy/options.rb#41
  def seekfunction(&block); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def seekfunction=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def server_response_timeout=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def share=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def sockoptdata=(value); end

  # source://ethon//lib/ethon/easy/options.rb#41
  def sockoptfunction(&block); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def sockoptfunction=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def socks5_gssapi_nec=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def socks5_gssapi_service=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ssh_auth_types=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ssh_host_public_key_md5=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ssh_keydata=(value); end

  # source://ethon//lib/ethon/easy/options.rb#41
  def ssh_keyfunction(&block); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ssh_keyfunction=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ssh_knownhosts=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ssh_private_keyfile=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ssh_public_keyfile=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ssl_cipher_list=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ssl_ctx_data=(value); end

  # source://ethon//lib/ethon/easy/options.rb#41
  def ssl_ctx_function(&block); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ssl_ctx_function=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ssl_options=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ssl_sessionid_cache=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ssl_verifyhost=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def ssl_verifypeer=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def sslcert=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def sslcertpasswd=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def sslcerttype=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def sslengine=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def sslengine_default=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def sslkey=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def sslkeypasswd=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def sslkeytype=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def sslversion=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def stderr=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def tcp_fastopen=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def tcp_keepalive=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def tcp_keepidle=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def tcp_keepintvl=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def tcp_nodelay=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def telnetoptions=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def tftp_blksize=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def timecondition=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def timeout=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def timeout_ms=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def timevalue=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def tlsauth_password=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def tlsauth_type=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def tlsauth_username=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def transfer_encoding=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def transfertext=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def unix_socket=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def unix_socket_path=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def unrestricted_auth=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def upload=(value); end

  # Returns the value of attribute url.
  #
  # source://ethon//lib/ethon/easy/options.rb#8
  def url; end

  # source://ethon//lib/ethon/easy/options.rb#10
  def url=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def use_ssl=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def useragent=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def username=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def userpwd=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def verbose=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def wildcardmatch=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def writedata=(value); end

  # source://ethon//lib/ethon/easy/options.rb#41
  def writefunction(&block); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def writefunction=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def writeheader=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def xferinfodata=(value); end

  # source://ethon//lib/ethon/easy/options.rb#35
  def xferinfofunction=(value); end
end

# This class represents HTTP request parameters.
#
# @api private
#
# source://ethon//lib/ethon/easy/params.rb#11
class Ethon::Easy::Params
  include ::Ethon::Easy::Util
  include ::Ethon::Easy::Queryable

  # Create a new Params.
  #
  # @api private
  # @example Create a new Params.
  #   Params.new({})
  # @param params [Hash] The params to use.
  # @return [Params] A new Params.
  #
  # source://ethon//lib/ethon/easy/params.rb#23
  def initialize(easy, params); end

  # source://ethon//lib/ethon/easy/queryable.rb#11
  def escape; end

  # source://ethon//lib/ethon/easy/queryable.rb#11
  def escape=(_arg0); end

  # source://ethon//lib/ethon/easy/queryable.rb#12
  def params_encoding; end

  # source://ethon//lib/ethon/easy/queryable.rb#12
  def params_encoding=(_arg0); end
end

# This module contains logic about building
# query parameters for url or form.
#
# source://ethon//lib/ethon/easy/queryable.rb#7
module Ethon::Easy::Queryable
  # Return query pairs build from a hash.
  #
  # @example Build query pairs.
  #   action.build_query_pairs({a: 1, b: 2})
  #   #=> [[:a, 1], [:b, 2]]
  # @param hash [Hash] The hash to go through.
  # @return [Array] The array of query pairs.
  #
  # source://ethon//lib/ethon/easy/queryable.rb#62
  def build_query_pairs(hash); end

  # Return wether there are elements in params or not.
  #
  # @example Return if params is empty.
  #   form.empty?
  # @return [Boolean] True if params is empty, else false.
  #
  # source://ethon//lib/ethon/easy/queryable.rb#21
  def empty?; end

  # Return file info for a file.
  #
  # @example Return file info.
  #   action.file_info(File.open('fubar', 'r'))
  # @param file [File] The file to handle.
  # @return [Array] Array of informations.
  #
  # source://ethon//lib/ethon/easy/queryable.rb#78
  def file_info(file); end

  # Return the query pairs.
  #
  # @example Return the query pairs.
  #   params.query_pairs
  # @return [Array] The query pairs.
  #
  # source://ethon//lib/ethon/easy/queryable.rb#49
  def query_pairs; end

  # Return the string representation of params.
  #
  # @example Return string representation.
  #   params.to_s
  # @return [String] The string representation.
  #
  # source://ethon//lib/ethon/easy/queryable.rb#31
  def to_s; end

  private

  # source://ethon//lib/ethon/easy/queryable.rb#114
  def encode_hash_pairs(h, prefix, pairs); end

  # source://ethon//lib/ethon/easy/queryable.rb#121
  def encode_indexed_array_pairs(h, prefix, pairs); end

  # source://ethon//lib/ethon/easy/queryable.rb#135
  def encode_multi_array_pairs(h, prefix, pairs); end

  # source://ethon//lib/ethon/easy/queryable.rb#128
  def encode_rack_array_pairs(h, prefix, pairs); end

  # source://ethon//lib/ethon/easy/queryable.rb#89
  def mime_type(filename); end

  # source://ethon//lib/ethon/easy/queryable.rb#142
  def pairs_for(v, key, pairs); end

  # source://ethon//lib/ethon/easy/queryable.rb#97
  def recursively_generate_pairs(h, prefix, pairs); end

  class << self
    # source://ethon//lib/ethon/easy/queryable.rb#10
    def included(base); end
  end
end

# This module contains the logic for the response callbacks.
# The on_complete callback is the only one at the moment.
#
# You can set multiple callbacks, which are then executed
# in the same order.
#
#   easy.on_complete { p 1 }
#   easy.on_complete { p 2 }
#   easy.complete
#   #=> 1
#   #=> 2
#
# You can clear the callbacks:
#
#   easy.on_complete { p 1 }
#   easy.on_complete { p 2 }
#   easy.on_complete.clear
#   easy.on_complete
#   #=> []
#
# source://ethon//lib/ethon/easy/response_callbacks.rb#24
module Ethon::Easy::ResponseCallbacks
  # Execute on_body callbacks.
  #
  # @example Execute on_body.
  #   request.body("This data came from HTTP.")
  # @return [Object] If there are no on_body callbacks, returns the symbol :unyielded.
  #
  # source://ethon//lib/ethon/easy/response_callbacks.rb#122
  def body(chunk); end

  # Execute on_complete callbacks.
  #
  # @example Execute on_completes.
  #   request.complete
  #
  # source://ethon//lib/ethon/easy/response_callbacks.rb#71
  def complete; end

  # Execute on_headers callbacks.
  #
  # @example Execute on_headers.
  #   request.headers
  #
  # source://ethon//lib/ethon/easy/response_callbacks.rb#42
  def headers; end

  # Set on_body callback.
  #
  # @example Set on_body.
  #   request.on_body { |chunk| p "yay" }
  # @param block [Block] The block to execute.
  #
  # source://ethon//lib/ethon/easy/response_callbacks.rb#110
  def on_body(&block); end

  # Set on_complete callback.
  #
  # @example Set on_complete.
  #   request.on_complete { p "yay" }
  # @param block [Block] The block to execute.
  #
  # source://ethon//lib/ethon/easy/response_callbacks.rb#61
  def on_complete(&block); end

  # Set on_headers callback.
  #
  # @example Set on_headers.
  #   request.on_headers { p "yay" }
  # @param block [Block] The block to execute.
  #
  # source://ethon//lib/ethon/easy/response_callbacks.rb#32
  def on_headers(&block); end

  # Set on_progress callback.
  #
  # @example Set on_progress.
  #   request.on_progress {|dltotal, dlnow, ultotal, ulnow| p "#{dltotal} #{dlnow} #{ultotal} #{ulnow}" }
  # @param block [Block] The block to execute.
  #
  # source://ethon//lib/ethon/easy/response_callbacks.rb#84
  def on_progress(&block); end

  # Execute on_progress callbacks.
  #
  # @example Execute on_progress.
  #   request.body(1, 1, 1, 1)
  #
  # source://ethon//lib/ethon/easy/response_callbacks.rb#98
  def progress(dltotal, dlnow, ultotal, ulnow); end
end

# This module contains small helpers.
#
# @api private
#
# source://ethon//lib/ethon/easy/util.rb#8
module Ethon::Easy::Util
  extend ::Ethon::Easy::Util

  # Escapes zero bytes in strings.
  #
  # @api private
  # @example Escape zero bytes.
  #   Util.escape_zero_byte("1\0")
  #   #=> "1\\0"
  # @param value [Object] The value to escape.
  # @return [String, Object] Escaped String if
  #   zero byte found, original object if not.
  #
  # source://ethon//lib/ethon/easy/util.rb#20
  def escape_zero_byte(value); end
end

# This namespace contains all errors raised by ethon.
#
# source://ethon//lib/ethon/errors/ethon_error.rb#3
module Ethon::Errors; end

# Default Ethon error class for all custom errors.
#
# source://ethon//lib/ethon/errors/ethon_error.rb#6
class Ethon::Errors::EthonError < ::StandardError; end

# Raises when global_init failed.
#
# source://ethon//lib/ethon/errors/global_init.rb#6
class Ethon::Errors::GlobalInit < ::Ethon::Errors::EthonError
  # @return [GlobalInit] a new instance of GlobalInit
  #
  # source://ethon//lib/ethon/errors/global_init.rb#7
  def initialize; end
end

# Raises when option is invalid.
#
# source://ethon//lib/ethon/errors/invalid_option.rb#6
class Ethon::Errors::InvalidOption < ::Ethon::Errors::EthonError
  # @return [InvalidOption] a new instance of InvalidOption
  #
  # source://ethon//lib/ethon/errors/invalid_option.rb#7
  def initialize(option); end
end

# Raises when option is invalid.
#
# source://ethon//lib/ethon/errors/invalid_value.rb#6
class Ethon::Errors::InvalidValue < ::Ethon::Errors::EthonError
  # @return [InvalidValue] a new instance of InvalidValue
  #
  # source://ethon//lib/ethon/errors/invalid_value.rb#7
  def initialize(option, value); end
end

# Raises when multi_add_handle failed.
#
# source://ethon//lib/ethon/errors/multi_add.rb#6
class Ethon::Errors::MultiAdd < ::Ethon::Errors::EthonError
  # @return [MultiAdd] a new instance of MultiAdd
  #
  # source://ethon//lib/ethon/errors/multi_add.rb#7
  def initialize(code, easy); end
end

# Raises when multi_fdset failed.
#
# source://ethon//lib/ethon/errors/multi_fdset.rb#6
class Ethon::Errors::MultiFdset < ::Ethon::Errors::EthonError
  # @return [MultiFdset] a new instance of MultiFdset
  #
  # source://ethon//lib/ethon/errors/multi_fdset.rb#7
  def initialize(code); end
end

# Raises when multi_remove_handle failed.
#
# source://ethon//lib/ethon/errors/multi_remove.rb#6
class Ethon::Errors::MultiRemove < ::Ethon::Errors::EthonError
  # @return [MultiRemove] a new instance of MultiRemove
  #
  # source://ethon//lib/ethon/errors/multi_remove.rb#7
  def initialize(code, easy); end
end

# Raised when multi_timeout failed.
#
# source://ethon//lib/ethon/errors/multi_timeout.rb#6
class Ethon::Errors::MultiTimeout < ::Ethon::Errors::EthonError
  # @return [MultiTimeout] a new instance of MultiTimeout
  #
  # source://ethon//lib/ethon/errors/multi_timeout.rb#7
  def initialize(code); end
end

# Raised when select failed.
#
# source://ethon//lib/ethon/errors/select.rb#6
class Ethon::Errors::Select < ::Ethon::Errors::EthonError
  # @return [Select] a new instance of Select
  #
  # source://ethon//lib/ethon/errors/select.rb#7
  def initialize(errno); end
end

# FFI Wrapper module for Libc.
#
# @api private
#
# source://ethon//lib/ethon/libc.rb#7
module Ethon::Libc
  extend ::FFI::Library

  def free(*_arg0); end
  def getdtablesize(*_arg0); end

  class << self
    def free(*_arg0); end
    def getdtablesize(*_arg0); end

    # @api private
    # @return [Boolean]
    #
    # source://ethon//lib/ethon/libc.rb#12
    def windows?; end
  end
end

# Contains logging behaviour.
#
# source://ethon//lib/ethon/loggable.rb#6
module Ethon::Loggable
  # Get the logger.
  #
  # @example Get the logger.
  #   Loggable.logger
  # @note Will try to grab Rails' logger first before creating a new logger
  #   with stdout.
  # @return [Logger] The logger.
  #
  # source://ethon//lib/ethon/loggable.rb#17
  def logger; end

  # Set the logger.
  #
  # @example Set the logger.
  #   Loggable.logger = Logger.new($stdout)
  # @param logger [Logger] The logger to set.
  # @return [Logger] The new logger.
  #
  # source://ethon//lib/ethon/loggable.rb#30
  def logger=(logger); end

  private

  # Gets the default Ethon logger - stdout.
  #
  # @example Get the default logger.
  #   Loggable.default_logger
  # @return [Logger] The default logger.
  #
  # source://ethon//lib/ethon/loggable.rb#42
  def default_logger; end

  # Get the Rails logger if it's defined.
  #
  # @example Get Rails' logger.
  #   Loggable.rails_logger
  # @return [Logger] The Rails logger.
  #
  # source://ethon//lib/ethon/loggable.rb#54
  def rails_logger; end
end

# This class represents libcurl multi.
#
# source://ethon//lib/ethon/multi/stack.rb#3
class Ethon::Multi
  include ::Ethon::Multi::Stack
  include ::Ethon::Multi::Operations
  include ::Ethon::Multi::Options

  # Create a new multi. Initialize curl in case
  # it didn't happen before.
  #
  # Pass a long. The set number will be used as the maximum amount of
  # simultaneously open connections in total. For each new session,
  # libcurl will open a new connection up to the limit set by
  # CURLMOPT_MAX_TOTAL_CONNECTIONS. When the limit is reached, the
  # sessions will be pending until there are available connections.
  # If CURLMOPT_PIPELINING is 1, libcurl will try to pipeline if the host
  # is capable of it.
  # The default value is 0, which means that there is no limit. However,
  # for backwards compatibility, setting it to 0 when CURLMOPT_PIPELINING
  # is 1 will not be treated as unlimited. Instead it will open only 1
  # connection and try to pipeline on it.
  # (Added in 7.30.0)
  #
  # @example Create a new Multi.
  #   Multi.new
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] The options.
  # @return [Multi] The new multi.
  #
  # source://ethon//lib/ethon/multi.rb#89
  def initialize(options = T.unsafe(nil)); end

  # Set given options.
  #
  # @api private
  # @example Set options.
  #   multi.set_attributes(options)
  # @raise InvalidOption
  # @see initialize
  #
  # source://ethon//lib/ethon/multi.rb#106
  def set_attributes(options); end

  private

  # Internal function to gate functions to a specific execution mode
  #
  # @api private
  # @raise ArgumentError
  #
  # source://ethon//lib/ethon/multi.rb#122
  def ensure_execution_mode(expected_mode); end
end

# This module contains logic to run a multi.
#
# source://ethon//lib/ethon/multi/operations.rb#5
module Ethon::Multi::Operations
  # Return the multi handle. Inititialize multi handle,
  # in case it didn't happened already.
  #
  # @example Return multi handle.
  #   multi.handle
  # @return [FFI::Pointer] The multi handle.
  #
  # source://ethon//lib/ethon/multi/operations.rb#16
  def handle; end

  # Initialize variables.
  #
  # @example Initialize variables.
  #   multi.init_vars
  # @return [void]
  #
  # source://ethon//lib/ethon/multi/operations.rb#26
  def init_vars; end

  # Return whether the multi still contains requests or not.
  #
  # @example Return if ongoing.
  #   multi.ongoing?
  # @return [Boolean] True if ongoing, else false.
  #
  # source://ethon//lib/ethon/multi/operations.rb#113
  def ongoing?; end

  # Perform multi.
  #
  # @example Perform multi.
  #   multi.perform
  # @return [nil]
  #
  # source://ethon//lib/ethon/multi/operations.rb#45
  def perform; end

  # Prepare multi.
  #
  # @deprecated It is no longer necessary to call prepare.
  # @example Prepare multi.
  #   multi.prepare
  # @return [nil]
  #
  # source://ethon//lib/ethon/multi/operations.rb#68
  def prepare; end

  # Continue execution with an external IO loop.
  #
  # @example When no sockets are ready yet, or to begin.
  #   multi.socket_action
  # @example When a socket is readable
  #   multi.socket_action(io_object, [:in])
  # @example When a socket is readable and writable
  #   multi.socket_action(io_object, [:in, :out])
  # @return [Symbol] The Curl.multi_socket_action return code.
  #
  # source://ethon//lib/ethon/multi/operations.rb#88
  def socket_action(io = T.unsafe(nil), readiness = T.unsafe(nil)); end

  private

  # Check.
  #
  # @example Check.
  #   multi.check
  # @return [void]
  #
  # source://ethon//lib/ethon/multi/operations.rb#179
  def check; end

  # Get timeout.
  #
  # @example Get timeout.
  #   multi.get_timeout
  # @raise [Ethon::Errors::MultiTimeout] If getting the timeout fails.
  # @return [Integer] The timeout.
  #
  # source://ethon//lib/ethon/multi/operations.rb#127
  def get_timeout; end

  # Reset file describtors.
  #
  # @example Reset fds.
  #   multi.reset_fds
  # @return [void]
  #
  # source://ethon//lib/ethon/multi/operations.rb#141
  def reset_fds; end

  # Run.
  #
  # @example Run
  #   multi.run
  # @return [void]
  #
  # source://ethon//lib/ethon/multi/operations.rb#199
  def run; end

  # Return number of running requests.
  #
  # @example Return count.
  #   multi.running_count
  # @return [Integer] Number running requests.
  #
  # source://ethon//lib/ethon/multi/operations.rb#223
  def running_count; end

  # Set fds.
  #
  # @example Set fds.
  #   multi.set_fds
  # @raise [Ethon::Errors::MultiFdset] If setting the file descriptors fails.
  # @raise [Ethon::Errors::Select] If select fails.
  # @return [void]
  #
  # source://ethon//lib/ethon/multi/operations.rb#156
  def set_fds(timeout); end

  # Trigger.
  #
  # @example Trigger.
  #   multi.trigger
  # @return [Symbol] The Curl.multi_perform return code.
  #
  # source://ethon//lib/ethon/multi/operations.rb#211
  def trigger(running_count_pointer); end
end

# source://ethon//lib/ethon/multi/operations.rb#7
Ethon::Multi::Operations::PERFORMED_MULTI = T.let(T.unsafe(nil), String)

# source://ethon//lib/ethon/multi/operations.rb#6
Ethon::Multi::Operations::STARTED_MULTI = T.let(T.unsafe(nil), String)

# This module contains the logic and knowledge about the
# available options on multi.
#
# source://ethon//lib/ethon/multi/options.rb#7
module Ethon::Multi::Options
  # Sets max_total_connections option.
  #
  # @example Set max_total_connections option.
  #   multi.max_total_conections = $value
  # @param value [String] The value to set.
  # @return [void]
  #
  # source://ethon//lib/ethon/multi/options.rb#17
  def max_total_connections=(value); end

  # Sets maxconnects option.
  #
  # @example Set maxconnects option.
  #   multi.maxconnects = $value
  # @param value [String] The value to set.
  # @return [void]
  #
  # source://ethon//lib/ethon/multi/options.rb#29
  def maxconnects=(value); end

  # Sets pipelining option.
  #
  # @example Set pipelining option.
  #   multi.pipelining = $value
  # @param value [String] The value to set.
  # @return [void]
  #
  # source://ethon//lib/ethon/multi/options.rb#41
  def pipelining=(value); end

  # Sets socketdata option.
  #
  # @example Set socketdata option.
  #   multi.socketdata = $value
  # @param value [String] The value to set.
  # @return [void]
  #
  # source://ethon//lib/ethon/multi/options.rb#53
  def socketdata=(value); end

  # Sets socketfunction option.
  #
  # @example Set socketfunction option.
  #   multi.socketfunction = $value
  # @param value [String] The value to set.
  # @return [void]
  #
  # source://ethon//lib/ethon/multi/options.rb#65
  def socketfunction=(value); end

  # Sets timerdata option.
  #
  # @example Set timerdata option.
  #   multi.timerdata = $value
  # @param value [String] The value to set.
  # @return [void]
  #
  # source://ethon//lib/ethon/multi/options.rb#77
  def timerdata=(value); end

  # Sets timerfunction option.
  #
  # @example Set timerfunction option.
  #   multi.timerfunction = $value
  # @param value [String] The value to set.
  # @return [void]
  #
  # source://ethon//lib/ethon/multi/options.rb#89
  def timerfunction=(value); end

  private

  # Return the value to set to multi handle. It is converted with the help
  # of bool_options, enum_options and int_options.
  #
  # @example Return casted the value.
  #   multi.value_for(:verbose)
  # @return [Object] The casted value.
  #
  # source://ethon//lib/ethon/multi/options.rb#102
  def value_for(value, type, option = T.unsafe(nil)); end
end

# This module provides the multi stack behaviour.
#
# source://ethon//lib/ethon/multi/stack.rb#6
module Ethon::Multi::Stack
  # Add an easy to the stack.
  #
  # @example Add easy.
  #   multi.add(easy)
  # @param easy [Easy] The easy to add.
  # @raise [Ethon::Errors::MultiAdd] If adding an easy failed.
  #
  # source://ethon//lib/ethon/multi/stack.rb#26
  def add(easy); end

  # Delete an easy from stack.
  #
  # @example Delete easy from stack.
  # @param easy [Easy] The easy to delete.
  # @raise [Ethon::Errors::MultiRemove] If removing an easy failed.
  #
  # source://ethon//lib/ethon/multi/stack.rb#41
  def delete(easy); end

  # Return easy handles.
  #
  # @example Return easy handles.
  #   multi.easy_handles
  # @return [Array] The easy handles.
  #
  # source://ethon//lib/ethon/multi/stack.rb#14
  def easy_handles; end
end

# Ethon version.
#
# source://ethon//lib/ethon/version.rb#5
Ethon::VERSION = T.let(T.unsafe(nil), String)
