# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `haml_lint` gem.
# Please instead update this file by running `bin/tapioca gem haml_lint`.

module Haml; end

# Haml does heavy transformations to strings that contain interpolation without a way
# of perfectly inverting that transformation.
#
# We need this monkey patch to have a way of recovering the original strings as they
# are in the haml files, so that we can use them and then autocorrect them.
#
# The HamlLint::Document carries over a hash of interpolation to original string. The
# below patches are there to extract said information from Haml's parsing.
#
# source://haml_lint//lib/haml_lint/extensions/haml_util_unescape_interpolation_tracking.rb#11
module Haml::Util
  # source://haml/6.1.2/lib/haml/util.rb#171
  def balance(scanner, start, finish, count = T.unsafe(nil)); end

  # source://haml/6.1.2/lib/haml/util.rb#65
  def check_encoding(str); end

  # source://haml/6.1.2/lib/haml/util.rb#112
  def check_haml_encoding(str, &block); end

  # source://haml/6.1.2/lib/haml/util.rb#200
  def contains_interpolation?(str); end

  # source://haml/6.1.2/lib/haml/util.rb#150
  def handle_interpolation(str); end

  # source://haml/6.1.2/lib/haml/util.rb#187
  def human_indentation(indentation); end

  # source://haml/6.1.2/lib/haml/util.rb#129
  def inspect_obj(obj); end

  # source://haml/6.1.2/lib/haml/util.rb#51
  def rails_xss_safe?; end

  # source://haml/6.1.2/lib/haml/util.rb#37
  def silence_warnings; end

  # Overriding the unescape_interpolation method to store the return and original string
  # in the cache.
  #
  # source://haml_lint//lib/haml_lint/extensions/haml_util_unescape_interpolation_tracking.rb#27
  def unescape_interpolation(str, escape_html = T.unsafe(nil)); end

  # Overriding the unescape_interpolation method to store the return and original string
  # in the cache.
  #
  # source://haml_lint//lib/haml_lint/extensions/haml_util_unescape_interpolation_tracking.rb#27
  def unescape_interpolation_with_original_tracking(str, escape_html = T.unsafe(nil)); end

  # source://haml/6.1.2/lib/haml/util.rb#204
  def unescape_interpolation_without_original_tracking(str, escape_html = T.unsafe(nil)); end

  private

  # source://haml/6.1.2/lib/haml/util.rb#236
  def parse_haml_magic_comment(str); end

  # source://haml/6.1.2/lib/haml/util.rb#248
  def try_parse_haml_emacs_magic_comment(scanner); end

  class << self
    def escape_html(_arg0); end

    # source://haml/6.1.2/lib/haml/util.rb#29
    def escape_html_safe(html); end

    # The cache for the current Thread (technically Fiber)
    #
    # source://haml_lint//lib/haml_lint/extensions/haml_util_unescape_interpolation_tracking.rb#13
    def unescape_interpolation_to_original_cache; end

    # As soon as a HamlLint::Document has finished processing a HAML souce, this gets called to
    # get a copy of this cache and clear up for the next HAML processing
    #
    # source://haml_lint//lib/haml_lint/extensions/haml_util_unescape_interpolation_tracking.rb#19
    def unescape_interpolation_to_original_cache_take_and_wipe; end
  end
end

# Defines the gem version.
#
# source://haml_lint//lib/haml_lint/constants.rb#4
module HamlLint; end

# source://haml_lint//lib/haml_lint/constants.rb#6
HamlLint::APP_NAME = T.let(T.unsafe(nil), String)

# Determines the adapter to use for the current Haml version
#
# source://haml_lint//lib/haml_lint/adapter/haml_4.rb#6
class HamlLint::Adapter
  class << self
    # Detects the adapter to use for the current Haml version
    #
    # @api public
    # @example
    #   HamlLint::Adapter.detect_class.new('%div')
    # @raise [HamlLint::Exceptions::UnknownHamlVersion]
    # @return [Class] the adapter class
    #
    # source://haml_lint//lib/haml_lint/adapter.rb#19
    def detect_class; end

    private

    # Determines the approximate version of Haml that is installed
    #
    # @api private
    # @return [String] the approximate Haml version
    #
    # source://haml_lint//lib/haml_lint/adapter.rb#33
    def haml_version; end
  end
end

# Adapts the Haml::Parser from Haml 4 for use in HamlLint
# :reek:UncommunicativeModuleName
#
# source://haml_lint//lib/haml_lint/adapter/haml_4.rb#9
class HamlLint::Adapter::Haml4 < ::HamlLint::Adapter
  extend ::Forwardable

  # Parses the specified Haml code into an abstract syntax tree
  #
  # @api public
  # @example
  #   HamlLint::Adapter::Haml4.new('%div')
  # @param source [String] Haml code to parse
  # @param options [Haml::Options]
  # @return [Haml4] a new instance of Haml4
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_4.rb#20
  def initialize(source, options = T.unsafe(nil)); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def parse(*args, **_arg1, &block); end

  # source://haml_lint//lib/haml_lint/adapter/haml_4.rb#25
  def precompile; end

  private

  # The Haml parser to adapt for HamlLint
  #
  # @api private
  # @return [Haml::Parser] the Haml 4 parser
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_4.rb#53
  def parser; end

  # The Haml code to parse
  #
  # @api private
  # @return [String] Haml code to parse
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_4.rb#59
  def source; end
end

# Adapts the Haml::Parser from Haml 5 for use in HamlLint
# :reek:UncommunicativeModuleName
#
# source://haml_lint//lib/haml_lint/adapter/haml_5.rb#15
class HamlLint::Adapter::Haml5 < ::HamlLint::Adapter
  # Parses the specified Haml code into an abstract syntax tree
  #
  # @api public
  # @example
  #   HamlLint::Adapter::Haml5.new('%div')
  # @param source [String] Haml code to parse
  # @param options [Haml::Options]
  # @return [Haml5] a new instance of Haml5
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_5.rb#16
  def initialize(source, options = T.unsafe(nil)); end

  # Parses the source code into an abstract syntax tree
  #
  # @api public
  # @example
  #   HamlLint::Adapter::Haml5.new('%div').parse
  # @raise [Haml::Error]
  # @return [Haml::Parser::ParseNode]
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_5.rb#29
  def parse; end

  # source://haml_lint//lib/haml_lint/adapter/haml_5.rb#33
  def precompile; end

  private

  # The Haml parser to adapt for HamlLint
  #
  # @api private
  # @return [Haml::Parser] the Haml 4 parser
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_5.rb#50
  def parser; end

  # The Haml code to parse
  #
  # @api private
  # @return [String] Haml code to parse
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_5.rb#56
  def source; end
end

# Adapts the Haml::Parser from Haml 5 for use in HamlLint
# :reek:UncommunicativeModuleName
#
# source://haml_lint//lib/haml_lint/adapter/haml_6.rb#15
class HamlLint::Adapter::Haml6 < ::HamlLint::Adapter
  # Parses the specified Haml code into an abstract syntax tree
  #
  # @api public
  # @example
  #   HamlLint::Adapter::Haml6.new('%div')
  # @param source [String] Haml code to parse
  # @param options [private Haml::Parser::ParserOptions]
  # @return [Haml6] a new instance of Haml6
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_6.rb#16
  def initialize(source, options = T.unsafe(nil)); end

  # Parses the source code into an abstract syntax tree
  #
  # @api public
  # @example
  #   HamlLint::Adapter::Haml6.new('%div').parse
  # @raise [Haml::Error]
  # @return [Haml::Parser::ParseNode]
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_6.rb#29
  def parse; end

  # source://haml_lint//lib/haml_lint/adapter/haml_6.rb#33
  def precompile; end

  private

  # The Haml parser to adapt for HamlLint
  #
  # @api private
  # @return [Haml::Parser] the Haml 4 parser
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_6.rb#50
  def parser; end

  # The Haml code to parse
  #
  # @api private
  # @return [String] Haml code to parse
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_6.rb#56
  def source; end
end

# source://haml_lint//lib/haml_lint/constants.rb#9
HamlLint::BUG_REPORT_URL = T.let(T.unsafe(nil), String)

# Determines what linters are enabled or disabled via comments.
#
# source://haml_lint//lib/haml_lint/comment_configuration.rb#5
class HamlLint::CommentConfiguration
  # Instantiates a new {HamlLint::CommentConfiguration}.
  #
  # @param node [HamlLint::Tree::Node] the node to configure
  # @return [CommentConfiguration] a new instance of CommentConfiguration
  #
  # source://haml_lint//lib/haml_lint/comment_configuration.rb#9
  def initialize(node); end

  # Checks whether a linter is disabled for the node.
  #
  # @api public
  # @param linter_name [String] the name of the linter
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/comment_configuration.rb#18
  def disabled?(linter_name); end

  private

  # The list of directives in order of precedence.
  #
  # @api private
  # @return [Array<HamlLint::Directive>]
  #
  # source://haml_lint//lib/haml_lint/comment_configuration.rb#30
  def directives; end

  # Finds all directives applicable to the given linter name.
  #
  # @api private
  # @param linter_name [String] the name of the linter
  # @return [Array<HamlLint::Directive>] the filtered directives
  #
  # source://haml_lint//lib/haml_lint/comment_configuration.rb#37
  def directives_for(linter_name); end
end

# Stores runtime configuration for the application.
#
# The purpose of this class is to validate and ensure all configurations
# satisfy some basic pre-conditions so other parts of the application don't
# have to check the configuration for errors. It should have no knowledge of
# how these configuration values are ultimately used.
#
# source://haml_lint//lib/haml_lint/configuration.rb#10
class HamlLint::Configuration
  # Creates a configuration from the given options hash.
  #
  # @param options [Hash]
  # @return [Configuration] a new instance of Configuration
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#17
  def initialize(options, file = T.unsafe(nil)); end

  # Compares this configuration with another.
  #
  # @param other [HamlLint::Configuration]
  # @return [true, false] whether the given configuration is equivalent
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#36
  def ==(other); end

  # Access the configuration as if it were a hash.
  #
  # @param key [String]
  # @return [Array, Hash, Number, String]
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#28
  def [](key); end

  # Returns a non-modifiable configuration for the specified linter.
  #
  # @param linter [HamlLint::Linter, Class]
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#43
  def for_linter(linter); end

  # Internal hash storing the configuration.
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#12
  def hash; end

  # Merges the given configuration with this one, returning a new
  # {Configuration}. The provided configuration will either add to or replace
  # any options defined in this configuration.
  #
  # @param config [HamlLint::Configuration]
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#60
  def merge(config); end

  private

  # Ensures the `exclude` global option is an array.
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#105
  def ensure_exclude_option_array_exists; end

  # Ensure `include` and `exclude` options for linters are arrays
  # (since users can specify a single string glob pattern for convenience)
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#116
  def ensure_linter_include_exclude_arrays_valid; end

  # Ensures the `linters` configuration section exists.
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#110
  def ensure_linter_section_exists; end

  # source://haml_lint//lib/haml_lint/configuration.rb#125
  def ensure_linter_severity_valid; end

  # Requires any extra linters / files specified in the configuration.
  # String starting with a . are treated as relative paths
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#84
  def resolve_requires; end

  # Merge two hashes such that nested hashes are merged rather than replaced.
  #
  # @param parent [Hash]
  # @param child [Hash]
  # @return [Hash]
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#71
  def smart_merge(parent, child); end

  # Validates the configuration for any invalid options, normalizing it where
  # possible.
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#97
  def validate; end
end

# Manages configuration file loading.
#
# source://haml_lint//lib/haml_lint/configuration_loader.rb#9
class HamlLint::ConfigurationLoader
  class << self
    # Loads the built-in default configuration.
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#39
    def default_configuration; end

    # Path to the default config file, if it exists
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#32
    def default_path_to_config; end

    # Load configuration file given the current working directory the
    # application is running within.
    #
    # @option options
    # @param config_file [String] optional path to the config file to load
    # @param options [Hash]
    # @return [HamlLint::Configuration]
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#22
    def load_applicable_config(config_file = T.unsafe(nil), options = T.unsafe(nil)); end

    # Loads a configuration, ensuring it extends the default configuration.
    #
    # @option context
    # @option context
    # @param file [String]
    # @param context [Hash]
    # @return [HamlLint::Configuration]
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#52
    def load_file(file, context = T.unsafe(nil)); end

    # Creates a configuration from the specified hash, ensuring it extends the
    # default configuration.
    #
    # @param hash [Hash]
    # @return [HamlLint::Configuration]
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#77
    def load_hash(hash); end

    private

    # Resolves the config file path relative to a gem
    #
    # @param gem_name [String] name of the gem
    # @param relative_config_path [String] path of the file to resolve, relative to the gem root
    # @return [String]
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#160
    def gem_config_path(gem_name, relative_config_path); end

    # Parses and loads a configuration from the given file.
    #
    # @param file [String]
    # @return [HamlLint::Configuration]
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#89
    def load_from_file(file); end

    # Returns a list of possible configuration files given the context of the
    # specified directory.
    #
    # @param directory [String]
    # @return [Array<Pathname>]
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#120
    def possible_config_files(directory); end

    # Resolves an inherited file and loads it.
    #
    # @param file [String] the path to the file
    # @param loaded_files [Array<String>] previously loaded files in the
    #   inheritance chain
    # @return [HamlLint::Configuration, nil]
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#133
    def resolve(file, context); end

    # Resolves the chain of `inherits_from` directives in a configuration.
    #
    # @param config [HamlLint::Configuration] the pre-existing configuration
    # @param loaded_files [Array<String>] any previously loaded files in an
    #   inheritance chain
    # @return [HamlLint::Configuration]
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#148
    def resolve_inheritance(config, context); end
  end
end

# source://haml_lint//lib/haml_lint/configuration_loader.rb#10
HamlLint::ConfigurationLoader::AUTO_GENERATED_FILE = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/configuration_loader.rb#12
HamlLint::ConfigurationLoader::CONFIG_FILE_NAME = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/configuration_loader.rb#11
HamlLint::ConfigurationLoader::DEFAULT_CONFIG_PATH = T.let(T.unsafe(nil), String)

# Handles linter configuration transformation via Haml comments.
#
# source://haml_lint//lib/haml_lint/directive.rb#5
class HamlLint::Directive
  # Instantiates a new {HamlLint::Directive}
  #
  # @api semipublic
  # @param source [String] the source code to analyze
  # @param line [Integer] the line number the source starts at
  # @param mode [String] the type of directive, one of "disable" or "enable"
  # @param linters [Array<String>] the name of the linters to act upon
  # @return [Directive] a new instance of Directive
  #
  # source://haml_lint//lib/haml_lint/directive.rb#41
  def initialize(source, line, mode, linters); end

  # Checks whether a directive is equivalent to another.
  #
  # @api public
  # @param other [HamlLint::Directive] the other directive
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#63
  def ==(other); end

  # Checks whether this is a disable directive.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#72
  def disable?; end

  # Checks whether this is an enable directive.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#79
  def enable?; end

  # Formats the directive for display in a console.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#86
  def inspect; end

  # The names of the linters to act upon.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#51
  def linters; end

  # The mode of the directive. One of "disable" or "enable".
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#56
  def mode; end

  class << self
    # Constructs a directive from source code as a given line.
    #
    # @param source [String] the source code to analyze
    # @param line [Integer] the line number the source starts at
    # @return [HamlLint::Directive]
    #
    # source://haml_lint//lib/haml_lint/directive.rb#24
    def from_line(source, line); end
  end
end

# source://haml_lint//lib/haml_lint/directive.rb#8
HamlLint::Directive::DIRECTIVE_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://haml_lint//lib/haml_lint/directive.rb#6
HamlLint::Directive::LINTER_REGEXP = T.let(T.unsafe(nil), Regexp)

# A null representation of a directive.
#
# source://haml_lint//lib/haml_lint/directive.rb#95
class HamlLint::Directive::Null < ::HamlLint::Directive
  # Instantiates a new null directive.
  #
  # @param source [String] the source code to analyze
  # @param line [Integer] the line number the source starts at
  # @return [Null] a new instance of Null
  #
  # source://haml_lint//lib/haml_lint/directive.rb#96
  def initialize(source, line); end

  # Stubs out the disable check as false.
  #
  # @return [false]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#104
  def disable?; end

  # Stubs out the ensable check as false.
  #
  # @return [false]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#111
  def enable?; end

  # Formats the null directive for display in a console.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#118
  def inspect; end

  # Stubs out the linters.
  #
  # @return [Array]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#125
  def linters; end
end

# Represents a parsed Haml document and its associated metadata.
#
# source://haml_lint//lib/haml_lint/document.rb#7
class HamlLint::Document
  # Parses the specified Haml code into a {Document}.
  #
  # @option options
  # @param source [String] Haml code to parse
  # @param options [Hash]
  # @raise [Haml::Parser::Error] if there was a problem parsing the document
  # @return [Document] a new instance of Document
  #
  # source://haml_lint//lib/haml_lint/document.rb#40
  def initialize(source, options); end

  # Reparses the new source and remember that the document was changed
  # Used when auto-correct does changes to the file. If the source hasn't changed,
  # then the document will not be marked as changed.
  #
  # If the new_source fails to parse, automatically reparses the previous source
  # to bring the document back to how it should be before re-raising the parse exception
  #
  # @param source [String] Haml code to parse
  #
  # source://haml_lint//lib/haml_lint/document.rb#63
  def change_source(new_source); end

  # @return [HamlLint::Configuration] Configuration used to parse template
  #
  # source://haml_lint//lib/haml_lint/document.rb#12
  def config; end

  # @return [String] Haml template file path
  #
  # source://haml_lint//lib/haml_lint/document.rb#15
  def file; end

  # @return [String] the indentation used in the file
  #
  # source://haml_lint//lib/haml_lint/document.rb#30
  def indentation; end

  # Returns the last non empty line of the document or 1 if all lines are empty
  #
  # @return [Integer] last non empty line of the document or 1 if all lines are empty
  #
  # source://haml_lint//lib/haml_lint/document.rb#50
  def last_non_empty_line; end

  # @return [String] original source code
  #
  # source://haml_lint//lib/haml_lint/document.rb#21
  def source; end

  # @return [Array<String>] original source code as an array of lines
  #
  # source://haml_lint//lib/haml_lint/document.rb#24
  def source_lines; end

  # @return [Boolean] true if the source was changed (by autocorrect)
  #
  # source://haml_lint//lib/haml_lint/document.rb#27
  def source_was_changed; end

  # @return [HamlLint::Tree::Node] Root of the parse tree
  #
  # source://haml_lint//lib/haml_lint/document.rb#18
  def tree; end

  # Returns the value of attribute unescape_interpolation_to_original_cache.
  #
  # source://haml_lint//lib/haml_lint/document.rb#32
  def unescape_interpolation_to_original_cache; end

  # source://haml_lint//lib/haml_lint/document.rb#80
  def write_to_disk!; end

  private

  # source://haml_lint//lib/haml_lint/document.rb#191
  def check_new_source_compatible(new_source); end

  # Converts a HAML parse tree to a tree of {HamlLint::Tree::Node} objects.
  #
  # This provides a cleaner interface with which the linters can interact with
  # the parse tree.
  #
  # @param haml_node [Haml::Parser::ParseNode]
  # @param parent [Haml::Tree::Node]
  # @return [Haml::Tree::Node]
  #
  # source://haml_lint//lib/haml_lint/document.rb#144
  def convert_tree(haml_node, parent = T.unsafe(nil)); end

  # Ensures source code is interpreted as UTF-8.
  #
  # This is necessary as sometimes Ruby guesses the encoding of a file
  # incorrectly, for example if the LC_ALL environment variable is set to "C".
  #
  # @param source [String]
  # @return [String] source encoded with UTF-8 encoding
  # @see http://unix.stackexchange.com/a/87763
  #
  # source://haml_lint//lib/haml_lint/document.rb#163
  def process_encoding(source); end

  # @param source [String] Haml code to parse
  # @raise [HamlLint::Exceptions::ParseError] if there was a problem parsing
  #
  # source://haml_lint//lib/haml_lint/document.rb#93
  def process_source(source); end

  # Processes the {Haml::Parser::ParseNode} tree and returns a tree composed
  # of friendlier {HamlLint::Tree::Node}s.
  #
  # @param original_tree [Haml::Parser::ParseNode]
  # @return [Haml::Tree::Node]
  #
  # source://haml_lint//lib/haml_lint/document.rb#125
  def process_tree(original_tree); end

  # Removes YAML frontmatter
  #
  # source://haml_lint//lib/haml_lint/document.rb#168
  def strip_frontmatter(source); end

  # source://haml_lint//lib/haml_lint/document.rb#198
  def unstrip_frontmatter(source); end
end

# File name given to source code parsed from just a string.
#
# source://haml_lint//lib/haml_lint/document.rb#9
HamlLint::Document::STRING_SOURCE = T.let(T.unsafe(nil), String)

# Collection of exceptions that can be raised by the HAML Lint application.
#
# source://haml_lint//lib/haml_lint/exceptions.rb#4
module HamlLint::Exceptions; end

# Raised when a {Configuration} could not be loaded from a file.
#
# source://haml_lint//lib/haml_lint/exceptions.rb#6
class HamlLint::Exceptions::ConfigurationError < ::StandardError; end

# Raised trying to change source with incompatible one (ex: due to frontmatter)
#
# source://haml_lint//lib/haml_lint/exceptions.rb#9
class HamlLint::Exceptions::IncompatibleNewSource < ::StandardError; end

# Raised when linter's autocorrection cause an infinite loop
#
# source://haml_lint//lib/haml_lint/exceptions.rb#12
class HamlLint::Exceptions::InfiniteLoopError < ::StandardError; end

# Raised when invalid/incompatible command line options are provided.
#
# source://haml_lint//lib/haml_lint/exceptions.rb#15
class HamlLint::Exceptions::InvalidCLIOption < ::StandardError; end

# Raised when an invalid file path is specified
#
# source://haml_lint//lib/haml_lint/exceptions.rb#18
class HamlLint::Exceptions::InvalidFilePath < ::StandardError; end

# Raised when attempting to execute `Runner` with options that would result in
# no linters being enabled.
#
# source://haml_lint//lib/haml_lint/exceptions.rb#25
class HamlLint::Exceptions::NoLintersError < ::StandardError; end

# Raised when a problem occurs parsing a HAML document.
#
# source://haml_lint//lib/haml_lint/exceptions.rb#21
class HamlLint::Exceptions::ParseError < ::Haml::SyntaxError; end

# Raised when an unsupported Haml version is detected
#
# source://haml_lint//lib/haml_lint/exceptions.rb#28
class HamlLint::Exceptions::UnknownHamlVersion < ::StandardError; end

# Raised when a severity is not recognized
#
# source://haml_lint//lib/haml_lint/exceptions.rb#31
class HamlLint::Exceptions::UnknownSeverity < ::StandardError; end

# Finds Haml files that should be linted given a specified list of paths, glob
# patterns, and configuration.
#
# source://haml_lint//lib/haml_lint/file_finder.rb#8
class HamlLint::FileFinder
  # Create a file finder using the specified configuration.
  #
  # @param config [HamlLint::Configuration]
  # @return [FileFinder] a new instance of FileFinder
  #
  # source://haml_lint//lib/haml_lint/file_finder.rb#16
  def initialize(config); end

  # Return list of files to lint given the specified set of paths and glob
  # patterns.
  #
  # @param patterns [Array<String>]
  # @param excluded_patterns [Array<String>]
  # @raise [HamlLint::Exceptions::InvalidFilePath]
  # @return [Array<String>] list of actual files
  #
  # source://haml_lint//lib/haml_lint/file_finder.rb#26
  def find(patterns, excluded_patterns); end

  private

  # Extract the list of matching files given the list of glob patterns, file
  # paths, and directories.
  #
  # @param patterns [Array<String>]
  # @return [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/file_finder.rb#43
  def extract_files_from(patterns); end

  # Whether the given file should be treated as a Haml file.
  #
  # @param file [String]
  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/file_finder.rb#84
  def haml_file?(file); end

  # Trim "./" from the front of relative paths.
  #
  # @param path [String]
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/file_finder.rb#76
  def normalize_path(path); end
end

# List of extensions of files to include under a directory when a directory
# is specified instead of a file.
#
# source://haml_lint//lib/haml_lint/file_finder.rb#11
HamlLint::FileFinder::VALID_EXTENSIONS = T.let(T.unsafe(nil), Array)

# source://haml_lint//lib/haml_lint/constants.rb#5
HamlLint::HOME = T.let(T.unsafe(nil), String)

# Provides an interface which when included allows a class to visit nodes in
# the parse tree of a HAML document.
#
# source://haml_lint//lib/haml_lint/haml_visitor.rb#6
module HamlLint::HamlVisitor
  # source://haml_lint//lib/haml_lint/haml_visitor.rb#7
  def visit(node); end

  # source://haml_lint//lib/haml_lint/haml_visitor.rb#31
  def visit_children(parent); end

  private

  # source://haml_lint//lib/haml_lint/haml_visitor.rb#37
  def node_name(node); end

  # source://haml_lint//lib/haml_lint/haml_visitor.rb#41
  def safe_send(name, *args, &block); end
end

# Contains information about a problem or issue with a HAML document.
#
# source://haml_lint//lib/haml_lint/lint.rb#5
class HamlLint::Lint
  # Creates a new lint.
  #
  # @param linter [HamlLint::Linter]
  # @param filename [String]
  # @param line [Fixnum]
  # @param message [String]
  # @param severity [Symbol]
  # @return [Lint] a new instance of Lint
  #
  # source://haml_lint//lib/haml_lint/lint.rb#31
  def initialize(linter, filename, line, message, severity = T.unsafe(nil), corrected: T.unsafe(nil)); end

  # @return [Boolean] If the error was corrected by auto-correct
  #
  # source://haml_lint//lib/haml_lint/lint.rb#7
  def corrected; end

  # Return whether this lint has a severity of error.
  #
  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/lint.rb#43
  def error?; end

  # @return [String] file path to which the lint applies
  #
  # source://haml_lint//lib/haml_lint/lint.rb#10
  def filename; end

  # source://haml_lint//lib/haml_lint/lint.rb#47
  def inspect; end

  # @return [String] line number of the file the lint corresponds to
  #
  # source://haml_lint//lib/haml_lint/lint.rb#13
  def line; end

  # @return [SlimLint::Linter] linter that reported the lint
  #
  # source://haml_lint//lib/haml_lint/lint.rb#16
  def linter; end

  # @return [String] error/warning message to display to user
  #
  # source://haml_lint//lib/haml_lint/lint.rb#19
  def message; end

  # @return [Symbol] whether this lint is a warning or an error
  #
  # source://haml_lint//lib/haml_lint/lint.rb#22
  def severity; end
end

# Base implementation for all lint checks.
#
# @abstract
#
# source://haml_lint//lib/haml_lint/linter.rb#7
class HamlLint::Linter
  include ::HamlLint::HamlVisitor

  # Initializes a linter with the specified configuration.
  #
  # @param config [Hash] configuration for this linter
  # @return [Linter] a new instance of Linter
  #
  # source://haml_lint//lib/haml_lint/linter.rb#19
  def initialize(config); end

  # List of lints reported by this linter.
  #
  # @todo Remove once spec/support/shared_linter_context returns an array of
  #   lints for the subject instead of the linter itself.
  #
  # source://haml_lint//lib/haml_lint/linter.rb#14
  def lints; end

  # Returns the simple name for this linter.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#73
  def name; end

  # Runs the linter against the given Haml document.
  #
  # @param document [HamlLint::Document]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#27
  def run(document, autocorrect: T.unsafe(nil)); end

  # Runs the linter against the given Haml document, raises if the file cannot be processed due to
  # Syntax or HAML-Lint internal errors. (For testing purposes)
  #
  # @param document [HamlLint::Document]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#62
  def run_or_raise(document, autocorrect: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#84
  def supports_autocorrect?; end

  private

  # Returns the value of attribute config.
  #
  # source://haml_lint//lib/haml_lint/linter.rb#90
  def config; end

  # Returns whether a string contains any interpolation.
  #
  # @param string [String]
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#135
  def contains_interpolation?(string); end

  # Returns the value of attribute document.
  #
  # source://haml_lint//lib/haml_lint/linter.rb#90
  def document; end

  # Returns the line of the "following node" (child of this node or sibling or
  # the last line in the file).
  #
  # @param node [HamlLint::Tree::Node]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#217
  def following_node_line(node); end

  # Returns whether the inline content for a node is a string.
  #
  # For example, the following node has a literal string:
  #
  #   %tag= "A literal #{string}"
  #
  # whereas this one does not:
  #
  #   %tag A literal #{string}
  #
  # @param node [HamlLint::Tree::Node]
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#168
  def inline_content_is_string?(node); end

  # Get the inline content for this node.
  #
  # Inline content is the content that appears inline right after the
  # tag/script. For example, in the code below...
  #
  #   %tag Some inline content
  #
  # ..."Some inline content" would be the inline content.
  #
  # @param node [HamlLint::Tree::Node]
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#188
  def inline_node_content(node); end

  # Gets the next node following this node, ascending up the ancestor chain
  # recursively if this node has no siblings.
  #
  # @param node [HamlLint::Tree::Node]
  # @return [HamlLint::Tree::Node, nil]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#203
  def next_node(node); end

  # Parse Ruby code into an abstract syntax tree.
  #
  # @return [AST::Node]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#114
  def parse_ruby(source); end

  # Record a lint for reporting back to the user.
  #
  # @param node_or_line [#line] line number or node to extract the line number from
  # @param message [String] error/warning to display to the user
  #
  # source://haml_lint//lib/haml_lint/linter.rb#104
  def record_lint(node_or_line, message, corrected: T.unsafe(nil)); end

  # Remove the surrounding double quotes from a string, ignoring any
  # leading/trailing whitespace.
  #
  # @param string [String]
  # @return [String] stripped with leading/trailing double quotes removed.
  #
  # source://haml_lint//lib/haml_lint/linter.rb#127
  def strip_surrounding_quotes(string); end

  # Returns whether this tag node has inline script, e.g. is of the form
  # %tag= ...
  #
  # @param tag_node [HamlLint::Tree::TagNode]
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#145
  def tag_has_inline_script?(tag_node); end

  # Extracts all text for a tag node and normalizes it, including additional
  # lines following commas or multiline bar indicators ('|')
  #
  # @param tag_node [HamlLine::Tree::TagNode]
  # @return [String] source code of original parse node
  #
  # source://haml_lint//lib/haml_lint/linter.rb#229
  def tag_with_inline_text(tag_node); end

  class << self
    # source://haml_lint//lib/haml_lint/linter.rb#118
    def ruby_parser; end

    # Returns true if this linter supports autocorrect, false otherwise
    #
    # @return [Boolean]
    #
    # source://haml_lint//lib/haml_lint/linter.rb#80
    def supports_autocorrect?; end

    private

    # Linters can call supports_autocorrect(true) in their top-level scope to indicate that
    # they supports autocorrect.
    #
    # source://haml_lint//lib/haml_lint/linter.rb#96
    def supports_autocorrect(value); end
  end
end

# source://haml_lint//lib/haml_lint/linter/alignment_tabs.rb#5
class HamlLint::Linter::AlignmentTabs < ::HamlLint::Linter
  # source://haml_lint//lib/haml_lint/linter/alignment_tabs.rb#8
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/alignment_tabs.rb#6
HamlLint::Linter::AlignmentTabs::REGEX = T.let(T.unsafe(nil), Regexp)

# source://haml_lint//lib/haml_lint/linter/alt_text.rb#5
class HamlLint::Linter::AltText < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/alt_text.rb#8
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/class_attribute_with_static_value.rb#18
class HamlLint::Linter::ClassAttributeWithStaticValue < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/class_attribute_with_static_value.rb#25
  def visit_tag(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/class_attribute_with_static_value.rb#38
  def contains_class_attribute?(attributes_sources); end

  # source://haml_lint//lib/haml_lint/linter/class_attribute_with_static_value.rb#51
  def static_class_attribute_value?(pair); end

  # source://haml_lint//lib/haml_lint/linter/class_attribute_with_static_value.rb#34
  def surrounded_by_braces?(code); end
end

# source://haml_lint//lib/haml_lint/linter/class_attribute_with_static_value.rb#21
HamlLint::Linter::ClassAttributeWithStaticValue::STATIC_TYPES = T.let(T.unsafe(nil), Array)

# source://haml_lint//lib/haml_lint/linter/class_attribute_with_static_value.rb#23
HamlLint::Linter::ClassAttributeWithStaticValue::VALID_CLASS_REGEX = T.let(T.unsafe(nil), Regexp)

# source://haml_lint//lib/haml_lint/linter/classes_before_ids.rb#5
class HamlLint::Linter::ClassesBeforeIds < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/classes_before_ids.rb#16
  def visit_tag(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/classes_before_ids.rb#34
  def attribute_prefix_order; end

  # source://haml_lint//lib/haml_lint/linter/classes_before_ids.rb#40
  def attribute_type_order; end

  # source://haml_lint//lib/haml_lint/linter/classes_before_ids.rb#46
  def enforced_style; end

  # source://haml_lint//lib/haml_lint/linter/classes_before_ids.rb#50
  def ids_first?; end
end

# source://haml_lint//lib/haml_lint/linter/classes_before_ids.rb#14
HamlLint::Linter::ClassesBeforeIds::MSG = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/linter/classes_before_ids.rb#9
HamlLint::Linter::ClassesBeforeIds::TYPES_BY_PREFIX = T.let(T.unsafe(nil), Hash)

# source://haml_lint//lib/haml_lint/linter/consecutive_comments.rb#5
class HamlLint::Linter::ConsecutiveComments < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/consecutive_comments.rb#10
  def visit_haml_comment(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/consecutive_comments.rb#26
  def possible_group(node); end

  # source://haml_lint//lib/haml_lint/linter/consecutive_comments.rb#30
  def previously_reported?(node); end

  # source://haml_lint//lib/haml_lint/linter/consecutive_comments.rb#34
  def reported_nodes; end
end

# source://haml_lint//lib/haml_lint/linter/consecutive_comments.rb#8
HamlLint::Linter::ConsecutiveComments::COMMENT_DETECTOR = T.let(T.unsafe(nil), Proc)

# source://haml_lint//lib/haml_lint/linter/consecutive_silent_scripts.rb#6
class HamlLint::Linter::ConsecutiveSilentScripts < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/consecutive_silent_scripts.rb#13
  def visit_silent_script(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/consecutive_silent_scripts.rb#29
  def possible_group(node); end

  # source://haml_lint//lib/haml_lint/linter/consecutive_silent_scripts.rb#33
  def previously_reported?(node); end

  # source://haml_lint//lib/haml_lint/linter/consecutive_silent_scripts.rb#37
  def reported_nodes; end
end

# source://haml_lint//lib/haml_lint/linter/consecutive_silent_scripts.rb#9
HamlLint::Linter::ConsecutiveSilentScripts::SILENT_SCRIPT_DETECTOR = T.let(T.unsafe(nil), Proc)

# source://haml_lint//lib/haml_lint/linter/empty_object_reference.rb#5
class HamlLint::Linter::EmptyObjectReference < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/empty_object_reference.rb#8
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/empty_script.rb#5
class HamlLint::Linter::EmptyScript < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/empty_script.rb#8
  def visit_silent_script(node); end
end

# source://haml_lint//lib/haml_lint/linter/final_newline.rb#5
class HamlLint::Linter::FinalNewline < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/final_newline.rb#8
  def visit_root(root); end
end

# source://haml_lint//lib/haml_lint/linter/html_attributes.rb#6
class HamlLint::Linter::HtmlAttributes < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/html_attributes.rb#9
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/id_names.rb#5
class HamlLint::Linter::IdNames < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/id_names.rb#22
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/id_names.rb#15
HamlLint::Linter::IdNames::STYLES = T.let(T.unsafe(nil), Hash)

# source://haml_lint//lib/haml_lint/linter/id_names.rb#8
HamlLint::Linter::IdNames::STYLIZED_NAMES = T.let(T.unsafe(nil), Hash)

# source://haml_lint//lib/haml_lint/linter/implicit_div.rb#6
class HamlLint::Linter::ImplicitDiv < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/implicit_div.rb#9
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/indentation.rb#5
class HamlLint::Linter::Indentation < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/indentation.rb#16
  def visit_root(root); end

  private

  # source://haml_lint//lib/haml_lint/linter/indentation.rb#27
  def check_character(character, root); end

  # source://haml_lint//lib/haml_lint/linter/indentation.rb#42
  def check_width(width, root); end
end

# source://haml_lint//lib/haml_lint/linter/indentation.rb#9
HamlLint::Linter::Indentation::INDENT_REGEX = T.let(T.unsafe(nil), Hash)

# source://haml_lint//lib/haml_lint/linter/indentation.rb#14
HamlLint::Linter::Indentation::LEADING_SPACES_REGEX = T.let(T.unsafe(nil), Regexp)

# source://haml_lint//lib/haml_lint/linter/inline_styles.rb#5
class HamlLint::Linter::InlineStyles < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/inline_styles.rb#10
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/inline_styles.rb#8
HamlLint::Linter::InlineStyles::MESSAGE = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/linter/instance_variables.rb#5
class HamlLint::Linter::InstanceVariables < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/instance_variables.rb#12
  def visit_root(node); end

  # source://haml_lint//lib/haml_lint/linter/instance_variables.rb#20
  def visit_script(node); end

  # source://haml_lint//lib/haml_lint/linter/instance_variables.rb#20
  def visit_silent_script(node); end

  # source://haml_lint//lib/haml_lint/linter/instance_variables.rb#39
  def visit_tag(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/instance_variables.rb#54
  def enabled; end

  # source://haml_lint//lib/haml_lint/linter/instance_variables.rb#54
  def enabled?; end

  # source://haml_lint//lib/haml_lint/linter/instance_variables.rb#67
  def file_types; end

  # source://haml_lint//lib/haml_lint/linter/instance_variables.rb#75
  def matcher; end
end

# source://haml_lint//lib/haml_lint/linter/leading_comment_space.rb#5
class HamlLint::Linter::LeadingCommentSpace < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/leading_comment_space.rb#8
  def visit_haml_comment(node); end
end

# source://haml_lint//lib/haml_lint/linter/line_length.rb#5
class HamlLint::Linter::LineLength < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/line_length.rb#15
  def visit_root(root); end
end

# source://haml_lint//lib/haml_lint/linter/line_length.rb#11
class HamlLint::Linter::LineLength::DummyNode < ::Struct
  def line; end
  def line=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://haml_lint//lib/haml_lint/linter/line_length.rb#13
HamlLint::Linter::LineLength::MSG = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/linter/multiline_pipe.rb#5
class HamlLint::Linter::MultilinePipe < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/multiline_pipe.rb#23
  def visit_plain(node); end

  # source://haml_lint//lib/haml_lint/linter/multiline_pipe.rb#15
  def visit_script(node); end

  # source://haml_lint//lib/haml_lint/linter/multiline_pipe.rb#19
  def visit_silent_script(node); end

  # source://haml_lint//lib/haml_lint/linter/multiline_pipe.rb#11
  def visit_tag(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/multiline_pipe.rb#40
  def check(node); end

  # source://haml_lint//lib/haml_lint/linter/multiline_pipe.rb#36
  def line_text_for_node(node); end
end

# source://haml_lint//lib/haml_lint/linter/multiline_pipe.rb#8
HamlLint::Linter::MultilinePipe::MESSAGE = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/linter/multiline_pipe.rb#34
HamlLint::Linter::MultilinePipe::MULTILINE_PIPE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://haml_lint//lib/haml_lint/linter/multiline_script.rb#5
class HamlLint::Linter::MultilineScript < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/multiline_script.rb#26
  def visit_script(node); end

  # source://haml_lint//lib/haml_lint/linter/multiline_script.rb#30
  def visit_silent_script(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/multiline_script.rb#36
  def check(node); end
end

# source://haml_lint//lib/haml_lint/linter/multiline_script.rb#10
HamlLint::Linter::MultilineScript::SPLIT_OPERATORS = T.let(T.unsafe(nil), Set)

# source://haml_lint//lib/haml_lint/linter/no_placeholders.rb#5
class HamlLint::Linter::NoPlaceholders < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/no_placeholders.rb#12
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/no_placeholders.rb#9
HamlLint::Linter::NoPlaceholders::HASH_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://haml_lint//lib/haml_lint/linter/no_placeholders.rb#10
HamlLint::Linter::NoPlaceholders::HTML_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://haml_lint//lib/haml_lint/linter/no_placeholders.rb#8
HamlLint::Linter::NoPlaceholders::MSG = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/linter/object_reference_attributes.rb#6
class HamlLint::Linter::ObjectReferenceAttributes < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/object_reference_attributes.rb#9
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/repeated_id.rb#5
class HamlLint::Linter::RepeatedId < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/repeated_id.rb#10
  def visit_root(_node); end

  # source://haml_lint//lib/haml_lint/linter/repeated_id.rb#14
  def visit_tag(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/repeated_id.rb#31
  def add_lint(node, id); end

  # source://haml_lint//lib/haml_lint/linter/repeated_id.rb#35
  def add_lints_for_first_duplications(nodes); end

  # source://haml_lint//lib/haml_lint/linter/repeated_id.rb#29
  def id_map; end
end

# source://haml_lint//lib/haml_lint/linter/repeated_id.rb#8
HamlLint::Linter::RepeatedId::MESSAGE_FORMAT = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/linter/rubocop.rb#18
class HamlLint::Linter::RuboCop < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#34
  def last_extracted_source; end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#34
  def last_extracted_source=(_arg0); end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#35
  def last_new_ruby_source; end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#35
  def last_new_ruby_source=(_arg0); end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#37
  def visit_root(_node); end

  private

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#258
  def extract_lints_from_offenses(offenses, source_map); end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#335
  def ignored_cops_flags; end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#140
  def new_haml_validity_checks(new_haml_string); end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#190
  def process_ruby_source(ruby_code, source_map); end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#288
  def record_lint(line, message, severity, corrected:); end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#307
  def rubocop_autocorrect_flags; end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#99
  def rubocop_config_for(path); end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#300
  def rubocop_flags; end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#206
  def run_rubocop(rubocop_cli, ruby_code, path); end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#111
  def transfer_corrections(coordinator, new_ruby_code); end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#107
  def transfer_corrections?(initial_ruby_code, new_ruby_code); end

  class << self
    # source://haml_lint//lib/haml_lint/linter/rubocop.rb#87
    def cops_names_not_supporting_autocorrect; end

    # source://haml_lint//lib/haml_lint/linter/rubocop.rb#173
    def rubocop_cli; end

    # source://haml_lint//lib/haml_lint/linter/rubocop.rb#179
    def rubocop_config_store; end
  end
end

# source://haml_lint//lib/haml_lint/linter/rubocop.rb#24
HamlLint::Linter::RuboCop::SEVERITY_MAP = T.let(T.unsafe(nil), Hash)

# source://haml_lint//lib/haml_lint/linter/ruby_comments.rb#5
class HamlLint::Linter::RubyComments < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/ruby_comments.rb#8
  def visit_silent_script(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/ruby_comments.rb#16
  def code_comment?(node); end
end

# source://haml_lint//lib/haml_lint/linter/space_before_script.rb#5
class HamlLint::Linter::SpaceBeforeScript < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/space_before_script.rb#39
  def visit_script(node); end

  # source://haml_lint//lib/haml_lint/linter/space_before_script.rb#46
  def visit_silent_script(node); end

  # source://haml_lint//lib/haml_lint/linter/space_before_script.rb#12
  def visit_tag(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/space_before_script.rb#52
  def missing_space?(node); end
end

# source://haml_lint//lib/haml_lint/linter/space_before_script.rb#10
HamlLint::Linter::SpaceBeforeScript::ALLOWED_SEPARATORS = T.let(T.unsafe(nil), Array)

# source://haml_lint//lib/haml_lint/linter/space_before_script.rb#8
HamlLint::Linter::SpaceBeforeScript::MESSAGE_FORMAT = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/linter/space_inside_hash_attributes.rb#6
class HamlLint::Linter::SpaceInsideHashAttributes < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/space_inside_hash_attributes.rb#24
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/space_inside_hash_attributes.rb#9
HamlLint::Linter::SpaceInsideHashAttributes::STYLE = T.let(T.unsafe(nil), Hash)

# source://haml_lint//lib/haml_lint/linter/syntax.rb#5
class HamlLint::Linter::Syntax < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry
end

# source://haml_lint//lib/haml_lint/linter/tag_name.rb#5
class HamlLint::Linter::TagName < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/tag_name.rb#8
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/trailing_empty_lines.rb#5
class HamlLint::Linter::TrailingEmptyLines < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/trailing_empty_lines.rb#10
  def visit_root(root); end
end

# source://haml_lint//lib/haml_lint/linter/trailing_empty_lines.rb#8
class HamlLint::Linter::TrailingEmptyLines::DummyNode < ::Struct
  def line; end
  def line=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://haml_lint//lib/haml_lint/linter/trailing_whitespace.rb#5
class HamlLint::Linter::TrailingWhitespace < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/trailing_whitespace.rb#10
  def visit_root(root); end
end

# source://haml_lint//lib/haml_lint/linter/trailing_whitespace.rb#8
class HamlLint::Linter::TrailingWhitespace::DummyNode < ::Struct
  def line; end
  def line=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://haml_lint//lib/haml_lint/linter/unnecessary_interpolation.rb#11
class HamlLint::Linter::UnnecessaryInterpolation < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/unnecessary_interpolation.rb#14
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/unnecessary_string_output.rb#11
class HamlLint::Linter::UnnecessaryStringOutput < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/unnecessary_string_output.rb#22
  def visit_script(node); end

  # source://haml_lint//lib/haml_lint/linter/unnecessary_string_output.rb#16
  def visit_tag(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/unnecessary_string_output.rb#34
  def outputs_string_literal?(script_node); end

  # source://haml_lint//lib/haml_lint/linter/unnecessary_string_output.rb#44
  def starts_with_reserved_character?(stringish); end
end

# source://haml_lint//lib/haml_lint/linter/unnecessary_string_output.rb#14
HamlLint::Linter::UnnecessaryStringOutput::MESSAGE = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/linter/view_length.rb#5
class HamlLint::Linter::ViewLength < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/view_length.rb#12
  def visit_root(root); end
end

# source://haml_lint//lib/haml_lint/linter/view_length.rb#10
class HamlLint::Linter::ViewLength::DummyNode < ::Struct
  def line; end
  def line=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://haml_lint//lib/haml_lint/linter/view_length.rb#8
HamlLint::Linter::ViewLength::MSG = T.let(T.unsafe(nil), String)

# Stores all defined linters.
#
# source://haml_lint//lib/haml_lint/linter_registry.rb#7
module HamlLint::LinterRegistry
  class << self
    # Return a list of {HamlLint::Linter} {Class}es corresponding to the
    # specified list of names.
    #
    # @param linter_names [Array<String>]
    # @return [Array<Class>]
    #
    # source://haml_lint//lib/haml_lint/linter_registry.rb#28
    def extract_linters_from(linter_names); end

    # Executed when a linter includes the {LinterRegistry} module.
    #
    # This results in the linter being registered with the registry.
    #
    # @param subclass [Class]
    #
    # source://haml_lint//lib/haml_lint/linter_registry.rb#19
    def included(subclass); end

    # List of all registered linters.
    #
    # source://haml_lint//lib/haml_lint/linter_registry.rb#12
    def linters; end
  end
end

# Chooses the appropriate linters to run given the specified configuration.
#
# source://haml_lint//lib/haml_lint/linter_selector.rb#5
class HamlLint::LinterSelector
  # Creates a selector using the given configuration and additional options.
  #
  # @param config [HamlLint::Configuration]
  # @param options [Hash]
  # @return [LinterSelector] a new instance of LinterSelector
  #
  # source://haml_lint//lib/haml_lint/linter_selector.rb#10
  def initialize(config, options); end

  # Returns the set of linters to run against the given file.
  #
  # @param file [String]
  # @raise [HamlLint::Exceptions::NoLintersError] when no linters are enabled
  # @return [Array<HamlLint::Linter>]
  #
  # source://haml_lint//lib/haml_lint/linter_selector.rb#20
  def linters_for_file(file); end

  private

  # Returns a list of linters that are enabled given the specified
  # configuration and additional options.
  #
  # @param config [HamlLint::Configuration]
  # @param options [Hash]
  # @return [Array<HamlLint::Linter>]
  #
  # source://haml_lint//lib/haml_lint/linter_selector.rb#33
  def extract_enabled_linters(config, options); end

  # Whether to run the given linter against the specified file.
  #
  # @param config [HamlLint::Configuration]
  # @param linter [HamlLint::Linter]
  # @param file [String]
  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/linter_selector.rb#64
  def run_linter_on_file?(config, linter, file); end
end

# Encapsulates all communication to an output source.
#
# source://haml_lint//lib/haml_lint/logger.rb#5
class HamlLint::Logger
  # Creates a new {HamlLint::Logger} instance.
  #
  # @param out [IO] the output destination.
  # @param summary [true, false] whether to print summaries
  # @return [Logger] a new instance of Logger
  #
  # source://haml_lint//lib/haml_lint/logger.rb#24
  def initialize(out, summary: T.unsafe(nil)); end

  # Print the specified output in bold face.
  # If output destination is not a TTY, behaves the same as {#log}.
  #
  # @param args [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#42
  def bold(*args); end

  # Print the specified output in a bold face and color indicative of error.
  # If output destination is not a TTY, behaves the same as {#log}.
  #
  # @param args [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#58
  def bold_error(*args); end

  # Whether colored output via ANSI escape sequences is enabled.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#8
  def color_enabled; end

  # Whether colored output via ANSI escape sequences is enabled.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#8
  def color_enabled=(_arg0); end

  # Print the specified output in a color indicative of error.
  # If output destination is not a TTY, behaves the same as {#log}.
  #
  # @param args [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#50
  def error(*args); end

  # Print the specified output in a color indicating information.
  # If output destination is not a TTY, behaves the same as {#log}.
  #
  # @param args [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#82
  def info(*args); end

  # Print the specified output.
  #
  # @param output [String] the output to send
  # @param newline [true, false] whether to append a newline
  #
  # source://haml_lint//lib/haml_lint/logger.rb#33
  def log(output, newline = T.unsafe(nil)); end

  # Print a blank line.
  #
  # source://haml_lint//lib/haml_lint/logger.rb#87
  def newline; end

  # Print the specified output in a color indicative of success.
  # If output destination is not a TTY, behaves the same as {#log}.
  #
  # @param args [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#66
  def success(*args); end

  # Whether to output a summary in the log for certain reporters.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#12
  def summary_enabled; end

  # Whether to output a summary in the log for certain reporters.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#12
  def summary_enabled=(_arg0); end

  # Whether this logger is outputting to a TTY.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#94
  def tty?; end

  # Print the specified output in a color indicative of a warning.
  # If output destination is not a TTY, behaves the same as {#log}.
  #
  # @param args [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#74
  def warning(*args); end

  private

  # source://haml_lint//lib/haml_lint/logger.rb#100
  def color(code, output, newline = T.unsafe(nil)); end

  class << self
    # Creates a logger which outputs nothing.
    #
    # @return [HamlLint::Logger]
    #
    # source://haml_lint//lib/haml_lint/logger.rb#16
    def silent; end
  end
end

# source://haml_lint//lib/haml_lint/linter_registry.rb#4
class HamlLint::NoSuchLinter < ::StandardError; end

# Responsible for transforming {Haml::Parser::ParseNode} objects into
# corresponding {HamlLint::Tree::Node} objects.
#
# The parse tree generated by HAML has a number of strange cases where certain
# types of nodes are created that don't necessarily correspond to what one
# would expect. This class is intended to isolate and handle these cases so
# that linters don't have to deal with them.
#
# source://haml_lint//lib/haml_lint/node_transformer.rb#11
class HamlLint::NodeTransformer
  # Creates a node transformer for the given Haml document.
  #
  # @param document [HamlLint::Document]
  # @return [NodeTransformer] a new instance of NodeTransformer
  #
  # source://haml_lint//lib/haml_lint/node_transformer.rb#15
  def initialize(document); end

  # Converts the given HAML parse node into its corresponding HAML-Lint parse
  # node.
  #
  # @param haml_node [Haml::Parser::ParseNode]
  # @return [HamlLint::Tree::Node]
  #
  # source://haml_lint//lib/haml_lint/node_transformer.rb#24
  def transform(haml_node); end
end

# Collects offenses detected by RuboCop.
#
# source://haml_lint//lib/haml_lint/linter/rubocop.rb#348
class HamlLint::OffenseCollector < ::RuboCop::Formatter::BaseFormatter
  # Executed when a file has been scanned by RuboCop, adding the reported
  # offenses to our collection.
  #
  # @param _file [String]
  # @param offenses [Array<RuboCop::Cop::Offense>]
  #
  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#366
  def file_finished(_file, offenses); end

  # Executed when RuboCop begins linting.
  #
  # @param _target_files [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#357
  def started(_target_files); end

  class << self
    # List of offenses reported by RuboCop.
    #
    # source://haml_lint//lib/haml_lint/linter/rubocop.rb#351
    def offenses; end

    # List of offenses reported by RuboCop.
    #
    # source://haml_lint//lib/haml_lint/linter/rubocop.rb#351
    def offenses=(_arg0); end
  end
end

# A thin wrapper around the syntax tree from the Parser gem.
#
# source://haml_lint//lib/haml_lint/parsed_ruby.rb#12
class HamlLint::ParsedRuby < ::SimpleDelegator
  # Checks whether the syntax tree contains any instance variables.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/parsed_ruby.rb#18
  def contains_instance_variables?; end

  # !@method syntax_tree
  #   Returns the bare syntax tree from the wrapper.
  #
  #   @api semipublic
  #   @return [Array] syntax tree in the form returned by Parser gem
  #
  # source://delegate/0.2.0/delegate.rb#318
  def syntax_tree; end
end

# source://haml_lint//lib/haml_lint/constants.rb#8
HamlLint::REPO_URL = T.let(T.unsafe(nil), String)

# Contains information about all lints detected during a scan.
#
# source://haml_lint//lib/haml_lint/report.rb#5
class HamlLint::Report
  # Creates a report.
  #
  # @param lints [Array<HamlLint::Lint>] lints that were found
  # @param files [Array<String>] files that were linted
  # @param fail_level [Symbol] the severity level to fail on
  # @param reporter [HamlLint::Reporter] the reporter for the report
  # @return [Report] a new instance of Report
  #
  # source://haml_lint//lib/haml_lint/report.rb#21
  def initialize(lints: T.unsafe(nil), files: T.unsafe(nil), fail_level: T.unsafe(nil), reporter: T.unsafe(nil)); end

  # Adds a lint to the report and notifies the reporter.
  #
  # @param lint [HamlLint::Lint] lint to add
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/report.rb#32
  def add_lint(lint); end

  # Displays the report via the configured reporter.
  #
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/report.rb#40
  def display; end

  # The level of lint to fail after detecting
  #
  # source://haml_lint//lib/haml_lint/report.rb#10
  def fail_level; end

  # Checks whether any lints were at or above the fail level
  #
  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/report.rb#47
  def failed?; end

  # List of files that were linted.
  #
  # source://haml_lint//lib/haml_lint/report.rb#13
  def files; end

  # Adds a file to the list of linted files and notifies the reporter.
  #
  # @param file [String] the name of the file that was finished
  # @param lints [Array<HamlLint::Lint>] the lints for the finished file
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/report.rb#56
  def finish_file(file, lints); end

  # List of lints that were found.
  #
  # source://haml_lint//lib/haml_lint/report.rb#7
  def lints; end

  # List of lints that were found.
  #
  # source://haml_lint//lib/haml_lint/report.rb#7
  def lints=(_arg0); end

  # Notifies the reporter that the report has started.
  #
  # @param files [Array<String>] the files to lint
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/report.rb#65
  def start(files); end
end

# Abstract lint reporter. Subclass and override {#display_report} to
# implement a custom lint reporter.
#
# @abstract
#
# source://haml_lint//lib/haml_lint/reporter/hooks.rb#4
class HamlLint::Reporter
  include ::HamlLint::Reporter::Hooks

  # Creates the reporter that will display the given report.
  #
  # @param logger [HamlLint::Logger]
  # @return [Reporter] a new instance of Reporter
  #
  # source://haml_lint//lib/haml_lint/reporter.rb#47
  def initialize(logger); end

  # Implemented by subclasses to display lints from a {HamlLint::Report}.
  #
  # @param report [HamlLint::Report]
  # @raise [NotImplementedError]
  #
  # source://haml_lint//lib/haml_lint/reporter.rb#54
  def display_report(report); end

  private

  # @return [HamlLint::Logger] logger to send output to
  #
  # source://haml_lint//lib/haml_lint/reporter.rb#77
  def log; end

  class << self
    # The CLI names of all configured reporters.
    #
    # @return [Array<String>]
    #
    # source://haml_lint//lib/haml_lint/reporter.rb#16
    def available; end

    # A flag for whether to show the reporter on the command line.
    #
    # @return [Boolean]
    #
    # source://haml_lint//lib/haml_lint/reporter.rb#27
    def available?; end

    # The name of the reporter as passed from the CLI.
    #
    # @return [String]
    #
    # source://haml_lint//lib/haml_lint/reporter.rb#34
    def cli_name; end

    # Keep tracking all the descendants of this class for the list of available
    # reporters.
    #
    # @return [Array<Class>]
    #
    # source://haml_lint//lib/haml_lint/reporter.rb#63
    def descendants; end

    # Executed when this class is subclassed.
    #
    # @param descendant [Class]
    #
    # source://haml_lint//lib/haml_lint/reporter.rb#70
    def inherited(descendant); end
  end
end

# source://haml_lint//lib/haml_lint/reporter/checkstyle_reporter.rb#5
class HamlLint::Reporter::CheckstyleReporter < ::HamlLint::Reporter
  # source://haml_lint//lib/haml_lint/reporter/checkstyle_reporter.rb#6
  def display_report(report); end

  private

  # source://haml_lint//lib/haml_lint/reporter/checkstyle_reporter.rb#26
  def render_offenses(offenses); end
end

# source://haml_lint//lib/haml_lint/reporter/default_reporter.rb#8
class HamlLint::Reporter::DefaultReporter < ::HamlLint::Reporter
  include ::HamlLint::Reporter::Utils

  # source://haml_lint//lib/haml_lint/reporter/default_reporter.rb#11
  def added_lint(lint, report); end

  # source://haml_lint//lib/haml_lint/reporter/default_reporter.rb#15
  def display_report(report); end
end

# source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#7
class HamlLint::Reporter::DisabledConfigReporter < ::HamlLint::Reporter::ProgressReporter
  # source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#28
  def initialize(log, limit: T.unsafe(nil)); end

  # source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#56
  def display_report(report); end

  # source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#50
  def exclude_limit; end

  # source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#71
  def finished_file(file, lints); end

  # source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#39
  def linters_lint_count; end

  # source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#45
  def linters_with_lints; end

  private

  # source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#87
  def config_file_contents; end

  # source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#102
  def generate_config_for_linter(linter, files); end

  class << self
    # source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#21
    def available?; end
  end
end

# source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#8
HamlLint::Reporter::DisabledConfigReporter::HEADING = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/reporter/hash_reporter.rb#8
class HamlLint::Reporter::HashReporter < ::HamlLint::Reporter
  # source://haml_lint//lib/haml_lint/reporter/hash_reporter.rb#13
  def display_report(report); end

  private

  # source://haml_lint//lib/haml_lint/reporter/hash_reporter.rb#39
  def map_file(file); end

  # source://haml_lint//lib/haml_lint/reporter/hash_reporter.rb#46
  def map_offense(offense); end

  # source://haml_lint//lib/haml_lint/reporter/hash_reporter.rb#30
  def metadata; end

  class << self
    # source://haml_lint//lib/haml_lint/reporter/hash_reporter.rb#9
    def available?; end
  end
end

# A collection of hook methods for incremental processing.
#
# source://haml_lint//lib/haml_lint/reporter/hooks.rb#6
module HamlLint::Reporter::Hooks
  # A hook that is called for each lint as it is detected.
  #
  # @param _lint [HamlLint::Lint] the lint added to the report
  # @param _report [HamlLint::Report] the report that contains the lint
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/hooks.rb#12
  def added_lint(_lint, _report); end

  # A hook that is called for each file as it is finished processing.
  #
  # @param _file [String] the name of the file that just finished
  # @param _lints [Array<HamlLint::Lint>] the lints added to the report
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/hooks.rb#19
  def finished_file(_file, _lints); end

  # A hook that is called when the processing starts.
  #
  # @param _files [Array<String>] the names of the files to be processed
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/hooks.rb#25
  def start(_files); end
end

# Outputs report as a JSON document.
#
# source://haml_lint//lib/haml_lint/reporter/json_reporter.rb#10
class HamlLint::Reporter::JsonReporter < ::HamlLint::Reporter::HashReporter
  # source://haml_lint//lib/haml_lint/reporter/json_reporter.rb#15
  def display_report(report); end

  class << self
    # Ensures that the CLI is able to use the the reporter.
    #
    # @return [true]
    #
    # source://haml_lint//lib/haml_lint/reporter/json_reporter.rb#11
    def available?; end
  end
end

# Outputs the a list of lints with a count of how many of each were found.
# Ordered by descending count
#
# source://haml_lint//lib/haml_lint/reporter/offense_count_reporter.rb#6
class HamlLint::Reporter::OffenseCountReporter < ::HamlLint::Reporter
  # source://haml_lint//lib/haml_lint/reporter/offense_count_reporter.rb#7
  def display_report(report); end

  private

  # source://haml_lint//lib/haml_lint/reporter/offense_count_reporter.rb#25
  def lint_type_group(lint); end

  # source://haml_lint//lib/haml_lint/reporter/offense_count_reporter.rb#29
  def offense_type(lint); end
end

# Outputs files as they are output as a simple symbol, then outputs
# a summary of each lint.
#
# source://haml_lint//lib/haml_lint/reporter/progress_reporter.rb#9
class HamlLint::Reporter::ProgressReporter < ::HamlLint::Reporter
  include ::HamlLint::Reporter::Utils

  # source://haml_lint//lib/haml_lint/reporter/progress_reporter.rb#14
  def display_report(report); end

  # source://haml_lint//lib/haml_lint/reporter/progress_reporter.rb#23
  def finished_file(_file, lints); end

  # source://haml_lint//lib/haml_lint/reporter/progress_reporter.rb#27
  def start(files); end

  private

  # source://haml_lint//lib/haml_lint/reporter/progress_reporter.rb#33
  def dot; end

  # source://haml_lint//lib/haml_lint/reporter/progress_reporter.rb#37
  def report_file_as_mark(lints); end
end

# source://haml_lint//lib/haml_lint/reporter/progress_reporter.rb#12
HamlLint::Reporter::ProgressReporter::DOT = T.let(T.unsafe(nil), String)

# Formatting helpers for printing the default report format.
#
# source://haml_lint//lib/haml_lint/reporter/utils.rb#6
module HamlLint::Reporter::Utils
  # Pluralizes a word based on a count.
  #
  # @param word [String] the word to pluralize
  # @param count [Integer] the count of items
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/reporter/utils.rb#12
  def pluralize(word, count: T.unsafe(nil)); end

  # Prints the lint with its location and severity.
  #
  # @param lint [HamlLint::Lint] the lint to print
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/utils.rb#24
  def print_lint(lint); end

  # Prints the location of a lint.
  #
  # @param lint [HamlLint::Lint] the lint to print
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/utils.rb#34
  def print_location(lint); end

  # Prints the description of a lint.
  #
  # @param lint [HamlLint::Lint] the lint to print
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/utils.rb#58
  def print_message(lint); end

  # Prints a summary of a report when summaries are enabled.
  #
  # @param report [HamlLint::Report] the report to print
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/utils.rb#74
  def print_summary(report); end

  # Prints a summary of the number of lints corrected in a report.
  #
  # @param report [HamlLint::Report] the report to print
  # @param is_append [Boolean] if this is appending to a line. Will preffix with ", ".
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/utils.rb#119
  def print_summary_corrected_lints(report, is_append:); end

  # Prints a summary of the number of files linted in a report.
  #
  # @param report [HamlLint::Report] the report to print
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/utils.rb#92
  def print_summary_files(report); end

  # Prints a summary of the number of lints found in a report.
  #
  # @param report [HamlLint::Report] the report to print
  # @param is_append [Boolean] if this is appending to a line. Will preffix with ", ".
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/utils.rb#101
  def print_summary_lints(report, is_append:); end

  # Prints the severity of a lint.
  #
  # @param lint [HamlLint::Lint] the lint to print
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/utils.rb#44
  def print_type(lint); end
end

# To handle our need to force some configurations on RuboCop, while still allowing users
# to customize most of RuboCop using their own rubocop.yml config(s), we need to detect
# the effective RuboCop configuration for a specific file, and generate a new configuration
# containing our own "forced configuration" with a `inherit_from` that points on the
# user's configuration.
#
# This class handles all of this logic.
#
# source://haml_lint//lib/haml_lint/linter/rubocop.rb#378
class HamlLint::RubocopConfigStore
  # @return [RubocopConfigStore] a new instance of RubocopConfigStore
  #
  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#379
  def initialize; end

  # Build a RuboCop::Config from config/forced_rubocop_config.yml which inherits from the given
  # user_config_path and return it's path.
  #
  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#386
  def config_object_pointing_to(user_config_path); end

  # Returns the content (Hash) of config/forced_rubocop_config.yml after processing it's ERB content.
  # Cached since it doesn't change between files
  #
  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#422
  def forced_rubocop_config_hash; end

  # Find the path to the effective RuboCop configuration for a path (file or dir)
  #
  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#410
  def user_rubocop_config_path_for(path); end
end

# source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#3
module HamlLint::RubyExtraction; end

# This chunk just adds its code to the ruby, but does not attempt to transfer their correction
# in any way.
#
# Used for piece of code that just need to be in the generated ruby for reasons specific to
# the use cases, such as needing a `begin` to do add indentation.
#
# source://haml_lint//lib/haml_lint/ruby_extraction/ad_hoc_chunk.rb#9
class HamlLint::RubyExtraction::AdHocChunk < ::HamlLint::RubyExtraction::BaseChunk
  # @return [AdHocChunk] a new instance of AdHocChunk
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/ad_hoc_chunk.rb#10
  def initialize(*args, **kwargs); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/ad_hoc_chunk.rb#20
  def skip_line_indexes_in_source_map; end

  # source://haml_lint//lib/haml_lint/ruby_extraction/ad_hoc_chunk.rb#18
  def transfer_correction(coordinator, all_corrected_ruby_lines, haml_lines); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/ad_hoc_chunk.rb#14
  def wrap_in_markers; end
end

# This is the base class for all of the Chunks of HamlLint::RubyExtraction.
# A Chunk represents a part of the HAML file that HamlLint::Linter::RuboCop
# is processing and will insert some Ruby code in a file passed to RuboCop.
#
# There are chunks for most HAML concepts, even if they don't represent Ruby
# code. For example, there is a chunk that represents a `%div` tag, which
# uses a `begin` in the generated Ruby to add indentation for the children
# of the %div in the Ruby file just like there is in the HAML file.
#
# source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#12
class HamlLint::RubyExtraction::BaseChunk
  # @return [BaseChunk] a new instance of BaseChunk
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#34
  def initialize(node, ruby_lines, end_marker_indent:, haml_line_index: T.unsafe(nil)); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#100
  def assemble_in(coordinator); end

  # @return [Integer] The indentation (number of spaces) to use to index the marker
  #   that follows this chunk. Unlike the marker before, this one can vary.
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#29
  def end_marker_indent; end

  # source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#89
  def full_assemble(coordinator); end

  # To be overridden in subclasses.
  # Return a new chunk which is the result of fusing self with the given following chunk.
  # If no fusion is possible, returns nil
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#47
  def fuse(_following_chunk); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#80
  def haml_end_line_index; end

  # @return [Integer] First line index of the auto-correctable code in the Haml source
  #   Usually same as node.line - 1, but some cases, such as interpolation in a filter will
  #   will be different.
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#21
  def haml_line_index; end

  # source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#85
  def nb_haml_lines; end

  # @return [HamlLint::Tree::Node] Haml node that this comes from
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#16
  def node; end

  # @return [Array<String>] The ruby lines that this chunk will insert
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#32
  def ruby_lines; end

  # source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#106
  def skip_line_indexes_in_source_map; end

  # source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#76
  def start_marker_indent; end

  # @return [Integer] Line number of the line marker in the ruby source placed before
  #   this auto-correctable code
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#25
  def start_marker_line_number; end

  # Overwrites haml_lines to match the Ruby code that was corrected by RuboCop which is in
  # all_corrected_ruby_lines. This can change non-ruby parts to, especially for
  # indentation.
  #
  # This will be called on ruby chunks in the reverse order they were created. Two benefits
  # of this approach:
  # * No need to track when lines in haml_lines are moved to apply changes later in the file
  # * When fixing indentation of lines that follow a corrected line, those following lines will
  #   already have been corrected and so require nothing.
  # Can be overridden by subclasses to make it do nothing
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#61
  def transfer_correction(coordinator, _all_corrected_ruby_lines, haml_lines); end

  # To be overriden by subclasses.
  #
  # Logic to transfer the corrections that turned from_ruby_lines into to_ruby_lines.
  #
  # This method only received the ruby code that belongs to this chunk. (It was
  # extracted using #extract_from by #transfer_correction)
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#72
  def transfer_correction_logic(_coordinator, _to_ruby_lines, _haml_lines); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#110
  def wrap_in_markers; end
end

# source://haml_lint//lib/haml_lint/ruby_extraction/base_chunk.rb#13
HamlLint::RubyExtraction::BaseChunk::COMMA_CHANGES_LINES = T.let(T.unsafe(nil), TrueClass)

# Extracts "chunks" of the haml file into instances of subclasses of HamlLint::RubyExtraction::BaseChunk.
#
# This is the first step of generating Ruby code from a HAML file to then be processed by RuboCop.
# See HamlLint::RubyExtraction::BaseChunk for more details.
#
# source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#9
class HamlLint::RubyExtraction::ChunkExtractor
  include ::HamlLint::HamlVisitor

  # @return [ChunkExtractor] a new instance of ChunkExtractor
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#20
  def initialize(document, script_output_prefix:); end

  # Adds empty lines that follow the lines (Used for scripts), so that
  # RuboCop can receive them too. Some cops are sensitive to empty lines.
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#614
  def add_following_empty_lines(node, lines); end

  # Adds chunks for the interpolation within the given code
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#396
  def add_interpolation_chunks(node, code, haml_line_index, indent:, line_start_index: T.unsafe(nil)); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#25
  def extract; end

  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#543
  def extract_piped_plain_multilines(first_line_index); end

  # HAML transforms the ruby code in many ways as it parses a document. Often removing lines and/or
  # indentation. This is quite annoying for us since we want the exact layout of the code to analyze it.
  #
  # This function receives the code as haml provides it and the line where it starts. It returns
  # the actual code as it is in the haml file, keeping breaks and indentation for the following lines.
  # In addition, the start position of the code in the first line.
  #
  # The rules for handling multiline code in HAML are as follow:
  # * if the line being processed ends with a space and a pipe, then append to the line (without
  #   newlines) every following lines that also end with a space and a pipe. This means the last line of
  #   the "block" also needs a pipe at the end.
  # * after processing the pipes, when dealing with ruby code (and not in tag attributes' hash), if the line
  #   (which maybe span across multiple lines) ends with a comma, add the next line to the current piece of code.
  #
  # @return [first_line_offset, ruby_lines]
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#484
  def extract_raw_ruby_lines(haml_processed_ruby_code, first_line_index); end

  # Tag attributes actually handle multiline differently than scripts.
  # The basic system basically keeps considering more lines until it meets the closing braces, but still
  # processes pipes too (same as extract_raw_ruby_lines).
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#565
  def extract_raw_tag_attributes_ruby_lines(haml_processed_ruby_code, first_line_index); end

  # Code common to both silent and outputting scripts
  #
  # raw_code is the code before we do transformations, such as adding the `HL.out = `
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#182
  def finish_visit_any_script(node, lines, raw_code: T.unsafe(nil), must_start_chunk: T.unsafe(nil), first_output_prefix: T.unsafe(nil)); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#634
  def indent_after_line_index(line_index); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#629
  def parse_ruby(source); end

  # Useful for tests
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#35
  def prepare_extract; end

  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#441
  def process_multiline!(line); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#450
  def process_plain_multiline!(line); end

  # Returns the value of attribute script_output_prefix.
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#12
  def script_output_prefix; end

  # Visiting comments which are output to HTML. Lines looking like
  #   `  / This will be in the HTML source!`
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#84
  def visit_comment(node); end

  # Visiting a HAML filter. Lines looking like `  :javascript` and the following lines
  # that are nested.
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#358
  def visit_filter(node); end

  # Visiting lines like `  -# Some commenting!`
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#51
  def visit_haml_comment(node); end

  # Visiting lines like `  Some raw text to output`
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#45
  def visit_plain(node); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#40
  def visit_root(_node); end

  # Visit a script which outputs. Lines looking like `  = foo`
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#91
  def visit_script(node, &block); end

  # Visit a script which doesn't output. Lines looking like `  - foo`
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#163
  def visit_silent_script(node, &block); end

  # Visiting a tag. Lines looking like `  %div`
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#219
  def visit_tag(node); end

  # (Called manually form visit_tag)
  # Visiting the attributes of a tag. Lots of different examples below in the code.
  # A common syntax is: `%div{style: 'yes_please'}`
  #
  # Returns the new line_index we reached, useful to handle the script that follows
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#259
  def visit_tag_attributes(node, indent:); end

  # Visiting the script besides tag. The part to the right of the equal sign of
  # lines looking like `  %div= foo(bar)`
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#319
  def visit_tag_script(node, line_index:, indent:); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#604
  def wrap_lines(lines, wrap_depth); end

  class << self
    # @return [Boolean]
    #
    # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#646
    def anonymous_block?(code); end

    # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#660
    def block_keyword(code); end

    # @return [Boolean]
    #
    # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#655
    def start_block_keyword?(code); end

    # @return [Boolean]
    #
    # source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#642
    def start_nesting_after?(code); end
  end
end

# source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#14
HamlLint::RubyExtraction::ChunkExtractor::HAML_PARSER_INSTANCE = T.let(T.unsafe(nil), Haml::Parser)

# source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#659
HamlLint::RubyExtraction::ChunkExtractor::LOOP_KEYWORDS = T.let(T.unsafe(nil), Array)

# source://haml_lint//lib/haml_lint/ruby_extraction/chunk_extractor.rb#654
HamlLint::RubyExtraction::ChunkExtractor::START_BLOCK_KEYWORDS = T.let(T.unsafe(nil), Array)

# Coordinates the entire RubyExtraction system.
#
# * Uses the extractor to generate chunks.
# * Preprocess the chunks to cleanup/fuse some of them.
# * Generates the extracted ruby code from the Chunks.
# * Handles the markers (see below)
# * Use the chunks to transfer corrections from corrected Ruby code back to HAML
#
# The generated Ruby code uses markers to wrap around the Ruby code from the chunks.
# Those markers look like function calls, like: `haml_lint_marker_1`, so are valid ruby.
# After RuboCop does it's auto-correction, the markers are used to find the pieces of the
# corrected Ruby code that correspond to each Chunk.
#
# source://haml_lint//lib/haml_lint/ruby_extraction/coordinator.rb#18
class HamlLint::RubyExtraction::Coordinator
  # @return [Coordinator] a new instance of Coordinator
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/coordinator.rb#31
  def initialize(document); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/coordinator.rb#101
  def add_lines(lines, haml_line_index:, skip_indexes_in_source_map: T.unsafe(nil)); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/coordinator.rb#120
  def add_marker(indent, haml_line_index:, name: T.unsafe(nil)); end

  # @return [Array<String>] The ruby lines after extraction from HAML (before RuboCop)
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/coordinator.rb#26
  def assembled_ruby_lines; end

  # @return [Array<String>] The ruby lines after correction by RuboCop
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/coordinator.rb#29
  def corrected_ruby_lines; end

  # source://haml_lint//lib/haml_lint/ruby_extraction/coordinator.rb#144
  def extract_from_corrected_lines(start_marker_line_number, nb_lines); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/coordinator.rb#42
  def extract_ruby_source; end

  # source://haml_lint//lib/haml_lint/ruby_extraction/coordinator.rb#134
  def find_line_index_of_marker_in_corrections(line, name: T.unsafe(nil)); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/coordinator.rb#78
  def haml_lines_with_corrections_applied(corrected_ruby_source); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/coordinator.rb#116
  def line_count; end

  # @return [String] The prefix used for markers in the Ruby code
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/coordinator.rb#23
  def marker_prefix; end

  # If the ruby_lines have different markers in them, or are in a different order,
  # then RuboCop did not alter them in a way that is compatible with this system.
  #
  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/coordinator.rb#128
  def markers_conflict?(from_ruby_lines, to_ruby_lines); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/coordinator.rb#155
  def pick_a_marker_prefix; end

  # source://haml_lint//lib/haml_lint/ruby_extraction/coordinator.rb#168
  def pick_a_script_output_prefix; end

  # source://haml_lint//lib/haml_lint/ruby_extraction/coordinator.rb#63
  def preprocess_chunks; end

  # @return [String] The prefix used for to handle `= foo` script's in the extracted Ruby code.
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/coordinator.rb#20
  def script_output_prefix; end
end

# Chunk for haml comments. Lines like `  -# Some commenting!`.
# Only deals with indentation while correcting, but can also be fused to a ScriptChunk.
#
# source://haml_lint//lib/haml_lint/ruby_extraction/haml_comment_chunk.rb#6
class HamlLint::RubyExtraction::HamlCommentChunk < ::HamlLint::RubyExtraction::BaseChunk
  # source://haml_lint//lib/haml_lint/ruby_extraction/haml_comment_chunk.rb#7
  def fuse(following_chunk); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/haml_comment_chunk.rb#30
  def min_indent_of(lines); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/haml_comment_chunk.rb#18
  def transfer_correction_logic(_coordinator, to_ruby_lines, haml_lines); end
end

# HAML adds a `end` when code gets outdented. We need to add that to the Ruby too, this
# is the chunk for it.
# However:
# * we can't apply fixes to it, so there are no markers
# * this is a distinct class so that a ScriptChunk can fuse this ImplicitEnd into itself,
#   So that we can generate bigger chunks of uninterrupted Ruby.
#
# source://haml_lint//lib/haml_lint/ruby_extraction/implicit_end_chunk.rb#10
class HamlLint::RubyExtraction::ImplicitEndChunk < ::HamlLint::RubyExtraction::BaseChunk
  # source://haml_lint//lib/haml_lint/ruby_extraction/implicit_end_chunk.rb#15
  def transfer_correction(coordinator, all_corrected_ruby_lines, haml_lines); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/implicit_end_chunk.rb#11
  def wrap_in_markers; end
end

# Deals with interpolation within a plain text, filter, etc.
# Can only handling single line interpolation, so will be skipped if it takes
# more than one line or if the correction takes more than one line.
#
# Stores the char index to know where in the line to do the replacements.
#
# source://haml_lint//lib/haml_lint/ruby_extraction/interpolation_chunk.rb#9
class HamlLint::RubyExtraction::InterpolationChunk < ::HamlLint::RubyExtraction::BaseChunk
  # @return [InterpolationChunk] a new instance of InterpolationChunk
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/interpolation_chunk.rb#10
  def initialize(*args, start_char_index:, **kwargs); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/interpolation_chunk.rb#15
  def transfer_correction_logic(coordinator, to_ruby_lines, haml_lines); end
end

# Chunk for dealing with every HAML filter other than `:ruby`
# The generated Ruby for these is just a HEREDOC, so interpolation is corrected at
# the same time by RuboCop.
#
# source://haml_lint//lib/haml_lint/ruby_extraction/non_ruby_filter_chunk.rb#7
class HamlLint::RubyExtraction::NonRubyFilterChunk < ::HamlLint::RubyExtraction::BaseChunk
  # source://haml_lint//lib/haml_lint/ruby_extraction/non_ruby_filter_chunk.rb#28
  def skip_line_indexes_in_source_map; end

  # source://haml_lint//lib/haml_lint/ruby_extraction/non_ruby_filter_chunk.rb#8
  def transfer_correction_logic(_coordinator, to_ruby_lines, haml_lines); end
end

# This chunk just adds a marker (with a custom name) to the generated Ruby and only attempts to
# transfer the corrections it receives to the indentation of the associated lines.
#
# Also used so that Rubocop doesn't think that there is nothing in `if` and other such structures,
# so that it does corrections that make sense for the HAML.
#
# source://haml_lint//lib/haml_lint/ruby_extraction/placeholder_marker_chunk.rb#9
class HamlLint::RubyExtraction::PlaceholderMarkerChunk < ::HamlLint::RubyExtraction::BaseChunk
  # @return [PlaceholderMarkerChunk] a new instance of PlaceholderMarkerChunk
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/placeholder_marker_chunk.rb#10
  def initialize(node, marker_name, indent:, nb_lines: T.unsafe(nil), **kwargs); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/placeholder_marker_chunk.rb#36
  def end_marker_indent; end

  # source://haml_lint//lib/haml_lint/ruby_extraction/placeholder_marker_chunk.rb#17
  def full_assemble(coordinator); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/placeholder_marker_chunk.rb#32
  def haml_end_line_index; end

  # source://haml_lint//lib/haml_lint/ruby_extraction/placeholder_marker_chunk.rb#22
  def transfer_correction(coordinator, all_corrected_ruby_lines, haml_lines); end
end

# Chunk for dealing with `:ruby` filter.
#
# source://haml_lint//lib/haml_lint/ruby_extraction/ruby_filter_chunk.rb#5
class HamlLint::RubyExtraction::RubyFilterChunk < ::HamlLint::RubyExtraction::BaseChunk
  # @return [RubyFilterChunk] a new instance of RubyFilterChunk
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/ruby_filter_chunk.rb#8
  def initialize(*args, start_marker_indent:, **kwargs); end

  # Returns the value of attribute start_marker_indent.
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/ruby_filter_chunk.rb#6
  def start_marker_indent; end

  # source://haml_lint//lib/haml_lint/ruby_extraction/ruby_filter_chunk.rb#13
  def transfer_correction_logic(coordinator, to_ruby_lines, haml_lines); end
end

# source://haml_lint//lib/haml_lint/ruby_extraction/ruby_source.rb#4
class HamlLint::RubyExtraction::RubySource < ::Struct
  # Returns the value of attribute ruby_chunks
  #
  # @return [Object] the current value of ruby_chunks
  def ruby_chunks; end

  # Sets the attribute ruby_chunks
  #
  # @param value [Object] the value to set the attribute ruby_chunks to.
  # @return [Object] the newly set value
  def ruby_chunks=(_); end

  # Returns the value of attribute source
  #
  # @return [Object] the current value of source
  def source; end

  # Sets the attribute source
  #
  # @param value [Object] the value to set the attribute source to.
  # @return [Object] the newly set value
  def source=(_); end

  # Returns the value of attribute source_map
  #
  # @return [Object] the current value of source_map
  def source_map; end

  # Sets the attribute source_map
  #
  # @param value [Object] the value to set the attribute source_map to.
  # @return [Object] the newly set value
  def source_map=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Chunk for handling outputting and silent scripts, so `  = foo` and `  - bar`
# Does NOT handle a script beside a tag (ex: `%div= spam`)
#
# source://haml_lint//lib/haml_lint/ruby_extraction/script_chunk.rb#8
class HamlLint::RubyExtraction::ScriptChunk < ::HamlLint::RubyExtraction::BaseChunk
  # @return [ScriptChunk] a new instance of ScriptChunk
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/script_chunk.rb#28
  def initialize(*args, previous_chunk:, must_start_chunk: T.unsafe(nil), skip_line_indexes_in_source_map: T.unsafe(nil), first_output_haml_prefix: T.unsafe(nil), **kwargs); end

  # @return [String] The prefix for the first outputting string of this script. (One of = != &=)
  #   The outputting scripts after the first are always with =
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/script_chunk.rb#13
  def first_output_haml_prefix; end

  # source://haml_lint//lib/haml_lint/ruby_extraction/script_chunk.rb#37
  def fuse(following_chunk); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/script_chunk.rb#67
  def fuse_implicit_end(following_chunk); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/script_chunk.rb#46
  def fuse_script_chunk(following_chunk); end

  # @return [Boolean] true if this ScriptChunk must be at the beginning of a chunk.
  #   This blocks this ScriptChunk from being fused to a ScriptChunk that is before it.
  #   Needed to handle some patterns of outputting script.
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/script_chunk.rb#18
  def must_start_chunk; end

  # @return [HamlLint::RubyExtraction::BaseChunk] The previous chunk can affect how
  #   our starting marker must be indented.
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/script_chunk.rb#26
  def previous_chunk; end

  # @return [Array<Integer>] Line indexes to ignore when building the source_map. For examples,
  #   implicit `end` are on their own line in the Ruby file, but in the HAML, they are absent.
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/script_chunk.rb#22
  def skip_line_indexes_in_source_map; end

  # source://haml_lint//lib/haml_lint/ruby_extraction/script_chunk.rb#85
  def start_marker_indent; end

  # source://haml_lint//lib/haml_lint/ruby_extraction/script_chunk.rb#91
  def transfer_correction_logic(coordinator, to_ruby_lines, haml_lines); end

  class << self
    # source://haml_lint//lib/haml_lint/ruby_extraction/script_chunk.rb#169
    def find_statement_start_line_indexes(to_ruby_lines); end

    # source://haml_lint//lib/haml_lint/ruby_extraction/script_chunk.rb#103
    def format_ruby_lines_to_haml_lines(to_ruby_lines, script_output_ruby_prefix:, first_output_haml_prefix: T.unsafe(nil)); end
  end
end

# source://haml_lint//lib/haml_lint/ruby_extraction/script_chunk.rb#101
HamlLint::RubyExtraction::ScriptChunk::ALLOW_EXPRESSION_AFTER_LINE_ENDING_WITH = T.let(T.unsafe(nil), Array)

# source://haml_lint//lib/haml_lint/ruby_extraction/script_chunk.rb#9
HamlLint::RubyExtraction::ScriptChunk::MID_BLOCK_KEYWORDS = T.let(T.unsafe(nil), Array)

# Chunk for handling the a tag attributes, such as `%div{style: 'yes_please'}`
#
# source://haml_lint//lib/haml_lint/ruby_extraction/tag_attributes_chunk.rb#5
class HamlLint::RubyExtraction::TagAttributesChunk < ::HamlLint::RubyExtraction::BaseChunk
  # @return [TagAttributesChunk] a new instance of TagAttributesChunk
  #
  # source://haml_lint//lib/haml_lint/ruby_extraction/tag_attributes_chunk.rb#6
  def initialize(*args, indent_to_remove:, **kwargs); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/tag_attributes_chunk.rb#11
  def transfer_correction_logic(_coordinator, to_ruby_lines, haml_lines); end

  # source://haml_lint//lib/haml_lint/ruby_extraction/tag_attributes_chunk.rb#50
  def unwrap(lines); end
end

# Chunk for handling outputting scripts after a tag, such as `%div= spam`
#
# source://haml_lint//lib/haml_lint/ruby_extraction/tag_script_chunk.rb#5
class HamlLint::RubyExtraction::TagScriptChunk < ::HamlLint::RubyExtraction::BaseChunk
  # source://haml_lint//lib/haml_lint/ruby_extraction/tag_script_chunk.rb#6
  def transfer_correction_logic(coordinator, to_ruby_lines, haml_lines); end
end

# source://haml_lint//lib/haml_lint/ruby_extraction/coordinator.rb#4
class HamlLint::RubyExtraction::UnableToTransferCorrections < ::StandardError; end

# Parser for the Ruby language.
#
# This provides a convenient wrapper around the `parser` gem and the
# Astrolabe integration (now built-in to RuboCop, so no longer called
# Astrolabe) to go with it. It is intended to be used for linter
# checks that require deep inspection of Ruby code.
#
# source://haml_lint//lib/haml_lint/ruby_parser.rb#13
class HamlLint::RubyParser
  # Creates a reusable parser.
  #
  # @return [RubyParser] a new instance of RubyParser
  #
  # source://haml_lint//lib/haml_lint/ruby_parser.rb#15
  def initialize; end

  # Parse the given Ruby source into an abstract syntax tree.
  #
  # @param source [String] Ruby source code
  # @return [Array] syntax tree in the form returned by Parser gem
  #
  # source://haml_lint//lib/haml_lint/ruby_parser.rb#35
  def parse(source); end

  # Require the current parser version while suppressing the
  # compliancy warning for minor version differences.
  #
  # source://haml_lint//lib/haml_lint/ruby_parser.rb#23
  def require_parser; end
end

# Responsible for running the applicable linters against the desired files.
#
# source://haml_lint//lib/haml_lint/runner.rb#7
class HamlLint::Runner
  # Runs the appropriate linters against the desired files given the specified
  # options.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash]
  # @return [HamlLint::Report] a summary of all lints found
  #
  # source://haml_lint//lib/haml_lint/runner.rb#21
  def run(options = T.unsafe(nil)); end

  private

  # Out of the provided linters, runs those that support autocorrect
  # against the specified document.
  # Updates the document and returns the lints that were corrected.
  #
  # @param document [HamlLint::Document]
  # @param linter_selector [HamlLint::LinterSelector]
  # @return [Array<HamlLint::Lint>]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#115
  def autocorrect_document(document, linters); end

  # Runs all provided linters using the specified config against the given
  # file.
  #
  # @param file [String] path to file to lint
  # @param linter_selector [HamlLint::LinterSelector]
  # @param config [HamlLint::Configuration]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#85
  def collect_lints(file, linter_selector, config); end

  # The {HamlLint::Configuration} that should be used for this run.
  #
  # @return [HamlLint::Configuration]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#38
  def config; end

  # Returns the list of files that should be linted given the specified
  # configuration and options.
  #
  # @param config [HamlLint::Configuration]
  # @param options [Hash]
  # @return [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#134
  def extract_applicable_files(config, options); end

  # A flag for whether to fail after the first failure.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#43
  def fail_fast; end

  # A flag for whether to fail after the first failure.
  # !@method fail_fast?
  #   Checks whether to fail after the first failure.
  #
  #   @return [true, false]
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#43
  def fail_fast?; end

  # The list of files to lint during this run.
  #
  # @return [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#54
  def files; end

  # The selector for which linters to run during this run.
  #
  # @return [HamlLint::LinterSelector]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#59
  def linter_selector; end

  # Returns the {HamlLint::Configuration} that should be used given the
  # specified options.
  #
  # @param options [Hash]
  # @return [HamlLint::Configuration]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#66
  def load_applicable_config(options); end

  # Process a file and add it to the given report.
  #
  # @param file [String] the name of the file to process
  # @param report [HamlLint::Report]
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#158
  def process_file(file, report); end

  # Process the files and add them to the given report.
  #
  # @param report [HamlLint::Report]
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#146
  def process_files(report); end

  # Generates a report based on the given options.
  #
  # @option options
  # @param options [Hash]
  # @return [HamlLint::Report]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#169
  def report(options); end

  # Cache the result of processing lints in parallel.
  #
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#180
  def warm_cache; end
end

# Models the severity of a lint
#
# source://haml_lint//lib/haml_lint/severity.rb#7
class HamlLint::Severity < ::SimpleDelegator
  include ::Comparable

  # Creates a new severity for a lint
  #
  # @api public
  # @example
  #   HamlLint::Severity.new(:warning)
  # @param name [Symbol] the name of the severity level
  # @return [Severity] a new instance of Severity
  #
  # source://haml_lint//lib/haml_lint/severity.rb#24
  def initialize(name); end

  # Compares the severity to another severity or a symbol
  #
  # @return [Integer]
  #
  # source://haml_lint//lib/haml_lint/severity.rb#92
  def <=>(other); end

  # The color of the mark in reporters.
  #
  # @return [Symbol]
  #
  # source://haml_lint//lib/haml_lint/severity.rb#34
  def color; end

  # Checks whether the severity is an error
  #
  # @api public
  # @example
  #   HamlLint::Severity.new(:error).error? #=> true
  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/severity.rb#45
  def error?; end

  # The level of severity for the lint
  #
  # @api public
  # @return [Integer]
  #
  # source://haml_lint//lib/haml_lint/severity.rb#53
  def level; end

  # The symbol to use in a {HamlLint::Reporter::ProgressReporter}.
  #
  # source://haml_lint//lib/haml_lint/severity.rb#60
  def mark; end

  # The colorized symbol to use in a reporter.
  #
  # source://haml_lint//lib/haml_lint/severity.rb#67
  def mark_with_color; end

  # The name of the severity.
  #
  # source://haml_lint//lib/haml_lint/severity.rb#74
  def name; end

  # Checks whether the severity is a warning
  #
  # @api public
  # @example
  #   HamlLint::Severity.new(:warning).warning? #=> true
  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/severity.rb#85
  def warning?; end
end

# source://haml_lint//lib/haml_lint/severity.rb#13
HamlLint::Severity::COLORS = T.let(T.unsafe(nil), Hash)

# source://haml_lint//lib/haml_lint/severity.rb#14
HamlLint::Severity::MARKS = T.let(T.unsafe(nil), Hash)

# source://haml_lint//lib/haml_lint/severity.rb#15
HamlLint::Severity::NAMES = T.let(T.unsafe(nil), Array)

# source://haml_lint//lib/haml_lint/severity.rb#10
HamlLint::Severity::SEVERITY_ERROR = T.let(T.unsafe(nil), Symbol)

# source://haml_lint//lib/haml_lint/severity.rb#11
HamlLint::Severity::SEVERITY_WARNING = T.let(T.unsafe(nil), Symbol)

# source://haml_lint//lib/haml_lint/tree/node.rb#5
module HamlLint::Tree; end

# Represents a visible XHTML comment in a HAML document.
#
# source://haml_lint//lib/haml_lint/tree/comment_node.rb#5
class HamlLint::Tree::CommentNode < ::HamlLint::Tree::Node; end

# Represents a doctype definition for a HAML document.
#
# source://haml_lint//lib/haml_lint/tree/doctype_node.rb#5
class HamlLint::Tree::DoctypeNode < ::HamlLint::Tree::Node; end

# Represents a filter node which contains arbitrary code.
#
# source://haml_lint//lib/haml_lint/tree/filter_node.rb#6
class HamlLint::Tree::FilterNode < ::HamlLint::Tree::Node
  # The type of code contained in this filter.
  #
  # source://haml_lint//lib/haml_lint/tree/filter_node.rb#7
  def filter_type; end

  # source://haml_lint//lib/haml_lint/tree/filter_node.rb#11
  def text; end
end

# Represents a HAML comment node.
#
# source://haml_lint//lib/haml_lint/tree/haml_comment_node.rb#7
class HamlLint::Tree::HamlCommentNode < ::HamlLint::Tree::Node
  # source://haml_lint//lib/haml_lint/tree/haml_comment_node.rb#8
  def directives; end

  # Returns the full text content of this comment, including newlines if a
  # single comment spans multiple lines.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/tree/haml_comment_node.rb#18
  def text; end

  private

  # source://haml_lint//lib/haml_lint/tree/haml_comment_node.rb#30
  def contained_directives; end
end

# Decorator class that provides a convenient set of helpers for HAML's
# {Haml::Parser::ParseNode} struct.
#
# The goal is to abstract away the details of the underlying struct and
# provide a cleaner and more uniform interface for getting information about a
# node, as there are a number of weird/special cases in the struct returned by
# the HAML parser.
#
# @abstract
#
# source://haml_lint//lib/haml_lint/tree/node.rb#15
class HamlLint::Tree::Node
  include ::Enumerable

  # Creates a node wrapping the given {Haml::Parser::ParseNode} struct.
  #
  # @param document [HamlLint::Document] Haml document that created this node
  # @param parse_node [Haml::Parser::ParseNode] parse node created by HAML's parser
  # @return [Node] a new instance of Node
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#25
  def initialize(document, parse_node); end

  # Returns the value of attribute children.
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#18
  def children; end

  # Sets the attribute children
  #
  # @param value the value to set the attribute children to.
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#18
  def children=(_arg0); end

  # Holds any configuration that is created from Haml comments.
  #
  # @return [HamlLint::CommentConfiguration]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#35
  def comment_configuration; end

  # The comment directives to apply to the node.
  #
  # @return [Array<HamlLint::Directive>]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#64
  def directives; end

  # Checks whether a visitor is disabled due to comment configuration.
  #
  # @param [HamlLint::HamlVisitor]
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#43
  def disabled?(visitor); end

  # Implements the Enumerable interface to walk through an entire tree.
  #
  # @return [Enumerator, HamlLint::Tree::Node]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#51
  def each; end

  # source://haml_lint//lib/haml_lint/tree/node.rb#86
  def inspect; end

  # source://haml_lint//lib/haml_lint/tree/node.rb#163
  def keyword; end

  # Returns the value of attribute line.
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#19
  def line; end

  # The line numbers that are contained within the node.
  #
  # @api public
  # @return [Range]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#104
  def line_numbers; end

  # The lines of text, if any, that are contained in the node.
  #
  # @api public
  # @return [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#94
  def lines; end

  # Returns the next node that appears after this node in the document.
  #
  # Returns nil if there is no next node.
  #
  # @return [HamlLint::Tree::Node, nil]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#145
  def next_node; end

  # Returns the value of attribute parent.
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#18
  def parent; end

  # Sets the attribute parent
  #
  # @param value the value to set the attribute parent to.
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#18
  def parent=(_arg0); end

  # The previous node to be traversed in the tree.
  #
  # @return [HamlLint::Tree::Node, nil]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#121
  def predecessor; end

  # Source code of all lines this node spans (excluding children).
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#73
  def source_code; end

  # The sibling nodes that come after this node in the tree.
  #
  # @return [Array<HamlLint::Tree::Node>]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#152
  def subsequents; end

  # Returns the node that follows this node, whether it be a sibling or an
  # ancestor's child, but not a child of this node.
  #
  # If you are also willing to return the child, call {#next_node}.
  #
  # Returns nil if there is no successor.
  #
  # @return [HamlLint::Tree::Node, nil]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#133
  def successor; end

  # Returns the text content of this node.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#159
  def text; end

  # Returns the value of attribute type.
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#19
  def type; end

  private

  # Discovers the end line of the node when there are no lines.
  #
  # @return [Integer] the end line of the node
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#172
  def nontrivial_end_line; end

  # The siblings of this node within the tree.
  #
  # @api private
  # @return [Array<HamlLint::Tree::Node>]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#184
  def siblings; end
end

# Finds the node's siblings within the tree and makes them queryable.
#
# source://haml_lint//lib/haml_lint/tree/node.rb#193
class HamlLint::Tree::Node::Siblings < ::SimpleDelegator
  # Finds the next sibling in the tree for a given node.
  #
  # @param node [HamlLint::Tree::Node]
  # @return [HamlLint::Tree::Node, nil]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#194
  def next(node); end

  # Finds the previous sibling in the tree for a given node.
  #
  # @param node [HamlLint::Tree::Node]
  # @return [HamlLint::Tree::Node, nil]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#202
  def previous(node); end

  # Finds all sibling notes that appear before a node in the tree.
  #
  # @param node [HamlLint::Tree::Node]
  # @return [Array<HamlLint::Tree::Node>]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#210
  def priors(node); end

  # The set of siblings within the tree.
  #
  # @api private
  # @return [Array<HamlLint::Tree::Node>]
  #
  # source://delegate/0.2.0/delegate.rb#318
  def siblings; end

  # Finds all sibling notes that appear after a node in the tree.
  #
  # @param node [HamlLint::Tree::Node]
  # @return [Array<HamlLint::Tree::Node>]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#223
  def subsequents(node); end

  private

  # Finds the position of a node within a set of siblings.
  #
  # @api private
  # @return [Integer, nil]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#239
  def position(node); end
end

# A null object version of a node that can be used as a safe default.
#
# source://haml_lint//lib/haml_lint/tree/null_node.rb#6
class HamlLint::Tree::NullNode < ::HamlLint::Tree::Node
  # Instantiates a new {HamlLint::Tree::NullNode}, ignoring all input.
  #
  # @return [NullNode] a new instance of NullNode
  #
  # source://haml_lint//lib/haml_lint/tree/null_node.rb#7
  def initialize(*_args); end

  # Overrides the disabled check to always say the linter is enabled.
  #
  # @param _linter [HamlLint::Linter] the linter to check
  # @return [false]
  #
  # source://haml_lint//lib/haml_lint/tree/null_node.rb#13
  def disabled?(_linter); end
end

# Represents a node that contains plain text.
#
# source://haml_lint//lib/haml_lint/tree/plain_node.rb#5
class HamlLint::Tree::PlainNode < ::HamlLint::Tree::Node; end

# Represents the root node of a HAML document that contains all other nodes.
#
# source://haml_lint//lib/haml_lint/tree/root_node.rb#10
class HamlLint::Tree::RootNode < ::HamlLint::Tree::Node
  # The name fo the file parsed to build this tree.
  #
  # @return [String] a file name
  #
  # source://haml_lint//lib/haml_lint/tree/root_node.rb#11
  def file; end

  # Gets the node of the syntax tree for a given line number.
  #
  # @param line [Integer] the line number of the node
  # @return [HamlLint::Node]
  #
  # source://haml_lint//lib/haml_lint/tree/root_node.rb#19
  def node_for_line(line); end
end

# Represents a node which produces output based on Ruby code.
#
# source://haml_lint//lib/haml_lint/tree/script_node.rb#10
class HamlLint::Tree::ScriptNode < ::HamlLint::Tree::Node
  # The Ruby script contents parsed into a syntax tree.
  #
  # @return [ParsedRuby] syntax tree in the form returned by Parser gem
  #
  # source://haml_lint//lib/haml_lint/tree/script_node.rb#11
  def parsed_script; end

  # Returns the source for the script following the `-` marker.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/tree/script_node.rb#24
  def script; end
end

# Represents a HAML silent script node (`- some_expression`) which executes
# code without producing output.
#
# source://haml_lint//lib/haml_lint/tree/silent_script_node.rb#9
class HamlLint::Tree::SilentScriptNode < ::HamlLint::Tree::Node
  # The Ruby script contents parsed into a syntax tree.
  #
  # @return [ParsedRuby] syntax tree in the form returned by Parser gem
  #
  # source://haml_lint//lib/haml_lint/tree/silent_script_node.rb#10
  def parsed_script; end

  # Returns the source for the script following the `-` marker.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/tree/silent_script_node.rb#32
  def script; end
end

# Represents a tag node in a HAML document.
#
# source://haml_lint//lib/haml_lint/tree/tag_node.rb#18
class HamlLint::Tree::TagNode < ::HamlLint::Tree::Node
  # Returns the source code for the static and dynamic attributes
  # of a tag.
  #
  # @example For `%tag.class{ id: 'hello' }(lang=en)`, this returns:
  #   { :static => '.class', :hash => " id: 'hello' ", :html => "lang=en" }
  # @return [Hash]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#96
  def attributes_source; end

  # Returns whether this tag contains executable script (e.g. is followed by a
  # `=`).
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#32
  def contains_script?; end

  # Returns the source code for the dynamic attributes defined in `{...}`,
  # `(...)`, or `[...]` after a tag name.
  #
  # @example For `%tag.class{ id: 'hello' }(lang=en)`, this returns:
  #   { :hash => " id: 'hello' ", :html => "lang=en" }
  # @return [Hash]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#84
  def dynamic_attributes_source; end

  # Computed set of attribute hashes code.
  #
  # This is a combination of all dynamically calculated attributes from the
  # different attribute setting syntaxes (`{...}`/`(...)`), converted into
  # Ruby code.
  #
  # calling `DynamicAttributes#to_literal`, they mutate the "old" parameter using
  # `String#sub!` instead of returning a new string. This means that any subsequent
  # calls can return a nil instead of a string for that attribute, which causes
  # any subsequent calls to the method to raise an error.
  #
  # @note This has to be memoized because of a design decision in Haml 5. When
  # @return [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#19
  def dynamic_attributes_sources; end

  # Returns whether this tag has a specified attribute.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#39
  def has_hash_attribute?(attribute); end

  # Whether this tag node has a set of hash attributes defined via the
  # curly brace syntax (e.g. `%tag{ lang: 'en' }`).
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#127
  def hash_attributes?; end

  # Attributes defined after the tag name in Ruby hash brackets (`{}`).
  #
  # @example For `%tag.class{ lang: 'en' }`, this returns:
  #   " lang: 'en' "
  # @return [String] source without the surrounding curly braces
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#137
  def hash_attributes_source; end

  # Whether this tag node has a set of HTML attributes defined via the
  # parentheses syntax (e.g. `%tag(lang=en)`).
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#145
  def html_attributes?; end

  # Attributes defined after the tag name in parentheses (`()`).
  #
  # @example For `%tag.class(lang=en)`, this returns:
  #   "lang=en"
  # @return [String, nil] source without the surrounding parentheses, or `nil`
  #   if it has not been defined
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#156
  def html_attributes_source; end

  # Whether this tag node has a set of square brackets (e.g. `%tag[...]`)
  # following it that indicates its class and ID will be to the value of the
  # given object's {#to_key} or {#id} method (in that order).
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#179
  def object_reference?; end

  # Source code for the contents of the node's object reference.
  #
  # @return [String, nil] string source of object reference or `nil` if it has
  #   not been defined
  # @see http://haml.info/docs/yardoc/file.REFERENCE.html#object_reference_
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#188
  def object_reference_source; end

  # The attributes given to the tag parsed into a Ruby syntax tree.
  #
  # @return [ParsedRuby] syntax tree in the form returned by Parser gem
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#195
  def parsed_attributes; end

  # The Ruby script contents of a tag parsed into a syntax tree.
  #
  # @return [ParsedRuby] syntax tree in the form returned by Parser gem
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#202
  def parsed_script; end

  # Whether this node had a `<` after it signifying that outer whitespace
  # should be removed.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#210
  def remove_inner_whitespace?; end

  # Whether this node had a `>` after it signifying that outer whitespace
  # should be removed.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#218
  def remove_outer_whitespace?; end

  # Returns the script source that will be evaluated to produce this tag's
  # inner content, if any.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#226
  def script; end

  # Static element attributes defined after the tag name.
  #
  # @example For `%tag.button#start-button`, this returns:
  #   '.button#start-button'
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#73
  def static_attributes_source; end

  # List of classes statically defined for this tag.
  #
  # @example For `%tag.button.button-info{ class: status }`, this returns:
  #   ['button', 'button-info']
  # @return [Array<String>] list of statically defined classes with leading
  #   dot removed
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#50
  def static_classes; end

  # List of ids statically defined for this tag.
  #
  # @example For `%tag.button#start-button{ id: special_id }`, this returns:
  #   ['start-button']
  # @return [Array<String>] list of statically defined ids with leading `#`
  #   removed
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#62
  def static_ids; end

  # ID of the HTML tag.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#163
  def tag_id; end

  # Name of the HTML tag.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#170
  def tag_name; end

  private

  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#232
  def existing_attributes; end
end

# A miscellaneous set of utility functions.
#
# source://haml_lint//lib/haml_lint/utils.rb#7
module HamlLint::Utils
  private

  # Returns whether a glob pattern (or any of a list of patterns) matches the
  # specified file.
  #
  # This is defined here so our file globbing options are consistent
  # everywhere we perform globbing.
  #
  # @param glob [String, Array]
  # @param file [String]
  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/utils.rb#19
  def any_glob_matches?(globs_or_glob, file); end

  # Converts a string containing underscores/hyphens/spaces into CamelCase.
  #
  # @param str [String]
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/utils.rb#136
  def camel_case(str); end

  # source://haml_lint//lib/haml_lint/utils.rb#240
  def check_error_when_compiling_haml(haml_string); end

  # Count the number of consecutive items satisfying the given {Proc}.
  #
  # @param items [Array]
  # @param offset [Fixnum] index to start searching from
  # @return [Integer]
  # @yield [item] Passes item to the provided block.
  # @yieldparam item [Object] Item to evaluate as matching criteria for
  #   inclusion
  # @yieldreturn [Boolean] whether to include the item
  #
  # source://haml_lint//lib/haml_lint/utils.rb#177
  def count_consecutive(items, offset = T.unsafe(nil)); end

  # Yields interpolated values within a block of text.
  #
  # @param text [String]
  # @yield Passes interpolated code and line number that code appears on in
  #   the text.
  # @yieldparam interpolated_code [String] code that was interpolated
  # @yieldparam line [Integer] line number code appears on in text
  #
  # source://haml_lint//lib/haml_lint/utils.rb#55
  def extract_interpolated_values(text); end

  # Returns indexes of all occurrences of a substring within a string.
  #
  # Note, this will not return overlaping substrings, so searching for "aa"
  # in "aaa" will only find one substring, not two.
  #
  # @param text [String] the text to search
  # @param substr [String] the substring to search for
  # @return [Array<Integer>] list of indexes where the substring occurs
  #
  # source://haml_lint//lib/haml_lint/utils.rb#125
  def extract_substring_positions(text, substr); end

  # Find all consecutive items satisfying the given block of a minimum size,
  # yielding each group of consecutive items to the provided block.
  #
  # @param items [Array]
  # @param satisfies [Proc] function that takes an item and returns true/false
  # @param min_consecutive [Fixnum] minimum number of consecutive items before
  #   yielding the group
  # @yield Passes list of consecutive items all matching the criteria defined
  #   by the `satisfies` {Proc} to the provided block
  # @yieldparam group [Array] List of consecutive items
  # @yieldreturn [Boolean] block should return whether item matches criteria
  #   for inclusion
  #
  # source://haml_lint//lib/haml_lint/utils.rb#152
  def for_consecutive_items(items, satisfies, min_consecutive = T.unsafe(nil)); end

  # Returns an array of two items, the first being the absolute path, the second
  # the relative path.
  #
  # The relative path is relative to the current working dir. The path passed can
  # be either relative or absolute.
  #
  # @param path [String] Path to get absolute and relative path of
  # @return [Array<String>] Absolute and relative path
  #
  # source://haml_lint//lib/haml_lint/utils.rb#37
  def get_abs_and_rel_path(path); end

  # source://haml_lint//lib/haml_lint/utils.rb#82
  def handle_interpolation_with_indexes(text); end

  # Same as Haml::Util.handle_interpolation, but enables multiline mode on the regex
  #
  # source://haml_lint//lib/haml_lint/utils.rb#103
  def handle_interpolation_with_newline(str); end

  # source://haml_lint//lib/haml_lint/utils.rb#215
  def indent(string, nb_indent); end

  # source://haml_lint//lib/haml_lint/utils.rb#194
  def insert_after_indentation(code, insert); end

  # Returns true if line is only whitespace.
  # Note, this is not like blank? is rails. For nil, this returns false.
  #
  # source://haml_lint//lib/haml_lint/utils.rb#236
  def is_blank_line?(line); end

  # source://haml_lint//lib/haml_lint/utils.rb#230
  def map_after_first!(array, &block); end

  # source://haml_lint//lib/haml_lint/utils.rb#223
  def map_subset!(array, range, &block); end

  # Process ERB, providing some values for for versions to it
  #
  # @param content [String] the (usually yaml) content to process
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/utils.rb#187
  def process_erb(content); end

  # source://haml_lint//lib/haml_lint/utils.rb#280
  def regexp_for_parts(parts, join_regexp); end

  # Overrides the global stdin, stdout and stderr while within the block, to
  # push a string in stdin, and capture both stdout and stderr which are returned.
  #
  # @param stdin_str [String] the string to push in as stdin
  # @param _block [Block] the block to perform with the overridden std streams
  # @return [String, String]
  #
  # source://haml_lint//lib/haml_lint/utils.rb#258
  def with_captured_streams(stdin_str, &_block); end

  # Calls a block of code with a modified set of environment variables,
  # restoring them once the code has executed.
  #
  # @param env [Hash] environment variables to set
  #
  # source://haml_lint//lib/haml_lint/utils.rb#203
  def with_environment(env); end

  class << self
    # Returns whether a glob pattern (or any of a list of patterns) matches the
    # specified file.
    #
    # This is defined here so our file globbing options are consistent
    # everywhere we perform globbing.
    #
    # @param glob [String, Array]
    # @param file [String]
    # @return [Boolean]
    #
    # source://haml_lint//lib/haml_lint/utils.rb#19
    def any_glob_matches?(globs_or_glob, file); end

    # Converts a string containing underscores/hyphens/spaces into CamelCase.
    #
    # @param str [String]
    # @return [String]
    #
    # source://haml_lint//lib/haml_lint/utils.rb#136
    def camel_case(str); end

    # source://haml_lint//lib/haml_lint/utils.rb#240
    def check_error_when_compiling_haml(haml_string); end

    # Count the number of consecutive items satisfying the given {Proc}.
    #
    # @param items [Array]
    # @param offset [Fixnum] index to start searching from
    # @return [Integer]
    # @yield [item] Passes item to the provided block.
    # @yieldparam item [Object] Item to evaluate as matching criteria for
    #   inclusion
    # @yieldreturn [Boolean] whether to include the item
    #
    # source://haml_lint//lib/haml_lint/utils.rb#177
    def count_consecutive(items, offset = T.unsafe(nil)); end

    # Yields interpolated values within a block of text.
    #
    # @param text [String]
    # @yield Passes interpolated code and line number that code appears on in
    #   the text.
    # @yieldparam interpolated_code [String] code that was interpolated
    # @yieldparam line [Integer] line number code appears on in text
    #
    # source://haml_lint//lib/haml_lint/utils.rb#55
    def extract_interpolated_values(text); end

    # Returns indexes of all occurrences of a substring within a string.
    #
    # Note, this will not return overlaping substrings, so searching for "aa"
    # in "aaa" will only find one substring, not two.
    #
    # @param text [String] the text to search
    # @param substr [String] the substring to search for
    # @return [Array<Integer>] list of indexes where the substring occurs
    #
    # source://haml_lint//lib/haml_lint/utils.rb#125
    def extract_substring_positions(text, substr); end

    # Find all consecutive items satisfying the given block of a minimum size,
    # yielding each group of consecutive items to the provided block.
    #
    # @param items [Array]
    # @param satisfies [Proc] function that takes an item and returns true/false
    # @param min_consecutive [Fixnum] minimum number of consecutive items before
    #   yielding the group
    # @yield Passes list of consecutive items all matching the criteria defined
    #   by the `satisfies` {Proc} to the provided block
    # @yieldparam group [Array] List of consecutive items
    # @yieldreturn [Boolean] block should return whether item matches criteria
    #   for inclusion
    #
    # source://haml_lint//lib/haml_lint/utils.rb#152
    def for_consecutive_items(items, satisfies, min_consecutive = T.unsafe(nil)); end

    # Returns an array of two items, the first being the absolute path, the second
    # the relative path.
    #
    # The relative path is relative to the current working dir. The path passed can
    # be either relative or absolute.
    #
    # @param path [String] Path to get absolute and relative path of
    # @return [Array<String>] Absolute and relative path
    #
    # source://haml_lint//lib/haml_lint/utils.rb#37
    def get_abs_and_rel_path(path); end

    # source://haml_lint//lib/haml_lint/utils.rb#82
    def handle_interpolation_with_indexes(text); end

    # source://haml_lint//lib/haml_lint/utils.rb#103
    def handle_interpolation_with_newline(str); end

    # source://haml_lint//lib/haml_lint/utils.rb#215
    def indent(string, nb_indent); end

    # source://haml_lint//lib/haml_lint/utils.rb#194
    def insert_after_indentation(code, insert); end

    # Returns true if line is only whitespace.
    # Note, this is not like blank? is rails. For nil, this returns false.
    #
    # @return [Boolean]
    #
    # source://haml_lint//lib/haml_lint/utils.rb#236
    def is_blank_line?(line); end

    # source://haml_lint//lib/haml_lint/utils.rb#230
    def map_after_first!(array, &block); end

    # source://haml_lint//lib/haml_lint/utils.rb#223
    def map_subset!(array, range, &block); end

    # Process ERB, providing some values for for versions to it
    #
    # @param content [String] the (usually yaml) content to process
    # @return [String]
    #
    # source://haml_lint//lib/haml_lint/utils.rb#187
    def process_erb(content); end

    # source://haml_lint//lib/haml_lint/utils.rb#280
    def regexp_for_parts(parts, join_regexp); end

    # Overrides the global stdin, stdout and stderr while within the block, to
    # push a string in stdin, and capture both stdout and stderr which are returned.
    #
    # @param stdin_str [String] the string to push in as stdin
    # @param _block [Block] the block to perform with the overridden std streams
    # @return [String, String]
    #
    # source://haml_lint//lib/haml_lint/utils.rb#258
    def with_captured_streams(stdin_str, &_block); end

    # Calls a block of code with a modified set of environment variables,
    # restoring them once the code has executed.
    #
    # @param env [Hash] environment variables to set
    #
    # source://haml_lint//lib/haml_lint/utils.rb#203
    def with_environment(env); end
  end
end

# source://haml_lint//lib/haml_lint/version.rb#5
HamlLint::VERSION = T.let(T.unsafe(nil), String)

# A simple wrapper around Gem::Version to allow comparison with String instances
# This makes code shorter in some places
#
# source://haml_lint//lib/haml_lint/version_comparer.rb#6
class HamlLint::VersionComparer
  include ::Comparable

  # @return [VersionComparer] a new instance of VersionComparer
  #
  # source://haml_lint//lib/haml_lint/version_comparer.rb#7
  def initialize(version); end

  # source://haml_lint//lib/haml_lint/version_comparer.rb#12
  def <=>(other); end

  class << self
    # source://haml_lint//lib/haml_lint/version_comparer.rb#21
    def for_haml; end

    # Shortcut to create a version comparer for the current RuboCop's version
    #
    # source://haml_lint//lib/haml_lint/version_comparer.rb#17
    def for_rubocop; end
  end
end
