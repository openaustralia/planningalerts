# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `honeybadger` gem.
# Please instead update this file by running `bin/tapioca gem honeybadger`.

# typed: true

module Honeybadger
  extend ::Forwardable
  extend ::Honeybadger

  def add_breadcrumb(*args, &block); end
  def backtrace_filter(*args, &block); end
  def breadcrumbs(*args, &block); end
  def check_in(*args, &block); end
  def clear!(*args, &block); end
  def config(*args, &block); end
  def configure(*args, &block); end
  def context(*args, &block); end
  def exception_filter(*args, &block); end
  def exception_fingerprint(*args, &block); end
  def flush(*args, &block); end
  def get_context(*args, &block); end
  def init!(*args, &block); end
  def install_at_exit_callback; end
  def load_plugins!; end
  def notify(exception_or_opts, opts = T.unsafe(nil)); end
  def start(config = T.unsafe(nil)); end
  def stop(*args, &block); end
  def track_deployment(*args, &block); end
  def with_rack_env(*args, &block); end

  private

  def ignored_exception?(exception); end
end

class Honeybadger::Agent
  include ::Honeybadger::Logging::Helper
  extend ::Forwardable

  def initialize(opts = T.unsafe(nil)); end

  def add_breadcrumb(message, metadata: T.unsafe(nil), category: T.unsafe(nil)); end
  def backend(*args, &block); end
  def backtrace_filter(*args, &block); end
  def breadcrumbs; end
  def check_in(id); end
  def clear!; end
  def config; end
  def configure(*args, &block); end
  def context(context = T.unsafe(nil)); end
  def exception_filter(*args, &block); end
  def exception_fingerprint(*args, &block); end
  def flush; end
  def get_context; end
  def init!(*args, &block); end
  def notify(exception_or_opts, opts = T.unsafe(nil)); end
  def stop(force = T.unsafe(nil)); end
  def track_deployment(environment: T.unsafe(nil), revision: T.unsafe(nil), local_username: T.unsafe(nil), repository: T.unsafe(nil)); end
  def with_rack_env(rack_env, &block); end
  def worker; end

  private

  def context_manager; end
  def init_worker; end
  def push(object); end
  def send_now(object); end
  def validate_notify_opts!(opts); end
  def with_error_handling; end

  class << self
    def instance; end
    def instance=(instance); end
  end
end

Honeybadger::BINDING_HAS_SOURCE_LOCATION = T.let(T.unsafe(nil), TrueClass)

module Honeybadger::Backend
  class << self
    def for(backend); end
    def mapping; end
  end
end

class Honeybadger::Backend::BackendError < ::StandardError; end

class Honeybadger::Backend::Base
  include ::Honeybadger::Logging::Helper
  extend ::Forwardable

  def initialize(config); end

  def check_in(id); end
  def notify(feature, payload); end
  def track_deployment(payload); end

  private

  def config; end
end

class Honeybadger::Backend::Debug < ::Honeybadger::Backend::Null
  def check_in(id); end
  def notify(feature, payload); end
end

class Honeybadger::Backend::Null < ::Honeybadger::Backend::Base
  def initialize(*args); end

  def check_in(id); end
  def notify(feature, payload); end
end

class Honeybadger::Backend::Null::StubbedResponse < ::Honeybadger::Backend::Response
  def initialize; end

  def success?; end
end

class Honeybadger::Backend::Response
  def initialize(*args); end

  def body; end
  def code; end
  def error; end
  def error_message; end
  def message; end
  def success?; end

  private

  def parse_error(body); end
end

Honeybadger::Backend::Response::FRIENDLY_ERRORS = T.let(T.unsafe(nil), Hash)
Honeybadger::Backend::Response::NOT_BLANK = T.let(T.unsafe(nil), Regexp)

class Honeybadger::Backend::Server < ::Honeybadger::Backend::Base
  def initialize(config); end

  def check_in(id); end
  def notify(feature, payload); end

  private

  def payload_headers(payload); end
end

Honeybadger::Backend::Server::CHECK_IN_ENDPOINT = T.let(T.unsafe(nil), String)
Honeybadger::Backend::Server::ENDPOINTS = T.let(T.unsafe(nil), Hash)
Honeybadger::Backend::Server::HTTP_ERRORS = T.let(T.unsafe(nil), Array)

class Honeybadger::Backend::Test < ::Honeybadger::Backend::Null
  def check_in(id); end
  def check_ins; end
  def notifications; end
  def notify(feature, payload); end

  class << self
    def check_ins; end
    def notifications; end
  end
end

class Honeybadger::Backtrace
  def initialize(lines); end

  def ==(other); end
  def application_lines; end
  def as_json(options = T.unsafe(nil)); end
  def inspect; end
  def lines; end
  def to_a; end
  def to_ary; end
  def to_json(*a); end
  def to_s; end

  private

  def application_lines=(_arg0); end
  def lines=(_arg0); end

  class << self
    def parse(ruby_backtrace, opts = T.unsafe(nil)); end
    def split_multiline_backtrace(backtrace); end
  end
end

class Honeybadger::Backtrace::Line
  def initialize(file, number, method, filtered_file = T.unsafe(nil), filtered_number = T.unsafe(nil), filtered_method = T.unsafe(nil), source_radius = T.unsafe(nil)); end

  def ==(other); end
  def application?; end
  def file; end
  def filtered_file; end
  def filtered_method; end
  def filtered_number; end
  def inspect; end
  def method; end
  def number; end
  def source; end
  def to_s; end

  private

  def file=(_arg0); end
  def filtered_file=(_arg0); end
  def filtered_method=(_arg0); end
  def filtered_number=(_arg0); end
  def get_source(file, number, radius = T.unsafe(nil)); end
  def method=(_arg0); end
  def number=(_arg0); end
  def source_radius; end
  def source_radius=(_arg0); end

  class << self
    def parse(unparsed_line, opts = T.unsafe(nil)); end
  end
end

Honeybadger::Backtrace::Line::INPUT_FORMAT = T.let(T.unsafe(nil), Regexp)
module Honeybadger::Breadcrumbs; end

class Honeybadger::Breadcrumbs::ActiveSupport
  class << self
    def default_notifications; end

    private

    def active_record_connection_db_config; end
  end
end

class Honeybadger::Breadcrumbs::Breadcrumb
  include ::Comparable

  def initialize(category: T.unsafe(nil), message: T.unsafe(nil), metadata: T.unsafe(nil)); end

  def <=>(other); end
  def active; end
  def active=(_arg0); end
  def active?; end
  def category; end
  def ignore!; end
  def message; end
  def message=(_arg0); end
  def metadata; end
  def metadata=(_arg0); end
  def timestamp; end
  def to_h; end
end

class Honeybadger::Breadcrumbs::Collector
  include ::Enumerable
  extend ::Forwardable

  def initialize(config, buffer = T.unsafe(nil)); end

  def <<(breadcrumb); end
  def add!(breadcrumb); end
  def clear!(*args, &block); end
  def drop_previous_breadcrumb_if; end
  def each(*args, &block); end
  def previous(*args, &block); end
  def to_a(*args, &block); end
  def to_h; end
  def trail; end

  private

  def initialize_dup(source); end
end

class Honeybadger::Breadcrumbs::RingBuffer
  include ::Enumerable

  def initialize(buffer_size = T.unsafe(nil)); end

  def add!(item); end
  def buffer; end
  def clear!; end
  def drop; end
  def each(&blk); end
  def previous; end
  def to_a; end
end

class Honeybadger::Config
  include ::Honeybadger::Logging::Helper
  extend ::Forwardable

  def initialize(opts = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def backend; end
  def backend=(backend); end
  def backtrace_filter(&block); end
  def before_notify_hooks; end
  def ca_bundle_path; end
  def configure; end
  def connection_port; end
  def connection_protocol; end
  def debug?; end
  def detected_framework; end
  def dev?; end
  def env; end
  def env=(_arg0); end
  def exception_filter(&block); end
  def exception_fingerprint(&block); end
  def excluded_request_keys; end
  def framework; end
  def framework=(_arg0); end
  def framework_name; end
  def get(key); end
  def ignored_classes; end
  def init!(opts = T.unsafe(nil), env = T.unsafe(nil)); end
  def load!(framework: T.unsafe(nil), env: T.unsafe(nil)); end
  def load_plugin?(name); end
  def local_cert_path; end
  def log_debug?; end
  def log_level(key = T.unsafe(nil)); end
  def logger; end
  def max_queue_size; end
  def params_filters; end
  def public?; end
  def root_regexp; end
  def ruby; end
  def ruby=(_arg0); end
  def set(key, value); end
  def to_h(defaults = T.unsafe(nil)); end
  def to_hash(defaults = T.unsafe(nil)); end
  def warn_development?; end
  def yaml; end
  def yaml=(_arg0); end

  private

  def build_file_logger(path); end
  def build_logger; end
  def build_stdout_logger; end
  def config_path; end
  def config_paths; end
  def default_backend; end
  def detect_revision!; end
  def includes_token?(obj, value); end
  def init_backend!; end
  def init_logging!; end
  def load_config_from_disk; end
  def locate_absolute_path(path, root); end
  def log_path; end
  def log_stdout?; end
  def undotify_keys(hash); end
end

class Honeybadger::Config::Boolean; end
class Honeybadger::Config::ConfigError < ::StandardError; end
Honeybadger::Config::DEFAULTS = T.let(T.unsafe(nil), Hash)
Honeybadger::Config::DEFAULT_PATHS = T.let(T.unsafe(nil), Array)
Honeybadger::Config::DEVELOPMENT_ENVIRONMENTS = T.let(T.unsafe(nil), Array)
Honeybadger::Config::DOTTED_KEY = T.let(T.unsafe(nil), Regexp)

module Honeybadger::Config::Env
  class << self
    def cast_value(value, type = T.unsafe(nil)); end
    def new(env = T.unsafe(nil)); end
  end
end

Honeybadger::Config::Env::ARRAY_VALUES = T.let(T.unsafe(nil), Regexp)
Honeybadger::Config::Env::CONFIG_KEY = T.let(T.unsafe(nil), Regexp)
Honeybadger::Config::Env::CONFIG_MAPPING = T.let(T.unsafe(nil), Hash)
Honeybadger::Config::Env::IGNORED_TYPES = T.let(T.unsafe(nil), Set)
Honeybadger::Config::IGNORE_DEFAULT = T.let(T.unsafe(nil), Array)
Honeybadger::Config::IVARS = T.let(T.unsafe(nil), Array)
Honeybadger::Config::KEY_REPLACEMENT = T.let(T.unsafe(nil), Regexp)

class Honeybadger::Config::Mash
  def initialize(config, prefix: T.unsafe(nil), hash: T.unsafe(nil)); end

  def to_h; end
  def to_hash; end

  private

  def config; end
  def get(key); end
  def getter?(method_name); end
  def hash; end
  def key(method_name); end
  def mash?(method); end
  def method_missing(method_name, *args, &block); end
  def prefix; end
  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end
  def setter?(method_name); end
end

Honeybadger::Config::Mash::KEYS = T.let(T.unsafe(nil), Array)
Honeybadger::Config::NOT_BLANK = T.let(T.unsafe(nil), Regexp)
Honeybadger::Config::OPTIONS = T.let(T.unsafe(nil), Hash)

class Honeybadger::Config::Ruby < ::Honeybadger::Config::Mash
  def backend; end
  def backend=(backend); end
  def backtrace_filter(&block); end
  def before_notify(action = T.unsafe(nil), &block); end
  def exception_filter(&block); end
  def exception_fingerprint(&block); end
  def logger; end
  def logger=(logger); end

  private

  def validate_before_action(action); end
end

module Honeybadger::Config::Yaml
  class << self
    def dotify_keys(hash, key_prefix = T.unsafe(nil)); end
    def load_yaml(path); end
    def new(path, env = T.unsafe(nil)); end
  end
end

Honeybadger::Config::Yaml::DISALLOWED_KEYS = T.let(T.unsafe(nil), Array)

class Honeybadger::ContextManager
  include ::Honeybadger::Conversions

  def initialize; end

  def clear!; end
  def get_context; end
  def get_rack_env; end
  def set_context(hash); end
  def set_rack_env(env); end

  private

  def _initialize; end
  def custom; end
  def custom=(_arg0); end
  def rack_env; end
  def rack_env=(_arg0); end

  class << self
    def current; end
  end
end

module Honeybadger::Conversions
  private

  def Context(object); end

  class << self
    def Context(object); end
  end
end

Honeybadger::GEM_ROOT = T.let(T.unsafe(nil), String)
module Honeybadger::Init; end
module Honeybadger::Init::Rails; end
class Honeybadger::Init::Rails::Railtie < ::Rails::Railtie; end
module Honeybadger::Logging; end

class Honeybadger::Logging::Base
  def add(severity, msg); end
  def debug(msg); end
  def debug?; end
  def error(msg); end
  def error?; end
  def fatal(msg); end
  def fatal?; end
  def info(msg); end
  def info?; end
  def level; end
  def unknown(msg); end
  def unknown?; end
  def warn(msg); end
  def warn?; end
end

class Honeybadger::Logging::BootLogger < ::Honeybadger::Logging::Base
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  def initialize; end

  def add(severity, msg); end
  def flush(logger); end
end

class Honeybadger::Logging::ConfigLogger < ::Honeybadger::Logging::StandardLogger
  def initialize(config, logger = T.unsafe(nil)); end

  def add(severity, msg); end
  def debug?; end

  private

  def caller_location; end
  def supplement(msg, severity); end
  def suppress_debug?; end
  def suppress_tty?(severity); end
end

Honeybadger::Logging::ConfigLogger::CALLER_LOCATION = T.let(T.unsafe(nil), Regexp)
Honeybadger::Logging::ConfigLogger::DEBUG_SUPPLEMENT = T.let(T.unsafe(nil), String)
Honeybadger::Logging::ConfigLogger::INFO_SUPPLEMENT = T.let(T.unsafe(nil), String)
Honeybadger::Logging::ConfigLogger::LOCATE_CALLER_LOCATION = T.let(T.unsafe(nil), Regexp)

class Honeybadger::Logging::FormattedLogger < ::Honeybadger::Logging::StandardLogger
  def add(severity, msg, progname = T.unsafe(nil)); end

  private

  def format_message(msg); end
end

module Honeybadger::Logging::Helper
  private

  def d(msg = T.unsafe(nil)); end
  def debug(msg = T.unsafe(nil)); end
  def error(msg = T.unsafe(nil)); end
  def info(msg = T.unsafe(nil)); end
  def logger; end
  def warn(msg = T.unsafe(nil)); end
end

Honeybadger::Logging::LOGGER_PROG = T.let(T.unsafe(nil), String)
Honeybadger::Logging::PREFIX = T.let(T.unsafe(nil), String)

class Honeybadger::Logging::StandardLogger < ::Honeybadger::Logging::Base
  extend ::Forwardable

  def initialize(logger = T.unsafe(nil)); end

  def add(severity, msg, progname = T.unsafe(nil)); end
  def debug?(*args, &block); end
  def error?(*args, &block); end
  def info?(*args, &block); end
  def level(*args, &block); end
  def warn?(*args, &block); end
end

Honeybadger::MAX_EXCEPTION_CAUSES = T.let(T.unsafe(nil), Integer)
Honeybadger::NOTIFIER = T.let(T.unsafe(nil), Hash)
Honeybadger::NOT_BLANK = T.let(T.unsafe(nil), Regexp)

class Honeybadger::Notice
  include ::Honeybadger::Conversions
  extend ::Forwardable

  def initialize(config, opts = T.unsafe(nil)); end

  def action; end
  def action=(_arg0); end
  def api_key; end
  def api_key=(_arg0); end
  def as_json(*args); end
  def backtrace; end
  def backtrace=(_arg0); end
  def breadcrumbs; end
  def breadcrumbs=(_arg0); end
  def cause; end
  def cause=(cause); end
  def causes; end
  def cgi_data; end
  def cgi_data=(_arg0); end
  def component; end
  def component=(_arg0); end
  def context; end
  def context=(_arg0); end
  def controller; end
  def controller=(_arg0); end
  def details; end
  def details=(_arg0); end
  def error_class; end
  def error_class=(_arg0); end
  def error_message; end
  def error_message=(_arg0); end
  def exception; end
  def fingerprint; end
  def fingerprint=(_arg0); end
  def halt!; end
  def halted?; end
  def id; end
  def ignore?; end
  def local_variables; end
  def local_variables=(_arg0); end
  def parameters; end
  def params; end
  def params=(_arg0); end
  def session; end
  def session=(_arg0); end
  def source; end
  def tags; end
  def tags=(tags); end
  def to_json(*a); end
  def url; end
  def url=(_arg0); end

  private

  def config; end
  def construct_backtrace_filters(opts); end
  def construct_context_hash(opts, exception); end
  def construct_request_hash; end
  def construct_tags(tags); end
  def exception_attribute(attribute, default = T.unsafe(nil), &block); end
  def exception_cause(exception); end
  def exception_context(exception); end
  def fingerprint_from_opts(opts); end
  def fingerprint_hash; end
  def from_exception(attribute); end
  def ignore_by_callbacks?; end
  def ignore_by_class?(ignored_class = T.unsafe(nil)); end
  def ignore_by_origin?; end
  def local_variables_from_exception(exception, config); end
  def now; end
  def opts; end
  def params_filters; end
  def parse_backtrace(backtrace); end
  def pid; end
  def prepare_causes(causes); end
  def rack_env; end
  def rails_params_filters; end
  def request_hash; end
  def request_sanitizer; end
  def s(data); end
  def sanitized_breadcrumbs; end
  def send_local_variables?(config); end
  def stats; end
  def unwrap_causes(cause); end
  def unwrap_exception(exception); end
end

Honeybadger::Notice::BACKTRACE_FILTERS = T.let(T.unsafe(nil), Array)

class Honeybadger::Notice::Cause
  def initialize(cause); end

  def backtrace; end
  def backtrace=(_arg0); end
  def error_class; end
  def error_class=(_arg0); end
  def error_message; end
  def error_message=(_arg0); end
end

Honeybadger::Notice::GEM_ROOT_CACHE = T.let(T.unsafe(nil), Hash)
Honeybadger::Notice::PROJECT_ROOT_CACHE = T.let(T.unsafe(nil), Hash)
Honeybadger::Notice::TAG_SANITIZER = T.let(T.unsafe(nil), Regexp)
Honeybadger::Notice::TAG_SEPERATOR = T.let(T.unsafe(nil), String)
Honeybadger::PROJECT_ROOT = T.let(T.unsafe(nil), String)

class Honeybadger::Plugin
  def initialize(name); end

  def execution(&block); end
  def executions; end
  def load!(config); end
  def loaded?; end
  def name; end
  def ok?(config); end
  def requirement(&block); end
  def requirements; end
  def reset!; end

  class << self
    def instances; end
    def load!(config); end
    def name_from_caller(caller); end
    def register(name = T.unsafe(nil), &block); end
  end
end

Honeybadger::Plugin::CALLER_FILE = T.let(T.unsafe(nil), Regexp)

class Honeybadger::Plugin::Execution
  extend ::Forwardable

  def initialize(config, &block); end

  def call; end
  def logger(*args, &block); end

  private

  def block; end
  def config; end
end

module Honeybadger::Plugins; end
Honeybadger::RELATIVE_ROOT = T.let(T.unsafe(nil), Regexp)
module Honeybadger::Rack; end

class Honeybadger::Rack::ErrorNotifier
  extend ::Forwardable

  def initialize(app, agent = T.unsafe(nil)); end

  def call(env); end
  def config(*args, &block); end
  def logger(*args, &block); end

  private

  def agent; end
  def framework_exception(env); end
  def ignored_user_agent?(env); end
  def notify_honeybadger(exception, env); end
end

class Honeybadger::Rack::UserFeedback
  extend ::Forwardable

  def initialize(app, agent = T.unsafe(nil)); end

  def action; end
  def call(env); end
  def config(*args, &block); end
  def custom_template_file; end
  def custom_template_file?; end
  def logger(*args, &block); end
  def render_form(error_id, action = T.unsafe(nil)); end
  def template_file; end

  private

  def agent; end
end

class Honeybadger::Rack::UserInformer
  extend ::Forwardable

  def initialize(app, agent = T.unsafe(nil)); end

  def call(env); end
  def config(*args, &block); end
  def logger(*args, &block); end
  def replacement(with); end

  private

  def agent; end
end

module Honeybadger::RakeHandler
  def display_error_message_with_honeybadger(ex); end
  def reconstruct_command_line; end

  class << self
    def included(klass); end
  end
end

module Honeybadger::RakeHandler::Rake087Methods
  def display_error_message(ex); end
  def standard_exception_handling; end
end

Honeybadger::STRING_EMPTY = T.let(T.unsafe(nil), String)
module Honeybadger::Util; end

class Honeybadger::Util::HTTP
  include ::Honeybadger::Logging::Helper
  extend ::Forwardable

  def initialize(config); end

  def get(endpoint); end
  def post(endpoint, payload, headers = T.unsafe(nil)); end

  private

  def compress(string, level = T.unsafe(nil)); end
  def config; end
  def http_connection; end
  def http_headers(headers = T.unsafe(nil)); end
  def setup_http_connection; end
end

Honeybadger::Util::HTTP::ERRORS = T.let(T.unsafe(nil), Array)
Honeybadger::Util::HTTP::HEADERS = T.let(T.unsafe(nil), Hash)

module Honeybadger::Util::RequestHash
  class << self
    def extract_cgi_data(request); end
    def extract_params(request); end
    def extract_session(request); end
    def extract_url(request); end
    def from_env(env); end
  end
end

Honeybadger::Util::RequestHash::CGI_WHITELIST = T.let(T.unsafe(nil), Array)
Honeybadger::Util::RequestHash::HTTP_HEADER_PREFIX = T.let(T.unsafe(nil), String)

module Honeybadger::Util::RequestPayload
  class << self
    def build(opts = T.unsafe(nil)); end
  end
end

Honeybadger::Util::RequestPayload::DEFAULTS = T.let(T.unsafe(nil), Hash)
Honeybadger::Util::RequestPayload::HTTP_COOKIE_KEY = T.let(T.unsafe(nil), String)
Honeybadger::Util::RequestPayload::KEYS = T.let(T.unsafe(nil), Array)

class Honeybadger::Util::Revision
  class << self
    def detect(root = T.unsafe(nil)); end

    private

    def from_capistrano(root); end
    def from_git; end
    def from_heroku; end
  end
end

class Honeybadger::Util::SQL
  class << self
    def force_utf_8(string); end
    def obfuscate(sql, adapter); end
  end
end

Honeybadger::Util::SQL::DQuotedData = T.let(T.unsafe(nil), Regexp)
Honeybadger::Util::SQL::DoubleQuoters = T.let(T.unsafe(nil), Regexp)
Honeybadger::Util::SQL::EmptyReplacement = T.let(T.unsafe(nil), String)
Honeybadger::Util::SQL::EscapedQuotes = T.let(T.unsafe(nil), Regexp)
Honeybadger::Util::SQL::Newline = T.let(T.unsafe(nil), Regexp)
Honeybadger::Util::SQL::NumericData = T.let(T.unsafe(nil), Regexp)
Honeybadger::Util::SQL::Replacement = T.let(T.unsafe(nil), String)
Honeybadger::Util::SQL::SQuotedData = T.let(T.unsafe(nil), Regexp)

class Honeybadger::Util::Sanitizer
  def initialize(max_depth: T.unsafe(nil), filters: T.unsafe(nil)); end

  def filter_cookies(raw_cookies); end
  def filter_url(url); end
  def sanitize(data, depth = T.unsafe(nil), stack = T.unsafe(nil), parents = T.unsafe(nil)); end

  private

  def basic_object?(object); end
  def blocks; end
  def can_dup?(obj); end
  def deep_regexps; end
  def filter_key?(key, parents = T.unsafe(nil)); end
  def filters?; end
  def inspected?(string); end
  def max_depth; end
  def recursive?(data); end
  def regexps; end
  def sanitize_string(string); end
  def valid_encoding(string); end
  def valid_encoding?(string); end

  class << self
    def sanitize(data); end
  end
end

Honeybadger::Util::Sanitizer::BASIC_OBJECT = T.let(T.unsafe(nil), String)
Honeybadger::Util::Sanitizer::COOKIE_PAIRS = T.let(T.unsafe(nil), Regexp)
Honeybadger::Util::Sanitizer::COOKIE_PAIR_SEP = T.let(T.unsafe(nil), String)
Honeybadger::Util::Sanitizer::COOKIE_SEP = T.let(T.unsafe(nil), String)
Honeybadger::Util::Sanitizer::DEPTH = T.let(T.unsafe(nil), String)
Honeybadger::Util::Sanitizer::ENCODE_OPTS = T.let(T.unsafe(nil), Hash)
Honeybadger::Util::Sanitizer::FILTERED = T.let(T.unsafe(nil), String)
Honeybadger::Util::Sanitizer::IMMUTABLE = T.let(T.unsafe(nil), Array)
Honeybadger::Util::Sanitizer::MAX_STRING_SIZE = T.let(T.unsafe(nil), Integer)
Honeybadger::Util::Sanitizer::RAISED = T.let(T.unsafe(nil), String)
Honeybadger::Util::Sanitizer::RECURSION = T.let(T.unsafe(nil), String)
Honeybadger::Util::Sanitizer::TRUNCATED = T.let(T.unsafe(nil), String)
Honeybadger::Util::Sanitizer::VALID_ENCODINGS = T.let(T.unsafe(nil), Array)

class Honeybadger::Util::Stats
  class << self
    def all; end
    def load; end
    def memory; end

    private

    def run; end
    def run_loadavg; end
    def run_meminfo; end
  end
end

Honeybadger::Util::Stats::HAS_LOAD = T.let(T.unsafe(nil), TrueClass)
Honeybadger::Util::Stats::HAS_MEM = T.let(T.unsafe(nil), TrueClass)
Honeybadger::VERSION = T.let(T.unsafe(nil), String)

class Honeybadger::Worker
  include ::Honeybadger::Logging::Helper
  extend ::Forwardable

  def initialize(config); end

  def backend(*args, &block); end
  def flush; end
  def push(msg); end
  def send_now(msg); end
  def shutdown(force = T.unsafe(nil)); end
  def start; end

  private

  def calc_throttle_interval; end
  def can_start?; end
  def config; end
  def dec_throttle; end
  def handle_response(msg, response); end
  def inc_throttle; end
  def kill!; end
  def marker; end
  def mutex; end
  def notify_backend(payload); end
  def pid; end
  def queue; end
  def release_marker; end
  def run; end
  def shutdown?; end
  def signal_marker(marker); end
  def start_at; end
  def suspend(interval); end
  def suspended?; end
  def thread; end
  def throttle; end
  def throttle_interval; end
  def throttled?; end
  def work(msg); end
end

Honeybadger::Worker::BASE_THROTTLE = T.let(T.unsafe(nil), Float)
Honeybadger::Worker::SHUTDOWN = T.let(T.unsafe(nil), Symbol)
class Honeybadger::Worker::Thread < ::Thread; end
