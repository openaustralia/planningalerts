# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `http` gem.
# Please instead update this file by running `bin/tapioca gem http`.

# HTTP should be easy
#
# source://http//lib/http/errors.rb#3
module HTTP
  extend ::HTTP::Chainable

  class << self
    # HTTP[:accept => 'text/html'].get(...)
    #
    # source://http//lib/http/chainable.rb#180
    def [](headers); end
  end
end

# source://http//lib/http/content_type.rb#6
HTTP::CHARSET_RE = T.let(T.unsafe(nil), Regexp)

# source://http//lib/http/chainable.rb#8
module HTTP::Chainable
  # Accept the given MIME type(s)
  #
  # @param type
  #
  # source://http//lib/http/chainable.rb#196
  def accept(type); end

  # Make a request with the given Authorization header
  #
  # @param value [#to_s] Authorization header value
  #
  # source://http//lib/http/chainable.rb#202
  def auth(value); end

  # Make a request with the given Basic authorization header
  #
  # @option opts
  # @option opts
  # @param opts [#fetch]
  # @see http://tools.ietf.org/html/rfc2617
  #
  # source://http//lib/http/chainable.rb#211
  def basic_auth(opts); end

  # Prepare an HTTP request with the given verb
  #
  # source://http//lib/http/chainable.rb#80
  def build_request(*args); end

  # Convert to a transparent TCP/IP tunnel
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  #
  # source://http//lib/http/chainable.rb#61
  def connect(uri, options = T.unsafe(nil)); end

  # Make a request with the given cookies
  #
  # source://http//lib/http/chainable.rb#185
  def cookies(cookies); end

  # Get options for HTTP
  #
  # @return [HTTP::Options]
  #
  # source://http//lib/http/chainable.rb#220
  def default_options; end

  # Set options for HTTP
  #
  # @param opts
  # @return [HTTP::Options]
  #
  # source://http//lib/http/chainable.rb#227
  def default_options=(opts); end

  # Delete a resource
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  #
  # source://http//lib/http/chainable.rb#40
  def delete(uri, options = T.unsafe(nil)); end

  # Force a specific encoding for response body
  #
  # source://http//lib/http/chainable.rb#190
  def encoding(encoding); end

  # Make client follow redirects.
  #
  # @param opts
  # @return [HTTP::Client]
  # @see Redirector#initialize
  #
  # source://http//lib/http/chainable.rb#174
  def follow(options = T.unsafe(nil)); end

  # Get a resource
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  #
  # source://http//lib/http/chainable.rb#19
  def get(uri, options = T.unsafe(nil)); end

  # Request a get sans response body
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  #
  # source://http//lib/http/chainable.rb#12
  def head(uri, options = T.unsafe(nil)); end

  # Make a request with the given headers
  #
  # @param headers
  #
  # source://http//lib/http/chainable.rb#180
  def headers(headers); end

  # Set TCP_NODELAY on the socket
  #
  # source://http//lib/http/chainable.rb#232
  def nodelay; end

  # Return the methods supported on the given URI
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  #
  # source://http//lib/http/chainable.rb#54
  def options(uri, options = T.unsafe(nil)); end

  # Apply partial modifications to a resource
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  #
  # source://http//lib/http/chainable.rb#68
  def patch(uri, options = T.unsafe(nil)); end

  # @overload persistent
  # @overload persistent
  #
  # source://http//lib/http/chainable.rb#143
  def persistent(host, timeout: T.unsafe(nil)); end

  # Post to a resource
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  #
  # source://http//lib/http/chainable.rb#26
  def post(uri, options = T.unsafe(nil)); end

  # Put to a resource
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  #
  # source://http//lib/http/chainable.rb#33
  def put(uri, options = T.unsafe(nil)); end

  # Make an HTTP request with the given verb
  #
  # source://http//lib/http/chainable.rb#74
  def request(*args); end

  # Make a request through an HTTP proxy
  #
  # @param proxy [Array]
  # @raise [Request::Error] if HTTP proxy is invalid
  #
  # source://http//lib/http/chainable.rb#155
  def through(*proxy); end

  # @overload timeout
  # @overload timeout
  #
  # source://http//lib/http/chainable.rb#93
  def timeout(options); end

  # Echo the request back to the client
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  #
  # source://http//lib/http/chainable.rb#47
  def trace(uri, options = T.unsafe(nil)); end

  # Turn on given features. Available features are:
  # * auto_inflate
  # * auto_deflate
  #
  # @param features
  #
  # source://http//lib/http/chainable.rb#240
  def use(*features); end

  # Make a request through an HTTP proxy
  #
  # @param proxy [Array]
  # @raise [Request::Error] if HTTP proxy is invalid
  #
  # source://http//lib/http/chainable.rb#155
  def via(*proxy); end

  private

  # source://http//lib/http/chainable.rb#247
  def branch(options); end
end

# Clients make requests and receive responses
#
# source://http//lib/http/client.rb#15
class HTTP::Client
  include ::HTTP::Chainable
  extend ::Forwardable

  # @return [Client] a new instance of Client
  #
  # source://http//lib/http/client.rb#21
  def initialize(default_options = T.unsafe(nil)); end

  # source://http//lib/http/client.rb#66
  def __perform__(req, options); end

  # Prepare an HTTP request
  #
  # source://http//lib/http/client.rb#40
  def build_request(verb, uri, opts = T.unsafe(nil)); end

  # source://http//lib/http/client.rb#101
  def close; end

  # Perform a single (no follow) HTTP request
  #
  # source://webmock/3.18.1/lib/webmock/http_lib_adapters/http_rb/client.rb#5
  def perform(request, options); end

  # @return [Boolean] whenever client is persistent
  # @see Options#persistent?
  #
  # source://forwardable/1.3.1/forwardable.rb#226
  def persistent?(*args, &block); end

  # Make an HTTP request
  #
  # source://http//lib/http/client.rb#28
  def request(verb, uri, opts = T.unsafe(nil)); end

  # source://webmock/3.18.1/lib/webmock/http_lib_adapters/http_rb/client.rb#11
  def webmock_enabled?; end

  private

  # source://http//lib/http/client.rb#182
  def make_form_data(form); end

  # Create the request body object to send
  #
  # source://http//lib/http/client.rb#167
  def make_request_body(opts, headers); end

  # Creates request headers with cookies (if any) merged in
  #
  # source://http//lib/http/client.rb#150
  def make_request_headers(opts); end

  # Merges query params if needed
  #
  # @param uri [#to_s]
  # @return [URI]
  #
  # source://http//lib/http/client.rb#128
  def make_request_uri(uri, opts); end

  # Verify our request isn't going to be made against another URI
  #
  # source://http//lib/http/client.rb#110
  def verify_connection!(uri); end
end

# source://http//lib/http/client.rb#19
HTTP::Client::HTTP_OR_HTTPS_RE = T.let(T.unsafe(nil), Regexp)

# A connection to the HTTP server
#
# source://http//lib/http/connection.rb#10
class HTTP::Connection
  extend ::Forwardable

  # @param req [HTTP::Request]
  # @param options [HTTP::Options]
  # @raise [HTTP::ConnectionError] when failed to connect
  # @return [Connection] a new instance of Connection
  #
  # source://http//lib/http/connection.rb#32
  def initialize(req, options); end

  # Close the connection
  #
  # @return [void]
  #
  # source://http//lib/http/connection.rb#124
  def close; end

  # Whether our connection has expired
  #
  # @return [Boolean]
  #
  # source://http//lib/http/connection.rb#139
  def expired?; end

  # @return [Boolean] whenever proxy connect failed
  #
  # source://http//lib/http/connection.rb#62
  def failed_proxy_connect?; end

  # Callback for when we've reached the end of a response
  #
  # @return [void]
  #
  # source://http//lib/http/connection.rb#112
  def finish_response; end

  # source://forwardable/1.3.1/forwardable.rb#226
  def headers(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def http_version(*args, &block); end

  # Whether we're keeping the conn alive
  #
  # @return [Boolean]
  #
  # source://http//lib/http/connection.rb#133
  def keep_alive?; end

  # Returned after HTTP CONNECT (via proxy)
  #
  # source://http//lib/http/connection.rb#27
  def proxy_response_headers; end

  # Reads data from socket up until headers are loaded
  #
  # @return [void]
  #
  # source://http//lib/http/connection.rb#101
  def read_headers!; end

  # Read a chunk of the body
  #
  # @return [String] data chunk
  # @return [nil] when no more data left
  #
  # source://http//lib/http/connection.rb#86
  def readpartial(size = T.unsafe(nil)); end

  # Send a request to the server
  #
  # @param req [Request] Request to send to the server
  # @raise [StateError]
  # @return [nil]
  #
  # source://http//lib/http/connection.rb#70
  def send_request(req); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def status_code(*args, &block); end

  private

  # Feeds some more data into parser
  #
  # @return [void]
  #
  # source://http//lib/http/connection.rb#209
  def read_more(size); end

  # Resets expiration of persistent connection.
  #
  # @return [void]
  #
  # source://http//lib/http/connection.rb#186
  def reset_timer; end

  # Open tunnel through proxy
  #
  # source://http//lib/http/connection.rb#162
  def send_proxy_connect_request(req); end

  # Store whether the connection should be kept alive.
  # Once we reset the parser, we lose all of this state.
  #
  # @return [void]
  #
  # source://http//lib/http/connection.rb#193
  def set_keep_alive; end

  # Sets up SSL context and starts TLS if needed.
  #
  # @param req [HTTP::Request]
  # @param options [HTTP::Options]
  # @return [void]
  #
  # source://http//lib/http/connection.rb#148
  def start_tls(req, options); end
end

# Attempt to read this much data
#
# source://http//lib/http/connection.rb#18
HTTP::Connection::BUFFER_SIZE = T.let(T.unsafe(nil), Integer)

# source://http//lib/http/connection.rb#15
HTTP::Connection::CLOSE = T.let(T.unsafe(nil), String)

# HTTP/1.0
#
# source://http//lib/http/connection.rb#21
HTTP::Connection::HTTP_1_0 = T.let(T.unsafe(nil), String)

# HTTP/1.1
#
# source://http//lib/http/connection.rb#24
HTTP::Connection::HTTP_1_1 = T.let(T.unsafe(nil), String)

# Allowed values for CONNECTION header
#
# source://http//lib/http/connection.rb#14
HTTP::Connection::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# Generic Connection error
#
# source://http//lib/http/errors.rb#8
class HTTP::ConnectionError < ::HTTP::Error; end

# source://http//lib/http/content_type.rb#4
class HTTP::ContentType < ::Struct
  # Returns the value of attribute charset
  #
  # @return [Object] the current value of charset
  def charset; end

  # Sets the attribute charset
  #
  # @param value [Object] the value to set the attribute charset to.
  # @return [Object] the newly set value
  #
  # source://http//lib/http/content_type.rb#4
  def charset=(_); end

  # Returns the value of attribute mime_type
  #
  # @return [Object] the current value of mime_type
  def mime_type; end

  # Sets the attribute mime_type
  #
  # @param value [Object] the value to set the attribute mime_type to.
  # @return [Object] the newly set value
  #
  # source://http//lib/http/content_type.rb#4
  def mime_type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end

    # Parse string and return ContentType struct
    #
    # source://http//lib/http/content_type.rb#10
    def parse(str); end

    private

    # source://http//lib/http/content_type.rb#23
    def charset(str); end

    # source://http//lib/http/content_type.rb#17
    def mime_type(str); end
  end
end

# Generic error
#
# source://http//lib/http/errors.rb#5
class HTTP::Error < ::StandardError; end

# source://http//lib/http/feature.rb#4
class HTTP::Feature
  # @return [Feature] a new instance of Feature
  #
  # source://http//lib/http/feature.rb#5
  def initialize(opts = T.unsafe(nil)); end

  # source://http//lib/http/feature.rb#9
  def wrap_request(request); end

  # source://http//lib/http/feature.rb#13
  def wrap_response(response); end
end

# source://http//lib/http/features/auto_inflate.rb#6
module HTTP::Features; end

# source://http//lib/http/features/auto_deflate.rb#10
class HTTP::Features::AutoDeflate < ::HTTP::Feature
  # @raise [Error]
  # @return [AutoDeflate] a new instance of AutoDeflate
  #
  # source://http//lib/http/features/auto_deflate.rb#13
  def initialize(**_arg0); end

  # source://http//lib/http/features/auto_deflate.rb#40
  def deflated_body(body); end

  # Returns the value of attribute method.
  #
  # source://http//lib/http/features/auto_deflate.rb#11
  def method; end

  # source://http//lib/http/features/auto_deflate.rb#21
  def wrap_request(request); end
end

# source://http//lib/http/features/auto_deflate.rb#51
class HTTP::Features::AutoDeflate::CompressedBody < ::HTTP::Request::Body
  # @return [CompressedBody] a new instance of CompressedBody
  #
  # source://http//lib/http/features/auto_deflate.rb#52
  def initialize(uncompressed_body); end

  # source://http//lib/http/features/auto_deflate.rb#62
  def each(&block); end

  # source://http//lib/http/features/auto_deflate.rb#57
  def size; end

  private

  # source://http//lib/http/features/auto_deflate.rb#84
  def compress_all!; end

  # source://http//lib/http/features/auto_deflate.rb#76
  def compressed_each; end
end

# source://http//lib/http/features/auto_deflate.rb#110
class HTTP::Features::AutoDeflate::DeflatedBody < ::HTTP::Features::AutoDeflate::CompressedBody
  # source://http//lib/http/features/auto_deflate.rb#111
  def compress; end
end

# source://http//lib/http/features/auto_deflate.rb#91
class HTTP::Features::AutoDeflate::GzippedBody < ::HTTP::Features::AutoDeflate::CompressedBody
  # source://http//lib/http/features/auto_deflate.rb#92
  def compress(&block); end
end

# source://http//lib/http/features/auto_deflate.rb#99
class HTTP::Features::AutoDeflate::GzippedBody::BlockIO
  # @return [BlockIO] a new instance of BlockIO
  #
  # source://http//lib/http/features/auto_deflate.rb#100
  def initialize(block); end

  # source://http//lib/http/features/auto_deflate.rb#104
  def write(data); end
end

# source://http//lib/http/features/auto_inflate.rb#7
class HTTP::Features::AutoInflate < ::HTTP::Feature
  # source://http//lib/http/features/auto_inflate.rb#28
  def stream_for(connection); end

  # source://http//lib/http/features/auto_inflate.rb#11
  def wrap_response(response); end

  private

  # @return [Boolean]
  #
  # source://http//lib/http/features/auto_inflate.rb#34
  def supported_encoding?(response); end
end

# source://http//lib/http/features/auto_inflate.rb#8
HTTP::Features::AutoInflate::SUPPORTED_ENCODING = T.let(T.unsafe(nil), Set)

# Instrument requests and responses. Expects an
# ActiveSupport::Notifications-compatible instrumenter. Defaults to use a
# namespace of 'http' which may be overridden with a `:namespace` param.
# Emits a single event like `"request.{namespace}"`, eg `"request.http"`.
# Be sure to specify the instrumenter when enabling the feature:
#
#    HTTP
#      .use(instrumentation: {instrumenter: ActiveSupport::Notifications.instrumenter})
#      .get("https://example.com/")
#
# Emits two events on every request:
#
#  * `start_request.http` before the request is made, so you can log the reqest being started
#  * `request.http` after the response is recieved, and contains `start`
#    and `finish` so the duration of the request can be calculated.
#
# source://http//lib/http/features/instrumentation.rb#21
class HTTP::Features::Instrumentation < ::HTTP::Feature
  # @return [Instrumentation] a new instance of Instrumentation
  #
  # source://http//lib/http/features/instrumentation.rb#24
  def initialize(instrumenter: T.unsafe(nil), namespace: T.unsafe(nil)); end

  # Returns the value of attribute instrumenter.
  #
  # source://http//lib/http/features/instrumentation.rb#22
  def instrumenter; end

  # Returns the value of attribute name.
  #
  # source://http//lib/http/features/instrumentation.rb#22
  def name; end

  # source://http//lib/http/features/instrumentation.rb#29
  def wrap_request(request); end

  # source://http//lib/http/features/instrumentation.rb#37
  def wrap_response(response); end
end

# source://http//lib/http/features/instrumentation.rb#44
class HTTP::Features::Instrumentation::NullInstrumenter
  # source://http//lib/http/features/instrumentation.rb#58
  def finish(_name, _payload); end

  # source://http//lib/http/features/instrumentation.rb#45
  def instrument(name, payload = T.unsafe(nil)); end

  # source://http//lib/http/features/instrumentation.rb#54
  def start(_name, _payload); end
end

# Log requests and responses. Request verb and uri, and Response status are
# logged at `info`, and the headers and bodies of both are logged at
# `debug`. Be sure to specify the logger when enabling the feature:
#
#    HTTP.use(logging: {logger: Logger.new(STDOUT)}).get("https://example.com/")
#
# source://http//lib/http/features/logging.rb#11
class HTTP::Features::Logging < ::HTTP::Feature
  # @return [Logging] a new instance of Logging
  #
  # source://http//lib/http/features/logging.rb#14
  def initialize(logger: T.unsafe(nil)); end

  # Returns the value of attribute logger.
  #
  # source://http//lib/http/features/logging.rb#12
  def logger; end

  # source://http//lib/http/features/logging.rb#18
  def wrap_request(request); end

  # source://http//lib/http/features/logging.rb#29
  def wrap_response(response); end
end

# source://http//lib/http/features/logging.rb#40
class HTTP::Features::Logging::NullLogger
  # source://http//lib/http/features/logging.rb#42
  def debug(*_args); end

  # source://http//lib/http/features/logging.rb#46
  def debug?; end

  # source://http//lib/http/features/logging.rb#42
  def error(*_args); end

  # source://http//lib/http/features/logging.rb#46
  def error?; end

  # source://http//lib/http/features/logging.rb#42
  def fatal(*_args); end

  # source://http//lib/http/features/logging.rb#46
  def fatal?; end

  # source://http//lib/http/features/logging.rb#42
  def info(*_args); end

  # source://http//lib/http/features/logging.rb#46
  def info?; end

  # source://http//lib/http/features/logging.rb#42
  def warn(*_args); end

  # source://http//lib/http/features/logging.rb#46
  def warn?; end
end

# source://http//lib/http/features/normalize_uri.rb#7
class HTTP::Features::NormalizeUri < ::HTTP::Feature
  # @return [NormalizeUri] a new instance of NormalizeUri
  #
  # source://http//lib/http/features/normalize_uri.rb#10
  def initialize(normalizer: T.unsafe(nil)); end

  # Returns the value of attribute normalizer.
  #
  # source://http//lib/http/features/normalize_uri.rb#8
  def normalizer; end
end

# Header value is of unexpected format (similar to Net::HTTPHeaderSyntaxError)
#
# source://http//lib/http/errors.rb#23
class HTTP::HeaderError < ::HTTP::Error; end

# HTTP Headers container.
#
# source://http//lib/http/headers/mixin.rb#6
class HTTP::Headers
  include ::Enumerable
  extend ::Forwardable

  # Class constructor.
  #
  # @return [Headers] a new instance of Headers
  #
  # source://http//lib/http/headers.rb#23
  def initialize; end

  # Compares headers to another Headers or Array of key/value pairs
  #
  # @return [Boolean]
  #
  # source://http//lib/http/headers.rb#119
  def ==(other); end

  # Smart version of {#get}.
  #
  # @return [nil] if header was not set
  # @return [String] if header has exactly one value
  # @return [Array<String>] if header has more than one value
  #
  # source://http//lib/http/headers.rb#69
  def [](name); end

  # Sets header.
  #
  # @return [void]
  #
  # source://http//lib/http/headers.rb#31
  def []=(name, value); end

  # Appends header.
  #
  # @param name [#to_s] header name
  # @param value [Array<#to_s>, #to_s] header value(s) to be appended
  # @return [void]
  #
  # source://http//lib/http/headers.rb#51
  def add(name, value); end

  # Removes header.
  #
  # @param name [#to_s] header name
  # @return [void]
  #
  # source://http//lib/http/headers.rb#41
  def delete(name); end

  # Calls the given block once for each key/value pair in headers container.
  #
  # @return [Enumerator] if no block given
  # @return [Headers] self-reference
  #
  # source://http//lib/http/headers.rb#128
  def each; end

  # Returns `true` if `self` has no key/value pairs
  #
  # @return [Boolean]
  #
  # source://forwardable/1.3.1/forwardable.rb#226
  def empty?(*args, &block); end

  # Returns list of header values if any.
  #
  # @return [Array<String>]
  #
  # source://http//lib/http/headers.rb#59
  def get(name); end

  # Compute a hash-code for this headers container.
  # Two conatiners with the same content will have the same hash code.
  #
  # @return [Fixnum]
  # @see http://www.ruby-doc.org/core/Object.html#method-i-hash
  #
  # source://forwardable/1.3.1/forwardable.rb#226
  def hash(*args, &block); end

  # Tells whenever header with given `name` is set or not.
  #
  # @return [Boolean]
  #
  # source://http//lib/http/headers.rb#82
  def include?(name); end

  # Returns human-readable representation of `self` instance.
  #
  # @return [String]
  #
  # source://http//lib/http/headers.rb#105
  def inspect; end

  # Returns list of header names.
  #
  # @return [Array<String>]
  #
  # source://http//lib/http/headers.rb#112
  def keys; end

  # Returns new instance with `other` headers merged in.
  #
  # @return [Headers]
  # @see #merge!
  #
  # source://http//lib/http/headers.rb#168
  def merge(other); end

  # Merges `other` headers into `self`.
  #
  # @return [void]
  # @see #merge
  #
  # source://http//lib/http/headers.rb#160
  def merge!(other); end

  # Sets header.
  #
  # @param name [#to_s] header name
  # @param value [Array<#to_s>, #to_s] header value(s) to be appended
  # @return [void]
  #
  # source://http//lib/http/headers.rb#31
  def set(name, value); end

  # Returns headers key/value pairs.
  #
  # @return [Array<[String, String]>]
  #
  # source://http//lib/http/headers.rb#98
  def to_a; end

  # Returns Rack-compatible headers Hash
  #
  # @return [Hash]
  #
  # source://http//lib/http/headers.rb#90
  def to_h; end

  # Returns Rack-compatible headers Hash
  #
  # @return [Hash]
  #
  # source://http//lib/http/headers.rb#90
  def to_hash; end

  private

  # Properly clones internal key/value storage.
  #
  # @api private
  #
  # source://http//lib/http/headers.rb#151
  def initialize_copy(orig); end

  # Transforms `name` to canonical HTTP header capitalization
  #
  # @param name [String]
  # @raise [HeaderError] if normalized name does not
  #   match {HEADER_NAME_RE}
  # @return [String] canonical HTTP header name
  #
  # source://http//lib/http/headers.rb#203
  def normalize_header(name); end

  class << self
    # Coerces given `object` into Headers.
    #
    # @param object [#to_hash, #to_h, #to_a]
    # @raise [Error] if object can't be coerced
    # @return [Headers]
    #
    # source://http//lib/http/headers.rb#178
    def [](object); end

    # Coerces given `object` into Headers.
    #
    # @param object [#to_hash, #to_h, #to_a]
    # @raise [Error] if object can't be coerced
    # @return [Headers]
    #
    # source://http//lib/http/headers.rb#178
    def coerce(object); end
  end
end

# Content-Types that are acceptable for the response.
#
# source://http//lib/http/headers/known.rb#6
HTTP::Headers::ACCEPT = T.let(T.unsafe(nil), String)

# Content-codings that are acceptable in the response.
#
# source://http//lib/http/headers/known.rb#9
HTTP::Headers::ACCEPT_ENCODING = T.let(T.unsafe(nil), String)

# The age the object has been in a proxy cache in seconds.
#
# source://http//lib/http/headers/known.rb#12
HTTP::Headers::AGE = T.let(T.unsafe(nil), String)

# Authentication credentials for HTTP authentication.
#
# source://http//lib/http/headers/known.rb#15
HTTP::Headers::AUTHORIZATION = T.let(T.unsafe(nil), String)

# Used to specify directives that must be obeyed by all caching mechanisms
# along the request-response chain.
#
# source://http//lib/http/headers/known.rb#19
HTTP::Headers::CACHE_CONTROL = T.let(T.unsafe(nil), String)

# Matches HTTP header names when in "Canonical-Http-Format"
#
# source://http//lib/http/headers.rb#16
HTTP::Headers::CANONICAL_NAME_RE = T.let(T.unsafe(nil), Regexp)

# Matches valid header field name according to RFC.
#
# @see http://tools.ietf.org/html/rfc7230#section-3.2
#
# source://http//lib/http/headers.rb#20
HTTP::Headers::COMPLIANT_NAME_RE = T.let(T.unsafe(nil), Regexp)

# Control options for the current connection and list
# of hop-by-hop request fields.
#
# source://http//lib/http/headers/known.rb#26
HTTP::Headers::CONNECTION = T.let(T.unsafe(nil), String)

# Indicates what additional content codings have been applied to the
# entity-body.
#
# source://http//lib/http/headers/known.rb#77
HTTP::Headers::CONTENT_ENCODING = T.let(T.unsafe(nil), String)

# The length of the request body in octets (8-bit bytes).
#
# source://http//lib/http/headers/known.rb#29
HTTP::Headers::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# The MIME type of the body of the request
# (used with POST and PUT requests).
#
# source://http//lib/http/headers/known.rb#33
HTTP::Headers::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# An HTTP cookie previously sent by the server with Set-Cookie.
#
# source://http//lib/http/headers/known.rb#22
HTTP::Headers::COOKIE = T.let(T.unsafe(nil), String)

# The date and time that the message was sent (in "HTTP-date" format as
# defined by RFC 7231 Date/Time Formats).
#
# source://http//lib/http/headers/known.rb#37
HTTP::Headers::DATE = T.let(T.unsafe(nil), String)

# An identifier for a specific version of a resource,
# often a message digest.
#
# source://http//lib/http/headers/known.rb#41
HTTP::Headers::ETAG = T.let(T.unsafe(nil), String)

# Gives the date/time after which the response is considered stale (in
# "HTTP-date" format as defined by RFC 7231).
#
# source://http//lib/http/headers/known.rb#45
HTTP::Headers::EXPIRES = T.let(T.unsafe(nil), String)

# The domain name of the server (for virtual hosting), and the TCP port
# number on which the server is listening. The port number may be omitted
# if the port is the standard port for the service requested.
#
# source://http//lib/http/headers/known.rb#50
HTTP::Headers::HOST = T.let(T.unsafe(nil), String)

# Allows a 304 Not Modified to be returned if content is unchanged.
#
# source://http//lib/http/headers/known.rb#53
HTTP::Headers::IF_MODIFIED_SINCE = T.let(T.unsafe(nil), String)

# Allows a 304 Not Modified to be returned if content is unchanged.
#
# source://http//lib/http/headers/known.rb#56
HTTP::Headers::IF_NONE_MATCH = T.let(T.unsafe(nil), String)

# The last modified date for the requested object (in "HTTP-date" format as
# defined by RFC 7231).
#
# source://http//lib/http/headers/known.rb#60
HTTP::Headers::LAST_MODIFIED = T.let(T.unsafe(nil), String)

# Used in redirection, or when a new resource has been created.
#
# source://http//lib/http/headers/known.rb#63
HTTP::Headers::LOCATION = T.let(T.unsafe(nil), String)

# Provides shared behavior for {HTTP::Request} and {HTTP::Response}.
# Expects `@headers` to be an instance of {HTTP::Headers}.
#
# @example Usage
#
#   class MyHttpRequest
#   include HTTP::Headers::Mixin
#
#   def initialize
#   @headers = HTTP::Headers.new
#   end
#   end
#
# source://http//lib/http/headers/mixin.rb#19
module HTTP::Headers::Mixin
  extend ::Forwardable

  # Smart version of {#get}.
  #
  # @return [nil] if header was not set
  # @return [String] if header has exactly one value
  # @return [Array<String>] if header has more than one value
  #
  # source://forwardable/1.3.1/forwardable.rb#226
  def [](*args, &block); end

  # Sets header.
  #
  # @return [void]
  #
  # source://forwardable/1.3.1/forwardable.rb#226
  def []=(*args, &block); end

  # @return [HTTP::Headers]
  #
  # source://http//lib/http/headers/mixin.rb#23
  def headers; end
end

# Authorization credentials for connecting to a proxy.
#
# source://http//lib/http/headers/known.rb#66
HTTP::Headers::PROXY_AUTHORIZATION = T.let(T.unsafe(nil), String)

# An HTTP cookie.
#
# source://http//lib/http/headers/known.rb#69
HTTP::Headers::SET_COOKIE = T.let(T.unsafe(nil), String)

# The form of encoding used to safely transfer the entity to the user.
# Currently defined methods are: chunked, compress, deflate, gzip, identity.
#
# source://http//lib/http/headers/known.rb#73
HTTP::Headers::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

# The user agent string of the user agent.
#
# source://http//lib/http/headers/known.rb#80
HTTP::Headers::USER_AGENT = T.let(T.unsafe(nil), String)

# Tells downstream proxies how to match future request headers to decide
# whether the cached response can be used rather than requesting a fresh
# one from the origin server.
#
# source://http//lib/http/headers/known.rb#85
HTTP::Headers::VARY = T.let(T.unsafe(nil), String)

# source://http//lib/http/content_type.rb#5
HTTP::MIME_TYPE_RE = T.let(T.unsafe(nil), Regexp)

# MIME type encode/decode adapters
#
# source://http//lib/http/mime_type.rb#5
module HTTP::MimeType
  class << self
    # Returns adapter associated with MIME type
    #
    # @param type [#to_s]
    # @raise [Error] if no adapter found
    # @return [Class]
    #
    # source://http//lib/http/mime_type.rb#37
    def [](type); end

    # Resolves type by shortcut if possible
    #
    # @param type [#to_s]
    # @return [String]
    #
    # source://http//lib/http/mime_type.rb#58
    def normalize(type); end

    # Associate MIME type with adapter
    #
    # @example
    #
    #   module JsonAdapter
    #   class << self
    #   def encode(obj)
    #   # encode logic here
    #   end
    #
    #   def decode(str)
    #   # decode logic here
    #   end
    #   end
    #   end
    #
    #   HTTP::MimeType.register_adapter 'application/json', MyJsonAdapter
    # @param type [#to_s]
    # @param adapter [#encode, #decode]
    # @return [void]
    #
    # source://http//lib/http/mime_type.rb#28
    def register_adapter(type, adapter); end

    # Register a shortcut for MIME type
    #
    # @example
    #
    #   HTTP::MimeType.register_alias 'application/json', :json
    # @param type [#to_s]
    # @param shortcut [#to_sym]
    # @return [void]
    #
    # source://http//lib/http/mime_type.rb#50
    def register_alias(type, shortcut); end

    private

    # source://http//lib/http/mime_type.rb#65
    def adapters; end

    # source://http//lib/http/mime_type.rb#70
    def aliases; end
  end
end

# Base encode/decode MIME type adapter
#
# source://http//lib/http/mime_type/adapter.rb#9
class HTTP::MimeType::Adapter
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # source://http//lib/http/mime_type/adapter.rb#18
  def decode(*_arg0); end

  # source://http//lib/http/mime_type/adapter.rb#18
  def encode(*_arg0); end

  class << self
    # source://forwardable/1.3.1/forwardable.rb#226
    def decode(*args, &block); end

    # source://forwardable/1.3.1/forwardable.rb#226
    def encode(*args, &block); end
  end
end

# JSON encode/decode MIME type adapter
#
# source://http//lib/http/mime_type/json.rb#10
class HTTP::MimeType::JSON < ::HTTP::MimeType::Adapter
  # Decodes JSON
  #
  # source://http//lib/http/mime_type/json.rb#17
  def decode(str); end

  # Encodes object to JSON
  #
  # source://http//lib/http/mime_type/json.rb#11
  def encode(obj); end
end

# source://http//lib/http/options.rb#11
class HTTP::Options
  # @return [Options] a new instance of Options
  #
  # source://http//lib/http/options.rb#53
  def initialize(options = T.unsafe(nil)); end

  # source://http//lib/http/options.rb#43
  def body; end

  # source://http//lib/http/options.rb#43
  def cookies; end

  # @yield [dupped]
  #
  # source://http//lib/http/options.rb#175
  def dup; end

  # source://http//lib/http/options.rb#43
  def encoding; end

  # source://http//lib/http/options.rb#181
  def feature(name); end

  # source://http//lib/http/options.rb#41
  def features; end

  # source://http//lib/http/options.rb#109
  def features=(features); end

  # source://http//lib/http/options.rb#41
  def follow; end

  # source://http//lib/http/options.rb#132
  def follow=(value); end

  # source://http//lib/http/options.rb#43
  def form; end

  # source://http//lib/http/options.rb#43
  def headers; end

  # source://http//lib/http/options.rb#43
  def json; end

  # source://http//lib/http/options.rb#43
  def keep_alive_timeout; end

  # source://http//lib/http/options.rb#152
  def merge(other); end

  # source://http//lib/http/options.rb#43
  def nodelay; end

  # source://http//lib/http/options.rb#43
  def params; end

  # source://http//lib/http/options.rb#41
  def persistent; end

  # source://http//lib/http/options.rb#144
  def persistent=(value); end

  # @return [Boolean]
  #
  # source://http//lib/http/options.rb#148
  def persistent?; end

  # source://http//lib/http/options.rb#43
  def proxy; end

  # source://http//lib/http/options.rb#43
  def response; end

  # source://http//lib/http/options.rb#43
  def socket_class; end

  # source://http//lib/http/options.rb#43
  def ssl; end

  # source://http//lib/http/options.rb#43
  def ssl_context; end

  # source://http//lib/http/options.rb#43
  def ssl_socket_class; end

  # source://http//lib/http/options.rb#43
  def timeout_class; end

  # source://http//lib/http/options.rb#43
  def timeout_options; end

  # source://http//lib/http/options.rb#168
  def to_hash; end

  # source://http//lib/http/options.rb#47
  def with_body(value); end

  # source://http//lib/http/options.rb#47
  def with_cookies(value); end

  # source://http//lib/http/options.rb#47
  def with_encoding(value); end

  # source://http//lib/http/options.rb#47
  def with_features(value); end

  # source://http//lib/http/options.rb#47
  def with_follow(value); end

  # source://http//lib/http/options.rb#47
  def with_form(value); end

  # source://http//lib/http/options.rb#47
  def with_headers(value); end

  # source://http//lib/http/options.rb#47
  def with_json(value); end

  # source://http//lib/http/options.rb#47
  def with_keep_alive_timeout(value); end

  # source://http//lib/http/options.rb#47
  def with_nodelay(value); end

  # source://http//lib/http/options.rb#47
  def with_params(value); end

  # source://http//lib/http/options.rb#47
  def with_persistent(value); end

  # source://http//lib/http/options.rb#47
  def with_proxy(value); end

  # source://http//lib/http/options.rb#47
  def with_response(value); end

  # source://http//lib/http/options.rb#47
  def with_socket_class(value); end

  # source://http//lib/http/options.rb#47
  def with_ssl(value); end

  # source://http//lib/http/options.rb#47
  def with_ssl_context(value); end

  # source://http//lib/http/options.rb#47
  def with_ssl_socket_class(value); end

  # source://http//lib/http/options.rb#47
  def with_timeout_class(value); end

  # source://http//lib/http/options.rb#47
  def with_timeout_options(value); end

  protected

  # source://http//lib/http/options.rb#187
  def []=(option, val); end

  # source://http//lib/http/options.rb#43
  def body=(_arg0); end

  # source://http//lib/http/options.rb#43
  def cookies=(_arg0); end

  # source://http//lib/http/options.rb#43
  def encoding=(_arg0); end

  # source://http//lib/http/options.rb#43
  def form=(_arg0); end

  # source://http//lib/http/options.rb#43
  def headers=(_arg0); end

  # source://http//lib/http/options.rb#43
  def json=(_arg0); end

  # source://http//lib/http/options.rb#43
  def keep_alive_timeout=(_arg0); end

  # source://http//lib/http/options.rb#43
  def nodelay=(_arg0); end

  # source://http//lib/http/options.rb#43
  def params=(_arg0); end

  # source://http//lib/http/options.rb#43
  def proxy=(_arg0); end

  # source://http//lib/http/options.rb#43
  def response=(_arg0); end

  # source://http//lib/http/options.rb#43
  def socket_class=(_arg0); end

  # source://http//lib/http/options.rb#43
  def ssl=(_arg0); end

  # source://http//lib/http/options.rb#43
  def ssl_context=(_arg0); end

  # source://http//lib/http/options.rb#43
  def ssl_socket_class=(_arg0); end

  # source://http//lib/http/options.rb#43
  def timeout_class=(_arg0); end

  # source://http//lib/http/options.rb#43
  def timeout_options=(_arg0); end

  private

  # @raise [Error]
  #
  # source://http//lib/http/options.rb#193
  def argument_error!(message); end

  class << self
    # Returns the value of attribute available_features.
    #
    # source://http//lib/http/options.rb#19
    def available_features; end

    # Returns the value of attribute default_socket_class.
    #
    # source://http//lib/http/options.rb#18
    def default_socket_class; end

    # Sets the attribute default_socket_class
    #
    # @param value the value to set the attribute default_socket_class to.
    #
    # source://http//lib/http/options.rb#18
    def default_socket_class=(_arg0); end

    # Returns the value of attribute default_ssl_socket_class.
    #
    # source://http//lib/http/options.rb#18
    def default_ssl_socket_class; end

    # Sets the attribute default_ssl_socket_class
    #
    # @param value the value to set the attribute default_ssl_socket_class to.
    #
    # source://http//lib/http/options.rb#18
    def default_ssl_socket_class=(_arg0); end

    # Returns the value of attribute default_timeout_class.
    #
    # source://http//lib/http/options.rb#18
    def default_timeout_class; end

    # Sets the attribute default_timeout_class
    #
    # @param value the value to set the attribute default_timeout_class to.
    #
    # source://http//lib/http/options.rb#18
    def default_timeout_class=(_arg0); end

    # source://http//lib/http/options.rb#26
    def defined_options; end

    # source://http//lib/http/options.rb#21
    def new(options = T.unsafe(nil)); end

    # source://http//lib/http/options.rb#30
    def register_feature(name, impl); end

    protected

    # source://http//lib/http/options.rb#36
    def def_option(name, reader_only: T.unsafe(nil), &interpreter); end
  end
end

# source://http//lib/http/redirector.rb#8
class HTTP::Redirector
  # @option opts
  # @option opts
  # @param opts [Hash]
  # @return [Redirector] a new instance of Redirector
  #
  # source://http//lib/http/redirector.rb#42
  def initialize(opts = T.unsafe(nil)); end

  # Returns the value of attribute max_hops.
  #
  # source://http//lib/http/redirector.rb#37
  def max_hops; end

  # Follows redirects until non-redirect response found
  #
  # source://http//lib/http/redirector.rb#48
  def perform(request, response); end

  # Returns the value of attribute strict.
  #
  # source://http//lib/http/redirector.rb#32
  def strict; end

  private

  # Check if we got into an endless loop
  #
  # @return [Boolean]
  #
  # source://http//lib/http/redirector.rb#79
  def endless_loop?; end

  # Redirect policy for follow
  #
  # @raise [StateError]
  # @return [Request]
  #
  # source://http//lib/http/redirector.rb#85
  def redirect_to(uri); end

  # Check if we reached max amount of redirect hops
  #
  # @return [Boolean]
  #
  # source://http//lib/http/redirector.rb#73
  def too_many_hops?; end
end

# Notifies that following redirects got into an endless loop
#
# source://http//lib/http/redirector.rb#13
class HTTP::Redirector::EndlessRedirectError < ::HTTP::Redirector::TooManyRedirectsError; end

# HTTP status codes which indicate redirects
#
# source://http//lib/http/redirector.rb#16
HTTP::Redirector::REDIRECT_CODES = T.let(T.unsafe(nil), Set)

# Verbs which will remain unchanged upon See Other response.
#
# source://http//lib/http/redirector.rb#27
HTTP::Redirector::SEE_OTHER_ALLOWED_VERBS = T.let(T.unsafe(nil), Set)

# Codes which which should raise StateError in strict mode if original
# request was any of {UNSAFE_VERBS}
#
# source://http//lib/http/redirector.rb#20
HTTP::Redirector::STRICT_SENSITIVE_CODES = T.let(T.unsafe(nil), Set)

# Notifies that we reached max allowed redirect hops
#
# source://http//lib/http/redirector.rb#10
class HTTP::Redirector::TooManyRedirectsError < ::HTTP::ResponseError; end

# Insecure http verbs, which should trigger StateError in strict mode
# upon {STRICT_SENSITIVE_CODES}
#
# source://http//lib/http/redirector.rb#24
HTTP::Redirector::UNSAFE_VERBS = T.let(T.unsafe(nil), Set)

# source://http//lib/http/request/body.rb#4
class HTTP::Request
  include ::HTTP::Headers::Mixin
  extend ::Forwardable

  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash] a customizable set of options
  # @raise [UnsupportedMethodError]
  # @return [Request] a new instance of Request
  #
  # source://http//lib/http/request.rb#83
  def initialize(opts); end

  # Returns the value of attribute body.
  #
  # source://http//lib/http/request.rb#74
  def body; end

  # Setup tunnel through proxy for SSL request
  #
  # source://http//lib/http/request.rb#147
  def connect_using_proxy(socket); end

  # Compute HTTP request header for direct or proxy request
  #
  # source://http//lib/http/request.rb#152
  def headline; end

  # @return [String]
  #
  # source://forwardable/1.3.1/forwardable.rb#226
  def host(*args, &block); end

  # Compute and add the Proxy-Authorization header
  #
  # source://http//lib/http/request.rb#137
  def include_proxy_authorization_header; end

  # source://http//lib/http/request.rb#131
  def include_proxy_headers; end

  # Human-readable representation of base request info.
  #
  # @example
  #
  #   req.inspect
  #   # => #<HTTP::Request/1.1 GET https://example.com>
  # @return [String]
  #
  # source://http//lib/http/request.rb#198
  def inspect; end

  # Returns the value of attribute proxy.
  #
  # source://http//lib/http/request.rb#74
  def proxy; end

  # source://http//lib/http/request.rb#141
  def proxy_authorization_header; end

  # Compute HTTP request header SSL proxy connection
  #
  # source://http//lib/http/request.rb#164
  def proxy_connect_header; end

  # Headers to send with proxy connect request
  #
  # source://http//lib/http/request.rb#169
  def proxy_connect_headers; end

  # Returns new Request with updated uri
  #
  # source://http//lib/http/request.rb#100
  def redirect(uri, verb = T.unsafe(nil)); end

  # Scheme is normalized to be a lowercase symbol e.g. :http, :https
  #
  # source://http//lib/http/request.rb#67
  def scheme; end

  # Host for tcp socket
  #
  # source://http//lib/http/request.rb#181
  def socket_host; end

  # Port for tcp socket
  #
  # source://http//lib/http/request.rb#186
  def socket_port; end

  # Stream the request to a socket
  #
  # source://http//lib/http/request.rb#116
  def stream(socket); end

  # "Request URI" as per RFC 2616
  # http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html
  #
  # source://http//lib/http/request.rb#73
  def uri; end

  # Returns the value of attribute uri_normalizer.
  #
  # source://http//lib/http/request.rb#69
  def uri_normalizer; end

  # Is this request using an authenticated proxy?
  #
  # @return [Boolean]
  #
  # source://http//lib/http/request.rb#127
  def using_authenticated_proxy?; end

  # Is this request using a proxy?
  #
  # @return [Boolean]
  #
  # source://http//lib/http/request.rb#122
  def using_proxy?; end

  # Method is given as a lowercase symbol e.g. :get, :post
  #
  # source://http//lib/http/request.rb#64
  def verb; end

  # Returns the value of attribute version.
  #
  # source://http//lib/http/request.rb#74
  def version; end

  # source://webmock/3.18.1/lib/webmock/http_lib_adapters/http_rb/request.rb#3
  def webmock_signature; end

  private

  # @return [String] Default host (with port if needed) header value.
  #
  # source://http//lib/http/request.rb#215
  def default_host_header_value; end

  # source://http//lib/http/request.rb#210
  def port; end

  # source://http//lib/http/request.rb#219
  def prepare_body(body); end

  # source://http//lib/http/request.rb#223
  def prepare_headers(headers); end
end

# source://http//lib/http/request/body.rb#5
class HTTP::Request::Body
  # @return [Body] a new instance of Body
  #
  # source://http//lib/http/request/body.rb#8
  def initialize(source); end

  # Request bodies are equivalent when they have the same source.
  #
  # source://http//lib/http/request/body.rb#47
  def ==(other); end

  # Yields chunks of content to be streamed to the request body.
  #
  # @yieldparam [String]
  #
  # source://http//lib/http/request/body.rb#33
  def each(&block); end

  # Returns size which should be used for the "Content-Length" header.
  #
  # @return [Integer]
  #
  # source://http//lib/http/request/body.rb#17
  def size; end

  # Returns the value of attribute source.
  #
  # source://http//lib/http/request/body.rb#6
  def source; end

  private

  # source://http//lib/http/request/body.rb#53
  def rewind(io); end

  # @raise [RequestError]
  #
  # source://http//lib/http/request/body.rb#75
  def validate_source_type!; end
end

# This class provides a "writable IO" wrapper around a proc object, with
# #write simply calling the proc, which we can pass in as the
# "destination IO" in IO.copy_stream.
#
# source://http//lib/http/request/body.rb#87
class HTTP::Request::Body::ProcIO
  # @return [ProcIO] a new instance of ProcIO
  #
  # source://http//lib/http/request/body.rb#88
  def initialize(block); end

  # source://http//lib/http/request/body.rb#92
  def write(data); end
end

# source://http//lib/http/request.rb#29
HTTP::Request::METHODS = T.let(T.unsafe(nil), Array)

# Default ports of supported schemes
#
# source://http//lib/http/request.rb#56
HTTP::Request::PORTS = T.let(T.unsafe(nil), Hash)

# Allowed schemes
#
# source://http//lib/http/request.rb#53
HTTP::Request::SCHEMES = T.let(T.unsafe(nil), Array)

# Default User-Agent header value
#
# source://http//lib/http/request.rb#27
HTTP::Request::USER_AGENT = T.let(T.unsafe(nil), String)

# The method given was not understood
#
# source://http//lib/http/request.rb#21
class HTTP::Request::UnsupportedMethodError < ::HTTP::RequestError; end

# The scheme of given URI was not understood
#
# source://http//lib/http/request.rb#24
class HTTP::Request::UnsupportedSchemeError < ::HTTP::RequestError; end

# source://http//lib/http/request/writer.rb#7
class HTTP::Request::Writer
  # @return [Writer] a new instance of Writer
  #
  # source://http//lib/http/request/writer.rb#20
  def initialize(socket, body, headers, headline); end

  # Adds the headers to the header array for the given request body we are working
  # with
  #
  # source://http//lib/http/request/writer.rb#49
  def add_body_type_headers; end

  # Adds headers to the request header from the headers array
  #
  # source://http//lib/http/request/writer.rb#28
  def add_headers; end

  # Returns true if the request should be sent in chunked encoding.
  #
  # @return [Boolean]
  #
  # source://http//lib/http/request/writer.rb#101
  def chunked?; end

  # Send headers needed to connect through proxy
  #
  # source://http//lib/http/request/writer.rb#42
  def connect_through_proxy; end

  # Yields chunks of request data that should be sent to the socket.
  #
  # It's important to send the request in a single write call when possible
  # in order to play nicely with Nagle's algorithm. Making two writes in a
  # row triggers a pathological case where Nagle is expecting a third write
  # that never happens.
  #
  # @yield [data]
  #
  # source://http//lib/http/request/writer.rb#77
  def each_chunk; end

  # Returns the chunk encoded for to the specified "Transfer-Encoding" header.
  #
  # source://http//lib/http/request/writer.rb#92
  def encode_chunk(chunk); end

  # Joins the headers specified in the request into a correctly formatted
  # http request header string
  #
  # source://http//lib/http/request/writer.rb#57
  def join_headers; end

  # Writes HTTP request data into the socket.
  #
  # source://http//lib/http/request/writer.rb#64
  def send_request; end

  # Stream the request to a socket
  #
  # source://http//lib/http/request/writer.rb#35
  def stream; end

  private

  # source://http//lib/http/request/writer.rb#107
  def write(data); end
end

# Chunked transfer encoding
#
# source://http//lib/http/request/writer.rb#15
HTTP::Request::Writer::CHUNKED = T.let(T.unsafe(nil), String)

# End of a chunked transfer
#
# source://http//lib/http/request/writer.rb#18
HTTP::Request::Writer::CHUNKED_END = T.let(T.unsafe(nil), String)

# CRLF is the universal HTTP delimiter
#
# source://http//lib/http/request/writer.rb#9
HTTP::Request::Writer::CRLF = T.let(T.unsafe(nil), String)

# Chunked data termintaor.
#
# source://http//lib/http/request/writer.rb#12
HTTP::Request::Writer::ZERO = T.let(T.unsafe(nil), String)

# Generic Request error
#
# source://http//lib/http/errors.rb#11
class HTTP::RequestError < ::HTTP::Error; end

class HTTP::RequestParser < ::HTTP::Parser; end

# source://http//lib/http/response/parser.rb#6
class HTTP::Response
  include ::HTTP::Headers::Mixin
  extend ::Forwardable

  # Inits a new instance
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash] a customizable set of options
  # @return [Response] a new instance of Response
  #
  # source://http//lib/http/response.rb#45
  def initialize(opts); end

  # @return [Body]
  #
  # source://http//lib/http/response.rb#27
  def body; end

  # Charset of response (if any)
  #
  # @return [String, nil]
  #
  # source://forwardable/1.3.1/forwardable.rb#226
  def charset(*args, &block); end

  # @return [Boolean]
  #
  # source://http//lib/http/response.rb#142
  def chunked?; end

  # @return [Fixnum] status code
  #
  # source://forwardable/1.3.1/forwardable.rb#226
  def code(*args, &block); end

  # The connection object used to make the corresponding request.
  #
  # @return [HTTP::Connection]
  #
  # source://forwardable/1.3.1/forwardable.rb#226
  def connection(*args, &block); end

  # Value of the Content-Length header.
  #
  # @return [nil] if Content-Length was not given, or it's value was invalid
  #   (not an integer, e.g. empty string or string with non-digits).
  # @return [Integer] otherwise
  #
  # source://http//lib/http/response.rb#103
  def content_length; end

  # Parsed Content-Type header
  #
  # @return [HTTP::ContentType]
  #
  # source://http//lib/http/response.rb#122
  def content_type; end

  # source://http//lib/http/response.rb#136
  def cookies; end

  # Flushes body and returns self-reference
  #
  # @return [Response]
  #
  # source://http//lib/http/response.rb#93
  def flush; end

  # Inspect a response
  #
  # source://http//lib/http/response.rb#162
  def inspect; end

  # MIME type of response (if any)
  #
  # @return [String, nil]
  #
  # source://forwardable/1.3.1/forwardable.rb#226
  def mime_type(*args, &block); end

  # Parse response body with corresponding MIME type adapter.
  #
  # @param as [#to_s] Parse as given MIME type
  #   instead of the one determined from headers
  # @raise [HTTP::Error] if adapter not found
  # @return [Object]
  #
  # source://http//lib/http/response.rb#157
  def parse(as = T.unsafe(nil)); end

  # @return [Hash]
  #
  # source://http//lib/http/response.rb#33
  def proxy_headers; end

  # source://forwardable/1.3.1/forwardable.rb#226
  def readpartial(*args, &block); end

  # @return [String, nil] status message
  #
  # source://forwardable/1.3.1/forwardable.rb#226
  def reason(*args, &block); end

  # @return [Status]
  #
  # source://http//lib/http/response.rb#21
  def status; end

  # Returns an Array ala Rack: `[status, headers, body]`
  #
  # @return [Array(Fixnum, Hash, String)]
  #
  # source://http//lib/http/response.rb#86
  def to_a; end

  # @return [String] eagerly consume the entire body as a string
  #
  # source://forwardable/1.3.1/forwardable.rb#226
  def to_s(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def to_str(*args, &block); end

  # source://webmock/3.18.1/lib/webmock/http_lib_adapters/http_rb/response.rb#3
  def to_webmock; end

  # @return [URI, nil]
  #
  # source://http//lib/http/response.rb#30
  def uri; end

  # @return [String]
  #
  # source://http//lib/http/response.rb#24
  def version; end

  class << self
    # source://webmock/3.18.1/lib/webmock/http_lib_adapters/http_rb/response.rb#14
    def from_webmock(request, webmock_response, request_signature = T.unsafe(nil)); end

    private

    # source://webmock/3.18.1/lib/webmock/http_lib_adapters/http_rb/response.rb#57
    def normalize_uri(uri); end
  end
end

# A streamable response body, also easily converted into a string
#
# source://http//lib/http/response/body.rb#9
class HTTP::Response::Body
  include ::Enumerable
  extend ::Forwardable

  # @return [Body] a new instance of Body
  #
  # source://http//lib/http/response/body.rb#19
  def initialize(stream, encoding: T.unsafe(nil)); end

  # The connection object used to make the corresponding request.
  #
  # @return [HTTP::Connection]
  #
  # source://http//lib/http/response/body.rb#17
  def connection; end

  # Iterate over the body, allowing it to be enumerable
  #
  # source://http//lib/http/response/body.rb#35
  def each; end

  # source://forwardable/1.3.1/forwardable.rb#226
  def empty?(*args, &block); end

  # Easier to interpret string inspect
  #
  # source://http//lib/http/response/body.rb#71
  def inspect; end

  # source://http//lib/http/response/body.rb#28
  def readpartial(*args); end

  # Assert that the body is actively being streamed
  #
  # @raise [StateError]
  #
  # source://http//lib/http/response/body.rb#65
  def stream!; end

  # @raise [StateError]
  # @return [String] eagerly consume the entire body as a string
  #
  # source://http//lib/http/response/body.rb#42
  def to_s; end

  # @raise [StateError]
  # @return [String] eagerly consume the entire body as a string
  #
  # source://http//lib/http/response/body.rb#42
  def to_str; end

  private

  # Retrieve encoding by name. If encoding cannot be found, default to binary.
  #
  # source://http//lib/http/response/body.rb#78
  def find_encoding(encoding); end
end

# source://http//lib/http/response/inflater.rb#7
class HTTP::Response::Inflater
  # @return [Inflater] a new instance of Inflater
  #
  # source://http//lib/http/response/inflater.rb#10
  def initialize(connection); end

  # Returns the value of attribute connection.
  #
  # source://http//lib/http/response/inflater.rb#8
  def connection; end

  # source://http//lib/http/response/inflater.rb#14
  def readpartial(*args); end

  private

  # source://http//lib/http/response/inflater.rb#27
  def zstream; end
end

# NOTE(ixti): This class is a subject of future refactoring, thus don't
#   expect this class API to be stable until this message disappears and
#   class is not marked as private anymore.
#
# @api private
#
# source://http//lib/http/response/parser.rb#12
class HTTP::Response::Parser
  # @api private
  # @return [Parser] a new instance of Parser
  #
  # source://http//lib/http/response/parser.rb#15
  def initialize; end

  # @api private
  # @raise [IOError]
  # @return [self]
  #
  # source://http//lib/http/response/parser.rb#23
  def <<(data); end

  # @api private
  # @raise [IOError]
  # @return [self]
  #
  # source://http//lib/http/response/parser.rb#23
  def add(data); end

  # @api private
  # @return [Boolean]
  #
  # source://http//lib/http/response/parser.rb#103
  def finished?; end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#13
  def headers; end

  # @api private
  # @return [Boolean]
  #
  # source://http//lib/http/response/parser.rb#35
  def headers?; end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#39
  def http_version; end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#66
  def on_body(_response, chunk); end

  # HTTP::Parser callbacks
  #
  # @api private
  #
  # source://http//lib/http/response/parser.rb#51
  def on_header_field(_response, field); end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#56
  def on_header_value(_response, value); end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#61
  def on_headers_complete(_reposse); end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#88
  def on_message_complete(_response); end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#74
  def read(size); end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#92
  def reset; end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#43
  def status_code; end

  private

  # @api private
  #
  # source://http//lib/http/response/parser.rb#109
  def append_header; end
end

# source://http//lib/http/response/status/reasons.rb#17
class HTTP::Response::Status
  # source://http//lib/http/response/status.rb#147
  def __getobj__; end

  # @raise [TypeError]
  #
  # source://http//lib/http/response/status.rb#142
  def __setobj__(obj); end

  # source://http//lib/http/response/status.rb#135
  def accepted?; end

  # source://http//lib/http/response/status.rb#135
  def already_reported?; end

  # source://http//lib/http/response/status.rb#135
  def bad_gateway?; end

  # source://http//lib/http/response/status.rb#135
  def bad_request?; end

  # Check if status code is client error (4XX)
  #
  # @return [Boolean]
  #
  # source://http//lib/http/response/status.rb#108
  def client_error?; end

  # @return [Fixnum] status code
  #
  # source://http//lib/http/response/status.rb#75
  def code; end

  # source://http//lib/http/response/status.rb#135
  def conflict?; end

  # source://http//lib/http/response/status.rb#135
  def continue?; end

  # source://http//lib/http/response/status.rb#135
  def created?; end

  # source://http//lib/http/response/status.rb#135
  def expectation_failed?; end

  # source://http//lib/http/response/status.rb#135
  def failed_dependency?; end

  # source://http//lib/http/response/status.rb#135
  def forbidden?; end

  # source://http//lib/http/response/status.rb#135
  def found?; end

  # source://http//lib/http/response/status.rb#135
  def gateway_timeout?; end

  # source://http//lib/http/response/status.rb#135
  def gone?; end

  # source://http//lib/http/response/status.rb#135
  def http_version_not_supported?; end

  # source://http//lib/http/response/status.rb#135
  def im_used?; end

  # Check if status code is informational (1XX)
  #
  # @return [Boolean]
  #
  # source://http//lib/http/response/status.rb#90
  def informational?; end

  # Printable version of HTTP Status, surrounded by quote marks,
  # with special characters escaped.
  #
  # (see String#inspect)
  #
  # source://http//lib/http/response/status.rb#130
  def inspect; end

  # source://http//lib/http/response/status.rb#135
  def insufficient_storage?; end

  # source://http//lib/http/response/status.rb#135
  def internal_server_error?; end

  # source://http//lib/http/response/status.rb#135
  def length_required?; end

  # source://http//lib/http/response/status.rb#135
  def locked?; end

  # source://http//lib/http/response/status.rb#135
  def loop_detected?; end

  # source://http//lib/http/response/status.rb#135
  def method_not_allowed?; end

  # source://http//lib/http/response/status.rb#135
  def misdirected_request?; end

  # source://http//lib/http/response/status.rb#135
  def moved_permanently?; end

  # source://http//lib/http/response/status.rb#135
  def multi_status?; end

  # source://http//lib/http/response/status.rb#135
  def multiple_choices?; end

  # source://http//lib/http/response/status.rb#135
  def network_authentication_required?; end

  # source://http//lib/http/response/status.rb#135
  def no_content?; end

  # source://http//lib/http/response/status.rb#135
  def non_authoritative_information?; end

  # source://http//lib/http/response/status.rb#135
  def not_acceptable?; end

  # source://http//lib/http/response/status.rb#135
  def not_extended?; end

  # source://http//lib/http/response/status.rb#135
  def not_found?; end

  # source://http//lib/http/response/status.rb#135
  def not_implemented?; end

  # source://http//lib/http/response/status.rb#135
  def not_modified?; end

  # source://http//lib/http/response/status.rb#135
  def ok?; end

  # source://http//lib/http/response/status.rb#135
  def partial_content?; end

  # source://http//lib/http/response/status.rb#135
  def payload_too_large?; end

  # source://http//lib/http/response/status.rb#135
  def payment_required?; end

  # source://http//lib/http/response/status.rb#135
  def permanent_redirect?; end

  # source://http//lib/http/response/status.rb#135
  def precondition_failed?; end

  # source://http//lib/http/response/status.rb#135
  def precondition_required?; end

  # source://http//lib/http/response/status.rb#135
  def processing?; end

  # source://http//lib/http/response/status.rb#135
  def proxy_authentication_required?; end

  # source://http//lib/http/response/status.rb#135
  def range_not_satisfiable?; end

  # @return [String, nil] status message
  # @see REASONS
  #
  # source://http//lib/http/response/status.rb#79
  def reason; end

  # Check if status code is redirection (3XX)
  #
  # @return [Boolean]
  #
  # source://http//lib/http/response/status.rb#102
  def redirect?; end

  # source://http//lib/http/response/status.rb#135
  def request_header_fields_too_large?; end

  # source://http//lib/http/response/status.rb#135
  def request_timeout?; end

  # source://http//lib/http/response/status.rb#135
  def reset_content?; end

  # source://http//lib/http/response/status.rb#135
  def see_other?; end

  # Check if status code is server error (5XX)
  #
  # @return [Boolean]
  #
  # source://http//lib/http/response/status.rb#114
  def server_error?; end

  # source://http//lib/http/response/status.rb#135
  def service_unavailable?; end

  # Check if status code is successful (2XX)
  #
  # @return [Boolean]
  #
  # source://http//lib/http/response/status.rb#96
  def success?; end

  # source://http//lib/http/response/status.rb#135
  def switching_protocols?; end

  # source://http//lib/http/response/status.rb#135
  def temporary_redirect?; end

  # @return [String] string representation of HTTP status
  #
  # source://http//lib/http/response/status.rb#84
  def to_s; end

  # Symbolized {#reason}
  #
  # @return [nil] unless code is well-known (see REASONS)
  # @return [Symbol]
  #
  # source://http//lib/http/response/status.rb#122
  def to_sym; end

  # source://http//lib/http/response/status.rb#135
  def too_many_requests?; end

  # source://http//lib/http/response/status.rb#135
  def unauthorized?; end

  # source://http//lib/http/response/status.rb#135
  def unavailable_for_legal_reasons?; end

  # source://http//lib/http/response/status.rb#135
  def unprocessable_entity?; end

  # source://http//lib/http/response/status.rb#135
  def unsupported_media_type?; end

  # source://http//lib/http/response/status.rb#135
  def upgrade_required?; end

  # source://http//lib/http/response/status.rb#135
  def uri_too_long?; end

  # source://http//lib/http/response/status.rb#135
  def use_proxy?; end

  # source://http//lib/http/response/status.rb#135
  def variant_also_negotiates?; end

  class << self
    # Coerces given value to Status.
    #
    # @example
    #   Status.coerce(:bad_request) # => Status.new(400)
    #   Status.coerce("400")        # => Status.new(400)
    #   Status.coerce(true)         # => raises HTTP::Error
    # @param object [Symbol, #to_i]
    # @raise [Error] if coercion is impossible
    # @return [Status]
    #
    # source://http//lib/http/response/status.rb#22
    def [](object); end

    # Coerces given value to Status.
    #
    # @example
    #
    #   Status.coerce(:bad_request) # => Status.new(400)
    #   Status.coerce("400")        # => Status.new(400)
    #   Status.coerce(true)         # => raises HTTP::Error
    # @param object [Symbol, #to_i]
    # @raise [Error] if coercion is impossible
    # @return [Status]
    #
    # source://http//lib/http/response/status.rb#22
    def coerce(object); end

    private

    # Symbolizes given string
    #
    # @example
    #
    #   symbolize "Bad Request"           # => :bad_request
    #   symbolize "Request-URI Too Long"  # => :request_uri_too_long
    #   symbolize "I'm a Teapot"          # => :im_a_teapot
    # @param str [#to_s]
    # @return [Symbol]
    #
    # source://http//lib/http/response/status.rb#47
    def symbolize(str); end
  end
end

# Code to Reason map
#
# @example Usage
#
#   REASONS[400] # => "Bad Request"
#   REASONS[414] # => "Request-URI Too Long"
# @return [Hash<Fixnum => String>]
#
# source://http//lib/http/response/status/reasons.rb#18
HTTP::Response::Status::REASONS = T.let(T.unsafe(nil), Hash)

# Code to Symbol map
#
# @example Usage
#
#   SYMBOLS[400] # => :bad_request
#   SYMBOLS[414] # => :request_uri_too_long
#   SYMBOLS[418] # => :im_a_teapot
# @return [Hash<Fixnum => Symbol>]
#
# source://http//lib/http/response/status.rb#61
HTTP::Response::Status::SYMBOLS = T.let(T.unsafe(nil), Hash)

# Reversed {SYMBOLS} map.
#
# @example Usage
#
#   SYMBOL_CODES[:bad_request]           # => 400
#   SYMBOL_CODES[:request_uri_too_long]  # => 414
#   SYMBOL_CODES[:im_a_teapot]           # => 418
# @return [Hash<Symbol => Fixnum>]
#
# source://http//lib/http/response/status.rb#72
HTTP::Response::Status::SYMBOL_CODES = T.let(T.unsafe(nil), Hash)

# Generic Response error
#
# source://http//lib/http/errors.rb#14
class HTTP::ResponseError < ::HTTP::Error; end

class HTTP::ResponseParser < ::HTTP::Parser; end

# Requested to do something when we're in the wrong state
#
# source://http//lib/http/errors.rb#17
class HTTP::StateError < ::HTTP::ResponseError; end

# source://http//lib/http/timeout/null.rb#7
module HTTP::Timeout; end

# source://http//lib/http/timeout/global.rb#10
class HTTP::Timeout::Global < ::HTTP::Timeout::Null
  # @return [Global] a new instance of Global
  #
  # source://http//lib/http/timeout/global.rb#11
  def initialize(*args); end

  # Write to the socket
  #
  # source://http//lib/http/timeout/global.rb#54
  def <<(data); end

  # source://http//lib/http/timeout/global.rb#22
  def connect(socket_class, host, port, nodelay = T.unsafe(nil)); end

  # source://http//lib/http/timeout/global.rb#32
  def connect_ssl; end

  # Read from the socket
  #
  # source://http//lib/http/timeout/global.rb#49
  def readpartial(size, buffer = T.unsafe(nil)); end

  # To future me: Don't remove this again, past you was smarter.
  #
  # source://http//lib/http/timeout/global.rb#18
  def reset_counter; end

  # Write to the socket
  #
  # source://http//lib/http/timeout/global.rb#54
  def write(data); end

  private

  # source://http//lib/http/timeout/global.rb#122
  def log_time; end

  # Perform the given I/O operation with the given argument
  #
  # source://http//lib/http/timeout/global.rb#81
  def perform_io; end

  # source://http//lib/http/timeout/global.rb#71
  def read_nonblock(size, buffer = T.unsafe(nil)); end

  # Due to the run/retry nature of nonblocking I/O, it's easier to keep track of time
  # via method calls instead of a block to monitor.
  #
  # source://http//lib/http/timeout/global.rb#118
  def reset_timer; end

  # Wait for a socket to become readable
  #
  # source://http//lib/http/timeout/global.rb#105
  def wait_readable_or_timeout; end

  # Wait for a socket to become writable
  #
  # source://http//lib/http/timeout/global.rb#111
  def wait_writable_or_timeout; end

  # source://http//lib/http/timeout/global.rb#75
  def write_nonblock(data); end
end

# source://http//lib/http/timeout/null.rb#8
class HTTP::Timeout::Null
  extend ::Forwardable

  # @return [Null] a new instance of Null
  #
  # source://http//lib/http/timeout/null.rb#15
  def initialize(options = T.unsafe(nil)); end

  # Write to the socket
  #
  # source://http//lib/http/timeout/null.rb#51
  def <<(data); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def close(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def closed?(*args, &block); end

  # Connects to a socket
  #
  # source://http//lib/http/timeout/null.rb#20
  def connect(socket_class, host, port, nodelay = T.unsafe(nil)); end

  # Starts a SSL connection on a socket
  #
  # source://http//lib/http/timeout/null.rb#26
  def connect_ssl; end

  # Returns the value of attribute options.
  #
  # source://http//lib/http/timeout/null.rb#13
  def options; end

  # Read from the socket
  #
  # source://http//lib/http/timeout/null.rb#44
  def readpartial(size, buffer = T.unsafe(nil)); end

  # Returns the value of attribute socket.
  #
  # source://http//lib/http/timeout/null.rb#13
  def socket; end

  # Configures the SSL connection and starts the connection
  #
  # source://http//lib/http/timeout/null.rb#31
  def start_tls(host, ssl_socket_class, ssl_context); end

  # Write to the socket
  #
  # source://http//lib/http/timeout/null.rb#51
  def write(data); end

  private

  # Retry reading
  #
  # source://http//lib/http/timeout/null.rb#59
  def rescue_readable(timeout = T.unsafe(nil)); end

  # Retry writing
  #
  # source://http//lib/http/timeout/null.rb#67
  def rescue_writable(timeout = T.unsafe(nil)); end
end

# source://http//lib/http/timeout/per_operation.rb#9
class HTTP::Timeout::PerOperation < ::HTTP::Timeout::Null
  # @return [PerOperation] a new instance of PerOperation
  #
  # source://http//lib/http/timeout/per_operation.rb#14
  def initialize(*args); end

  # source://http//lib/http/timeout/per_operation.rb#22
  def connect(socket_class, host, port, nodelay = T.unsafe(nil)); end

  # source://http//lib/http/timeout/per_operation.rb#29
  def connect_ssl; end

  # Read data from the socket
  #
  # source://http//lib/http/timeout/per_operation.rb#60
  def readpartial(size, buffer = T.unsafe(nil)); end

  # Write data to the socket
  #
  # source://http//lib/http/timeout/per_operation.rb#84
  def write(data); end
end

# source://http//lib/http/timeout/per_operation.rb#10
HTTP::Timeout::PerOperation::CONNECT_TIMEOUT = T.let(T.unsafe(nil), Float)

# source://http//lib/http/timeout/per_operation.rb#12
HTTP::Timeout::PerOperation::READ_TIMEOUT = T.let(T.unsafe(nil), Float)

# source://http//lib/http/timeout/per_operation.rb#11
HTTP::Timeout::PerOperation::WRITE_TIMEOUT = T.let(T.unsafe(nil), Float)

# Generic Timeout error
#
# source://http//lib/http/errors.rb#20
class HTTP::TimeoutError < ::HTTP::Error; end

# source://http//lib/http/uri.rb#6
class HTTP::URI
  extend ::Forwardable

  # Creates an HTTP::URI instance from the given options
  #
  # @option options_or_uri
  # @option options_or_uri
  # @option options_or_uri
  # @option options_or_uri
  # @option options_or_uri
  # @option options_or_uri
  # @option options_or_uri
  # @option options_or_uri
  # @param options_or_uri [Hash, Addressable::URI]
  # @return [HTTP::URI] new URI instance
  #
  # source://http//lib/http/uri.rb#77
  def initialize(options_or_uri = T.unsafe(nil)); end

  # Are these URI objects equal? Normalizes both URIs prior to comparison
  #
  # @param other [Object] URI to compare this one with
  # @return [TrueClass, FalseClass] are the URIs equivalent (after normalization)?
  #
  # source://http//lib/http/uri.rb#93
  def ==(other); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def authority(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def authority=(*args, &block); end

  # @return [Object] duplicated URI
  #
  # source://http//lib/http/uri.rb#133
  def dup; end

  # Are these URI objects equal? Does NOT normalizes both URIs prior to comparison
  #
  # @param other [Object] URI to compare this one with
  # @return [TrueClass, FalseClass] are the URIs equivalent?
  #
  # source://http//lib/http/uri.rb#102
  def eql?(other); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def fragment(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def fragment=(*args, &block); end

  # Hash value based off the normalized form of a URI
  #
  # @return [Integer] A hash of the URI
  #
  # source://http//lib/http/uri.rb#109
  def hash; end

  # source://forwardable/1.3.1/forwardable.rb#226
  def host(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def host=(*args, &block); end

  # @return [True] if URI is HTTP
  # @return [False] otherwise
  #
  # source://http//lib/http/uri.rb#122
  def http?; end

  # @return [True] if URI is HTTPS
  # @return [False] otherwise
  #
  # source://http//lib/http/uri.rb#128
  def https?; end

  # @return [String] human-readable representation of URI
  #
  # source://http//lib/http/uri.rb#146
  def inspect; end

  # source://forwardable/1.3.1/forwardable.rb#226
  def join(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def normalize(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def normalized_authority(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def normalized_fragment(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def normalized_host(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def normalized_password(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def normalized_path(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def normalized_port(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def normalized_query(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def normalized_scheme(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def normalized_user(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def omit(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def origin(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def origin=(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def password(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def password=(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def path(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def path=(*args, &block); end

  # Port number, either as specified or the default if unspecified
  #
  # @return [Integer] port number
  #
  # source://http//lib/http/uri.rb#116
  def port; end

  # source://forwardable/1.3.1/forwardable.rb#226
  def port=(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def query(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def query=(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def query_values(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def query_values=(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def request_uri(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def request_uri=(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def scheme(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def scheme=(*args, &block); end

  # Convert an HTTP::URI to a String
  #
  # @return [String] URI serialized as a String
  #
  # source://http//lib/http/uri.rb#140
  def to_s; end

  # Convert an HTTP::URI to a String
  #
  # @return [String] URI serialized as a String
  #
  # source://http//lib/http/uri.rb#140
  def to_str; end

  # source://forwardable/1.3.1/forwardable.rb#226
  def user(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def user=(*args, &block); end

  class << self
    # Encodes key/value pairs as application/x-www-form-urlencoded
    #
    # @param form_values [#to_hash, #to_ary] to encode
    # @param sort [TrueClass, FalseClass] should key/value pairs be sorted first?
    # @return [String] encoded value
    #
    # source://http//lib/http/uri.rb#59
    def form_encode(form_values, sort = T.unsafe(nil)); end

    # Parse the given URI string, returning an HTTP::URI object
    #
    # @param uri [HTTP::URI, String, #to_str] to parse
    # @return [HTTP::URI] new URI instance
    #
    # source://http//lib/http/uri.rb#47
    def parse(uri); end
  end
end

# @private
#
# source://http//lib/http/uri.rb#27
HTTP::URI::HTTPS_SCHEME = T.let(T.unsafe(nil), String)

# @private
#
# source://http//lib/http/uri.rb#24
HTTP::URI::HTTP_SCHEME = T.let(T.unsafe(nil), String)

# @private
#
# source://http//lib/http/uri.rb#30
HTTP::URI::NORMALIZER = T.let(T.unsafe(nil), Proc)

# source://http//lib/http/version.rb#4
HTTP::VERSION = T.let(T.unsafe(nil), String)
