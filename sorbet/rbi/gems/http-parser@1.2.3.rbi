# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `http-parser` gem.
# Please instead update this file by running `bin/tapioca gem http-parser`.

class FFI::Function < ::FFI::Pointer
  # @return [Function] a new instance of Function
  def initialize(*_arg0); end

  def attach(_arg0, _arg1); end
  def autorelease; end
  def autorelease=(_arg0); end
  def autorelease?; end
  def call(*_arg0); end
  def free; end

  private

  def initialize_copy(_arg0); end
end

# source://http-parser//lib/http-parser/ext.rb#6
module HttpParser
  extend ::FFI::Library

  def err_desc(*_arg0); end
  def err_name(*_arg0); end
  def http_body_is_final(*_arg0); end
  def http_parser_execute(*_arg0); end
  def http_parser_init(*_arg0); end
  def http_should_keep_alive(*_arg0); end

  class << self
    def err_desc(*_arg0); end
    def err_name(*_arg0); end
    def http_body_is_final(*_arg0); end
    def http_parser_execute(*_arg0); end
    def http_parser_init(*_arg0); end
    def http_should_keep_alive(*_arg0); end
  end
end

# source://http-parser//lib/http-parser/errors.rb#36
HttpParser::ERRORS = T.let(T.unsafe(nil), Hash)

# source://http-parser//lib/http-parser/errors.rb#4
class HttpParser::Error < ::StandardError; end

# Any callback-related errors
#
# source://http-parser//lib/http-parser/errors.rb#8
class HttpParser::Error::CALLBACK < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#13
class HttpParser::Error::CLOSED_CONNECTION < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#12
class HttpParser::Error::HEADER_OVERFLOW < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#27
class HttpParser::Error::INVALID_CHUNK_SIZE < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#28
class HttpParser::Error::INVALID_CONSTANT < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#26
class HttpParser::Error::INVALID_CONTENT_LENGTH < ::HttpParser::Error; end

# Parsing-related errors
#
# source://http-parser//lib/http-parser/errors.rb#11
class HttpParser::Error::INVALID_EOF_STATE < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#23
class HttpParser::Error::INVALID_FRAGMENT < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#25
class HttpParser::Error::INVALID_HEADER_TOKEN < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#19
class HttpParser::Error::INVALID_HOST < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#29
class HttpParser::Error::INVALID_INTERNAL_STATE < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#17
class HttpParser::Error::INVALID_METHOD < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#21
class HttpParser::Error::INVALID_PATH < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#20
class HttpParser::Error::INVALID_PORT < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#22
class HttpParser::Error::INVALID_QUERY_STRING < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#16
class HttpParser::Error::INVALID_STATUS < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#18
class HttpParser::Error::INVALID_URL < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#15
class HttpParser::Error::INVALID_VERSION < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#24
class HttpParser::Error::LF_EXPECTED < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#5
class HttpParser::Error::OK < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#31
class HttpParser::Error::PAUSED < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#30
class HttpParser::Error::STRICT < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/errors.rb#33
class HttpParser::Error::UNKNOWN < ::HttpParser::Error; end

# source://http-parser//lib/http-parser/types.rb#14
HttpParser::FLAG = T.let(T.unsafe(nil), Hash)

# source://http-parser//lib/http-parser/types.rb#299
class HttpParser::FieldData < ::FFI::Struct; end

# source://http-parser//lib/http-parser/types.rb#4
HttpParser::HTTP_MAX_HEADER_SIZE = T.let(T.unsafe(nil), Integer)

# source://http-parser//lib/http-parser/types.rb#304
class HttpParser::HttpParserUrl < ::FFI::Struct; end

# Effectively this represents a request instance
#
# source://http-parser//lib/http-parser/types.rb#86
class HttpParser::Instance < ::FFI::Struct
  # @return [Instance] a new instance of Instance
  # @yield [_self]
  # @yieldparam _self [HttpParser::Instance] the object that the method was called on
  #
  # source://http-parser//lib/http-parser/types.rb#106
  def initialize(ptr = T.unsafe(nil)); end

  # Additional data attached to the parser.
  #
  # @return [FFI::Pointer] Pointer to the additional data.
  #
  # source://http-parser//lib/http-parser/types.rb#257
  def data; end

  # Returns the error that occurred during processing.
  #
  # @return [StandarError] Returns the error that occurred.
  #
  # source://http-parser//lib/http-parser/types.rb#241
  def error; end

  # Indicates an error has occurred when called in a callback
  #
  # source://http-parser//lib/http-parser/types.rb#294
  def error!; end

  # Determines whether an error occurred during processing.
  #
  # @return [Boolean] Did a parsing error occur with the request?
  #
  # source://http-parser//lib/http-parser/types.rb#230
  def error?; end

  # Determines if a chunked response has completed
  #
  # @return [Boolean] Specifies whether the chunked response has completed
  #
  # source://http-parser//lib/http-parser/types.rb#280
  def final_chunk?; end

  # Flags for the parser.
  #
  # @return [Integer] Parser flags.
  #
  # source://http-parser//lib/http-parser/types.rb#154
  def flags; end

  # The parsed HTTP major version number.
  #
  # @return [Integer] The HTTP major version number.
  #
  # source://http-parser//lib/http-parser/types.rb#164
  def http_major; end

  # The parsed HTTP Method.
  #
  # @return [Symbol] The HTTP Method name.
  # @see http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1
  #
  # source://http-parser//lib/http-parser/types.rb#208
  def http_method; end

  # The parsed HTTP minor version number.
  #
  # @return [Integer] The HTTP minor version number.
  #
  # source://http-parser//lib/http-parser/types.rb#174
  def http_minor; end

  # The parsed HTTP response Status Code.
  #
  # @return [Integer] The HTTP Status Code.
  # @see http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1.1
  #
  # source://http-parser//lib/http-parser/types.rb#196
  def http_status; end

  # The parsed HTTP version.
  #
  # @return [String] The HTTP version.
  #
  # source://http-parser//lib/http-parser/types.rb#184
  def http_version; end

  # Determines whether the `Connection: keep-alive` header has been
  # parsed.
  #
  # @return [Boolean] Specifies whether the Connection should be kept alive.
  # @see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.10
  #
  # source://http-parser//lib/http-parser/types.rb#270
  def keep_alive?; end

  # Resets the parser.
  #
  # @param new_type [:request, :response, :both] The new type for the parser.
  #
  # source://http-parser//lib/http-parser/types.rb#124
  def reset!(new_type = T.unsafe(nil)); end

  # Halts the parser if called in a callback
  #
  # source://http-parser//lib/http-parser/types.rb#287
  def stop!; end

  # The type of the parser.
  #
  # @return [:request, :response, :both] The parser type.
  #
  # source://http-parser//lib/http-parser/types.rb#134
  def type; end

  # Sets the type of the parser.
  #
  # @param new_type [:request, :response, :both] The new parser type.
  #
  # source://http-parser//lib/http-parser/types.rb#144
  def type=(new_type); end

  # Determines whether the `Upgrade` header has been parsed.
  #
  # @return [Boolean] Specifies whether the `Upgrade` header has been seen.
  # @see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.42
  #
  # source://http-parser//lib/http-parser/types.rb#220
  def upgrade?; end
end

# Request Methods
#
# source://http-parser//lib/http-parser/types.rb#27
HttpParser::METHODS = T.let(T.unsafe(nil), FFI::Enum)

# source://http-parser//lib/http-parser/parser.rb#4
class HttpParser::Parser
  # Initializes the Parser instance.
  #
  # @return [Parser] a new instance of Parser
  # @yield [_self]
  # @yieldparam _self [HttpParser::Parser] the object that the method was called on
  #
  # source://http-parser//lib/http-parser/parser.rb#21
  def initialize(callback_obj = T.unsafe(nil)); end

  # Registers an `on_body` callback.
  #
  # @see http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.5
  # @yield [instance, body] The given block will be called when the body is recognized in the
  #   message body.
  # @yieldparam instance [HttpParser::Instance] The state so far of the request / response being processed.
  # @yieldparam body [String] The full body or a chunk of the body from a chunked
  #   Transfer-Encoded stream.
  #
  # source://http-parser//lib/http-parser/parser.rb#158
  def on_body(&block); end

  # Registers an `on_chunk_complete` callback.
  #
  # @yield [instance] The given block will be called when the current chunk completes.
  # @yieldparam instance [HttpParser::Instance] The state so far of the request / response being processed.
  #
  # source://http-parser//lib/http-parser/parser.rb#203
  def on_chunk_complete(&block); end

  # Registers an `on_chunk_header` callback.
  #
  # @yield [instance] The given block will be called when a new chunk header is received.
  # @yieldparam instance [HttpParser::Instance] The state so far of the request / response being processed.
  #
  # source://http-parser//lib/http-parser/parser.rb#188
  def on_chunk_header(&block); end

  # Registers an `on_header_field` callback.
  #
  # @see http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.5
  # @yield [instance, field] The given block will be called when a Header name is recognized
  #   in the Headers.
  # @yieldparam instance [HttpParser::Instance] The state so far of the request / response being processed.
  # @yieldparam field [String] A recognized Header name.
  #
  # source://http-parser//lib/http-parser/parser.rb#100
  def on_header_field(&block); end

  # Registers an `on_header_value` callback.
  #
  # @see http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.5
  # @yield [instance, value] The given block will be called when a Header value is recognized
  #   in the Headers.
  # @yieldparam instance [HttpParser::Instance] The state so far of the request / response being processed.
  # @yieldparam value [String] A recognized Header value.
  #
  # source://http-parser//lib/http-parser/parser.rb#121
  def on_header_value(&block); end

  # Registers an `on_headers_complete` callback.
  #
  # @yield [instance] The given block will be called when the Headers stop.
  # @yieldparam instance [HttpParser::Instance] The state so far of the request / response being processed.
  #
  # source://http-parser//lib/http-parser/parser.rb#136
  def on_headers_complete(&block); end

  # Registers an `on_message_begin` callback.
  #
  # @yield [instance] The given block will be called when the HTTP message begins.
  # @yieldparam instance [HttpParser::Instance] The state so far of the request / response being processed.
  #
  # source://http-parser//lib/http-parser/parser.rb#43
  def on_message_begin(&block); end

  # Registers an `on_message_begin` callback.
  #
  # @yield [instance] The given block will be called when the message completes.
  # @yieldparam instance [HttpParser::Instance] The state so far of the request / response being processed.
  #
  # source://http-parser//lib/http-parser/parser.rb#173
  def on_message_complete(&block); end

  # Registers an `on_status_complete` callback.
  #
  # @yield [instance] The given block will be called when the status is recognized.
  # @yieldparam instance [HttpParser::Instance] The state so far of the request / response being processed.
  #
  # source://http-parser//lib/http-parser/parser.rb#79
  def on_status(&block); end

  # Registers an `on_url` callback.
  #
  # @see http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2
  # @yield [instance, url] The given block will be called when the Request URI is recognized
  #   within the Request-Line.
  # @yieldparam instance [HttpParser::Instance] The state so far of the request / response being processed.
  # @yieldparam url [String] The recognized Request URI.
  #
  # source://http-parser//lib/http-parser/parser.rb#64
  def on_url(&block); end

  # Parses data.
  #
  # @param inst [HttpParser::Instance] The state so far of the request / response being processed.
  # @param data [String] The data to parse against the instance specified.
  # @return [Boolean] Returns true if the data was parsed successfully.
  #
  # source://http-parser//lib/http-parser/parser.rb#221
  def parse(inst, data); end

  class << self
    # Returns a new request/response instance variable
    #
    # source://http-parser//lib/http-parser/parser.rb#13
    def new_instance(&block); end
  end
end

# source://http-parser//lib/http-parser/parser.rb#5
HttpParser::Parser::CALLBACKS = T.let(T.unsafe(nil), Array)

# source://http-parser//lib/http-parser/parser.rb#233
class HttpParser::Parser::Callback < ::FFI::Function
  class << self
    # Creates a new Parser callback.
    #
    # source://http-parser//lib/http-parser/parser.rb#234
    def new(&block); end
  end
end

# source://http-parser//lib/http-parser/parser.rb#245
class HttpParser::Parser::DataCallback < ::FFI::Function
  class << self
    # source://http-parser//lib/http-parser/parser.rb#246
    def new(&block); end
  end
end

# source://http-parser//lib/http-parser/types.rb#315
class HttpParser::Settings < ::FFI::Struct; end

# These share a byte of data as a bitmap
#
# source://http-parser//lib/http-parser/types.rb#9
HttpParser::TYPES = T.let(T.unsafe(nil), FFI::Enum)

# source://http-parser//lib/http-parser/types.rb#71
HttpParser::UrlFields = T.let(T.unsafe(nil), FFI::Enum)
