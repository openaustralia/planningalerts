# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sidekiq` gem.
# Please instead update this file by running `bin/tapioca gem sidekiq`.


# Use `Sidekiq.transactional_push!` in your sidekiq.rb initializer
#
# source://sidekiq//lib/sidekiq/version.rb#3
module Sidekiq
  class << self
    # @yield [default_configuration]
    #
    # source://sidekiq//lib/sidekiq.rb#135
    def configure_client; end

    # Creates a Sidekiq::Config instance that is more tuned for embedding
    # within an arbitrary Ruby process. Notably it reduces concurrency by
    # default so there is less contention for CPU time with other threads.
    #
    #   inst = Sidekiq.configure_embed do |config|
    #     config.queues = %w[critical default low]
    #   end
    #   inst.run
    #   sleep 10
    #   inst.stop
    #
    # NB: it is really easy to overload a Ruby process with threads due to the GIL.
    # I do not recommend setting concurrency higher than 2-3.
    #
    # NB: Sidekiq only supports one instance in memory. You will get undefined behavior
    # if you try to embed Sidekiq twice in the same process.
    #
    # @yield [cfg]
    #
    # source://sidekiq//lib/sidekiq.rb#123
    def configure_embed(&block); end

    # @yield [default_configuration]
    #
    # source://sidekiq//lib/sidekiq.rb#97
    def configure_server(&block); end

    # source://sidekiq//lib/sidekiq.rb#89
    def default_configuration; end

    # source://sidekiq//lib/sidekiq.rb#85
    def default_job_options; end

    # source://sidekiq//lib/sidekiq.rb#81
    def default_job_options=(hash); end

    # source://sidekiq//lib/sidekiq.rb#57
    def dump_json(object); end

    # @return [Boolean]
    #
    # source://sidekiq//lib/sidekiq.rb#65
    def ent?; end

    # source://sidekiq//lib/sidekiq.rb#102
    def freeze!; end

    # source://sidekiq//lib/sidekiq.rb#53
    def load_json(string); end

    # source://sidekiq//lib/sidekiq.rb#93
    def logger; end

    # @return [Boolean]
    #
    # source://sidekiq//lib/sidekiq.rb#61
    def pro?; end

    # source://sidekiq//lib/sidekiq.rb#73
    def redis(&block); end

    # source://sidekiq//lib/sidekiq.rb#69
    def redis_pool; end

    # @return [Boolean]
    #
    # source://sidekiq//lib/sidekiq.rb#49
    def server?; end

    # source://sidekiq//lib/sidekiq.rb#77
    def strict_args!(mode = T.unsafe(nil)); end

    # source://sidekiq//lib/sidekiq/transaction_aware_client.rb#40
    def transactional_push!; end

    # source://sidekiq//lib/sidekiq.rb#45
    def ❨╯°□°❩╯︵┻━┻; end
  end
end

# source://sidekiq//lib/sidekiq/client.rb#8
class Sidekiq::Client
  include ::Sidekiq::JobUtil

  # Sidekiq::Client is responsible for pushing job payloads to Redis.
  # Requires the :pool or :config keyword argument.
  #
  #   Sidekiq::Client.new(pool: Sidekiq::RedisConnection.create)
  #
  # Inside the Sidekiq process, you can reuse the configured resources:
  #
  #   Sidekiq::Client.new(config: config)
  #
  # @param pool [ConnectionPool] explicit Redis pool to use
  # @param config [Sidekiq::Config] use the pool and middleware from the given Sidekiq container
  # @param chain [Sidekiq::Middleware::Chain] use the given middleware chain
  # @return [Client] a new instance of Client
  #
  # source://sidekiq//lib/sidekiq/client.rb#45
  def initialize(*args, **kwargs); end

  # Define client-side middleware:
  #
  #   client = Sidekiq::Client.new
  #   client.middleware do |chain|
  #     chain.use MyClientMiddleware
  #   end
  #   client.push('class' => 'SomeJob', 'args' => [1,2,3])
  #
  # All client instances default to the globally-defined
  # Sidekiq.client_middleware but you can change as necessary.
  #
  # source://sidekiq//lib/sidekiq/client.rb#23
  def middleware(&block); end

  # The main method used to push a job to Redis.  Accepts a number of options:
  #
  #   queue - the named queue to use, default 'default'
  #   class - the job class to call, required
  #   args - an array of simple arguments to the perform method, must be JSON-serializable
  #   at - timestamp to schedule the job (optional), must be Numeric (e.g. Time.now.to_f)
  #   retry - whether to retry this job if it fails, default true or an integer number of retries
  #   retry_for - relative amount of time to retry this job if it fails, default nil
  #   backtrace - whether to save any error backtrace, default false
  #
  # If class is set to the class name, the jobs' options will be based on Sidekiq's default
  # job options. Otherwise, they will be based on the job class's options.
  #
  # Any options valid for a job class's sidekiq_options are also available here.
  #
  # All keys must be strings, not symbols.  NB: because we are serializing to JSON, all
  # symbols in 'args' will be converted to strings.  Note that +backtrace: true+ can take quite a bit of
  # space in Redis; a large volume of failing jobs can start Redis swapping if you aren't careful.
  #
  # Returns a unique Job ID.  If middleware stops the job, nil will be returned instead.
  #
  # Example:
  #   push('queue' => 'my_queue', 'class' => MyJob, 'args' => ['foo', 1, :bat => 'bar'])
  #
  # source://sidekiq//lib/sidekiq/client.rb#86
  def push(item); end

  # Push a large number of jobs to Redis. This method cuts out the redis
  # network round trip latency. It pushes jobs in batches if more than
  # `:batch_size` (1000 by default) of jobs are passed. I wouldn't recommend making `:batch_size`
  # larger than 1000 but YMMV based on network quality, size of job args, etc.
  # A large number of jobs can cause a bit of Redis command processing latency.
  #
  # Takes the same arguments as #push except that args is expected to be
  # an Array of Arrays.  All other keys are duplicated for each job.  Each job
  # is run through the client middleware pipeline and each job gets its own Job ID
  # as normal.
  #
  # Returns an array of the of pushed jobs' jids, may contain nils if any client middleware
  # prevented a job push.
  #
  # Example (pushing jobs in batches):
  #   push_bulk('class' => MyJob, 'args' => (1..100_000).to_a, batch_size: 1_000)
  #
  # @raise [ArgumentError]
  #
  # source://sidekiq//lib/sidekiq/client.rb#116
  def push_bulk(items); end

  # Returns the value of attribute redis_pool.
  #
  # source://sidekiq//lib/sidekiq/client.rb#31
  def redis_pool; end

  # Sets the attribute redis_pool
  #
  # @param value the value to set the attribute redis_pool to.
  #
  # source://sidekiq//lib/sidekiq/client.rb#31
  def redis_pool=(_arg0); end

  private

  # source://sidekiq//lib/sidekiq/client.rb#248
  def atomic_push(conn, payloads); end

  # source://sidekiq//lib/sidekiq/client.rb#224
  def raw_push(payloads); end

  class << self
    # Resque compatibility helpers.  Note all helpers
    # should go through Sidekiq::Job#client_push.
    #
    # Example usage:
    #   Sidekiq::Client.enqueue(MyJob, 'foo', 1, :bat => 'bar')
    #
    # Messages are enqueued to the 'default' queue.
    #
    # source://sidekiq//lib/sidekiq/client.rb#189
    def enqueue(klass, *args); end

    # Example usage:
    #   Sidekiq::Client.enqueue_in(3.minutes, MyJob, 'foo', 1, :bat => 'bar')
    #
    # source://sidekiq//lib/sidekiq/client.rb#217
    def enqueue_in(interval, klass, *args); end

    # Example usage:
    #   Sidekiq::Client.enqueue_to(:queue_name, MyJob, 'foo', 1, :bat => 'bar')
    #
    # source://sidekiq//lib/sidekiq/client.rb#196
    def enqueue_to(queue, klass, *args); end

    # Example usage:
    #   Sidekiq::Client.enqueue_to_in(:queue_name, 3.minutes, MyJob, 'foo', 1, :bat => 'bar')
    #
    # source://sidekiq//lib/sidekiq/client.rb#203
    def enqueue_to_in(queue, interval, klass, *args); end

    # source://sidekiq//lib/sidekiq/client.rb#173
    def push(item); end

    # source://sidekiq//lib/sidekiq/client.rb#177
    def push_bulk(*_arg0, **_arg1, &_arg2); end

    # Allows sharding of jobs across any number of Redis instances.  All jobs
    # defined within the block will use the given Redis connection pool.
    #
    #   pool = ConnectionPool.new { Redis.new }
    #   Sidekiq::Client.via(pool) do
    #     SomeJob.perform_async(1,2,3)
    #     SomeOtherJob.perform_async(1,2,3)
    #   end
    #
    # Generally this is only needed for very large Sidekiq installs processing
    # thousands of jobs per second.  I do not recommend sharding unless
    # you cannot scale any other way (e.g. splitting your app into smaller apps).
    #
    # source://sidekiq//lib/sidekiq/client.rb#163
    def via(pool); end
  end
end

# no difference for now
#
# source://sidekiq//lib/sidekiq/middleware/modules.rb#20
Sidekiq::ClientMiddleware = Sidekiq::ServerMiddleware

# Sidekiq::Component assumes a config instance is available at @config
#
# source://sidekiq//lib/sidekiq/component.rb#6
module Sidekiq::Component
  # source://sidekiq//lib/sidekiq/component.rb#7
  def config; end

  # source://sidekiq//lib/sidekiq/component.rb#51
  def fire_event(event, options = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/component.rb#47
  def handle_exception(ex, ctx = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/component.rb#35
  def hostname; end

  # source://sidekiq//lib/sidekiq/component.rb#43
  def identity; end

  # source://sidekiq//lib/sidekiq/component.rb#23
  def logger; end

  # source://sidekiq//lib/sidekiq/component.rb#39
  def process_nonce; end

  # source://sidekiq//lib/sidekiq/component.rb#27
  def redis(&block); end

  # source://sidekiq//lib/sidekiq/component.rb#16
  def safe_thread(name, &block); end

  # source://sidekiq//lib/sidekiq/component.rb#31
  def tid; end

  # source://sidekiq//lib/sidekiq/component.rb#9
  def watchdog(last_words); end
end

# Sidekiq::Config represents the global configuration for an instance of Sidekiq.
#
# source://sidekiq//lib/sidekiq/config.rb#8
class Sidekiq::Config
  extend ::Forwardable

  # @return [Config] a new instance of Config
  #
  # source://sidekiq//lib/sidekiq/config.rb#51
  def initialize(options = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def [](*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def []=(*args, **_arg1, &block); end

  # How frequently Redis should be checked by a random Sidekiq process for
  # scheduled and retriable jobs. Each individual process will take turns by
  # waiting some multiple of this value.
  #
  # See sidekiq/scheduled.rb for an in-depth explanation of this value
  #
  # source://sidekiq//lib/sidekiq/config.rb#216
  def average_scheduled_poll_interval=(interval); end

  # register a new queue processing subsystem
  #
  # @yield [cap]
  #
  # source://sidekiq//lib/sidekiq/config.rb#115
  def capsule(name); end

  # Returns the value of attribute capsules.
  #
  # source://sidekiq//lib/sidekiq/config.rb#60
  def capsules; end

  # @yield [@client_chain]
  #
  # source://sidekiq//lib/sidekiq/config.rb#98
  def client_middleware; end

  # source://sidekiq//lib/sidekiq/config.rb#72
  def concurrency; end

  # LEGACY: edits the default capsule
  # config.concurrency = 5
  #
  # source://sidekiq//lib/sidekiq/config.rb#68
  def concurrency=(val); end

  # Death handlers are called when all retries for a job have been exhausted and
  # the job dies.  It's the notification to your application
  # that this job will not succeed without manual intervention.
  #
  # Sidekiq.configure_server do |config|
  #   config.death_handlers << ->(job, ex) do
  #   end
  # end
  #
  # source://sidekiq//lib/sidekiq/config.rb#207
  def death_handlers; end

  # source://sidekiq//lib/sidekiq/config.rb#110
  def default_capsule(&block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def dig(*args, **_arg1, &block); end

  # Register a proc to handle any error which occurs within the Sidekiq process.
  #
  #   Sidekiq.configure_server do |config|
  #     config.error_handlers << proc {|ex,ctx_hash| MyErrorService.notify(ex, ctx_hash) }
  #   end
  #
  # The default error handler logs errors to @logger.
  #
  # source://sidekiq//lib/sidekiq/config.rb#227
  def error_handlers; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def fetch(*args, **_arg1, &block); end

  # INTERNAL USE ONLY
  #
  # source://sidekiq//lib/sidekiq/config.rb#271
  def handle_exception(ex, ctx = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def has_key?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def key?(*args, **_arg1, &block); end

  # source://sidekiq//lib/sidekiq/config.rb#245
  def logger; end

  # source://sidekiq//lib/sidekiq/config.rb#256
  def logger=(logger); end

  # find a singleton
  #
  # source://sidekiq//lib/sidekiq/config.rb#190
  def lookup(name, default_class = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def merge!(*args, **_arg1, &block); end

  # source://sidekiq//lib/sidekiq/config.rb#140
  def new_redis_pool(size, name = T.unsafe(nil)); end

  # Register a block to run at a point in the Sidekiq lifecycle.
  # :startup, :quiet or :shutdown are valid events.
  #
  #   Sidekiq.configure_server do |config|
  #     config.on(:shutdown) do
  #       puts "Goodbye cruel world!"
  #     end
  #   end
  #
  # @raise [ArgumentError]
  #
  # source://sidekiq//lib/sidekiq/config.rb#239
  def on(event, &block); end

  # source://sidekiq//lib/sidekiq/config.rb#94
  def queues; end

  # Edit the default capsule.
  # config.queues = %w( high default low )                 # strict
  # config.queues = %w( high,3 default,2 low,1 )           # weighted
  # config.queues = %w( feature1,1 feature2,1 feature3,1 ) # random
  #
  # With weighted priority, queue will be checked first (weight / total) of the time.
  # high will be checked first (3/6) or 50% of the time.
  # I'd recommend setting weights between 1-10. Weights in the hundreds or thousands
  # are ridiculous and unnecessarily expensive. You can get random queue ordering
  # by explicitly setting all weights to 1.
  #
  # source://sidekiq//lib/sidekiq/config.rb#90
  def queues=(val); end

  # @raise [ArgumentError]
  #
  # source://sidekiq//lib/sidekiq/config.rb#162
  def redis; end

  # All capsules must use the same Redis configuration
  #
  # source://sidekiq//lib/sidekiq/config.rb#126
  def redis=(hash); end

  # source://sidekiq//lib/sidekiq/config.rb#146
  def redis_info; end

  # source://sidekiq//lib/sidekiq/config.rb#130
  def redis_pool; end

  # register global singletons which can be accessed elsewhere
  #
  # source://sidekiq//lib/sidekiq/config.rb#185
  def register(name, instance); end

  # @yield [@server_chain]
  #
  # source://sidekiq//lib/sidekiq/config.rb#104
  def server_middleware; end

  # source://sidekiq//lib/sidekiq/config.rb#62
  def to_json(*_arg0); end

  # source://sidekiq//lib/sidekiq/config.rb#76
  def total_concurrency; end

  private

  # source://sidekiq//lib/sidekiq/config.rb#134
  def local_redis_pool; end

  # source://sidekiq//lib/sidekiq/config.rb#265
  def parameter_size(handler); end
end

# source://sidekiq//lib/sidekiq/config.rb#11
Sidekiq::Config::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://sidekiq//lib/sidekiq/config.rb#41
Sidekiq::Config::ERROR_HANDLER = T.let(T.unsafe(nil), Proc)

# source://sidekiq//lib/sidekiq/logger.rb#7
module Sidekiq::Context
  class << self
    # source://sidekiq//lib/sidekiq/logger.rb#20
    def add(k, v); end

    # source://sidekiq//lib/sidekiq/logger.rb#16
    def current; end

    # source://sidekiq//lib/sidekiq/logger.rb#8
    def with(hash); end
  end
end

# The set of dead jobs within Sidekiq. Dead jobs have failed all of
# their retries and are helding in this set pending some sort of manual
# fix. They will be removed after 6 months (dead_timeout) if not.
#
# source://sidekiq//lib/sidekiq/api.rb#809
class Sidekiq::DeadSet < ::Sidekiq::JobSet
  # @return [DeadSet] a new instance of DeadSet
  #
  # source://sidekiq//lib/sidekiq/api.rb#810
  def initialize; end

  # Add the given job to the Dead set.
  #
  # @param message [String] the job data as JSON
  #
  # source://sidekiq//lib/sidekiq/api.rb#816
  def kill(message, opts = T.unsafe(nil)); end

  # Enqueue all dead jobs
  #
  # source://sidekiq//lib/sidekiq/api.rb#838
  def retry_all; end
end

# source://sidekiq//lib/sidekiq/iterable_job.rb#32
module Sidekiq::IterableJob
  include ::Sidekiq::Job::Options
  include ::Sidekiq::Job
  include ::Sidekiq::Job::Iterable

  mixes_in_class_methods ::Sidekiq::Job::Options::ClassMethods
  mixes_in_class_methods ::Sidekiq::Job::ClassMethods
  mixes_in_class_methods ::Sidekiq::Job::Iterable::ClassMethods

  class << self
    # @private
    #
    # source://sidekiq//lib/sidekiq/iterable_job.rb#33
    def included(base); end
  end
end

# Include this module in your job class and you can easily create
# asynchronous jobs:
#
#   class HardJob
#     include Sidekiq::Job
#     sidekiq_options queue: 'critical', retry: 5
#
#     def perform(*args)
#       # do some work
#     end
#   end
#
# Then in your Rails app, you can do this:
#
#   HardJob.perform_async(1, 2, 3)
#
# Note that perform_async is a class method, perform is an instance method.
#
# Sidekiq::Job also includes several APIs to provide compatibility with
# ActiveJob.
#
#   class SomeJob
#     include Sidekiq::Job
#     queue_as :critical
#
#     def perform(...)
#     end
#   end
#
#   SomeJob.set(wait_until: 1.hour).perform_async(123)
#
# Note that arguments passed to the job must still obey Sidekiq's
# best practice for simple, JSON-native data types. Sidekiq will not
# implement ActiveJob's more complex argument serialization. For
# this reason, we don't implement `perform_later` as our call semantics
# are very different.
#
# source://sidekiq//lib/sidekiq/job.rb#44
module Sidekiq::Job
  include ::Sidekiq::Job::Options

  mixes_in_class_methods ::Sidekiq::Job::Options::ClassMethods
  mixes_in_class_methods ::Sidekiq::Job::ClassMethods

  # This attribute is implementation-specific and not a public API
  #
  # source://sidekiq//lib/sidekiq/job.rb#163
  def _context; end

  # This attribute is implementation-specific and not a public API
  #
  # source://sidekiq//lib/sidekiq/job.rb#163
  def _context=(_arg0); end

  # @return [Boolean]
  #
  # source://sidekiq//lib/sidekiq/job.rb#176
  def interrupted?; end

  # Returns the value of attribute jid.
  #
  # source://sidekiq//lib/sidekiq/job.rb#160
  def jid; end

  # Sets the attribute jid
  #
  # @param value the value to set the attribute jid to.
  #
  # source://sidekiq//lib/sidekiq/job.rb#160
  def jid=(_arg0); end

  # source://sidekiq//lib/sidekiq/job.rb#172
  def logger; end

  class << self
    # @private
    # @raise [ArgumentError]
    #
    # source://sidekiq//lib/sidekiq/job.rb#165
    def included(base); end
  end
end

# The Sidekiq testing infrastructure overrides perform_async
# so that it does not actually touch the network.  Instead it
# stores the asynchronous jobs in a per-class array so that
# their presence/absence can be asserted by your tests.
#
# This is similar to ActionMailer's :test delivery_method and its
# ActionMailer::Base.deliveries array.
#
# Example:
#
#   require 'sidekiq/testing'
#
#   assert_equal 0, HardJob.jobs.size
#   HardJob.perform_async(:something)
#   assert_equal 1, HardJob.jobs.size
#   assert_equal :something, HardJob.jobs[0]['args'][0]
#
# You can also clear and drain all job types:
#
#   Sidekiq::Job.clear_all # or .drain_all
#
# This can be useful to make sure jobs don't linger between tests:
#
#   RSpec.configure do |config|
#     config.before(:each) do
#       Sidekiq::Job.clear_all
#     end
#   end
#
# or for acceptance testing, i.e. with cucumber:
#
#   AfterStep do
#     Sidekiq::Job.drain_all
#   end
#
#   When I sign up as "foo@example.com"
#   Then I should receive a welcome email to "foo@example.com"
#
# source://sidekiq//lib/sidekiq/job.rb#275
module Sidekiq::Job::ClassMethods
  # source://sidekiq//lib/sidekiq/job.rb#378
  def build_client; end

  # @raise [ArgumentError]
  #
  # source://sidekiq//lib/sidekiq/job.rb#363
  def client_push(item); end

  # @raise [ArgumentError]
  #
  # source://sidekiq//lib/sidekiq/job.rb#276
  def delay(*args); end

  # @raise [ArgumentError]
  #
  # source://sidekiq//lib/sidekiq/job.rb#280
  def delay_for(*args); end

  # @raise [ArgumentError]
  #
  # source://sidekiq//lib/sidekiq/job.rb#284
  def delay_until(*args); end

  # source://sidekiq//lib/sidekiq/job.rb#296
  def perform_async(*args); end

  # +interval+ must be a timestamp, numeric or something that acts
  #   numeric (like an activesupport time interval).
  #
  # source://sidekiq//lib/sidekiq/job.rb#332
  def perform_at(interval, *args); end

  # Push a large number of jobs to Redis, while limiting the batch of
  # each job payload to 1,000. This method helps cut down on the number
  # of round trips to Redis, which can increase the performance of enqueueing
  # large numbers of jobs.
  #
  # +items+ must be an Array of Arrays.
  #
  # For finer-grained control, use `Sidekiq::Client.push_bulk` directly.
  #
  # Example (3 Redis round trips):
  #
  #     SomeJob.perform_async(1)
  #     SomeJob.perform_async(2)
  #     SomeJob.perform_async(3)
  #
  # Would instead become (1 Redis round trip):
  #
  #     SomeJob.perform_bulk([[1], [2], [3]])
  #
  # source://sidekiq//lib/sidekiq/job.rb#326
  def perform_bulk(*args, **kwargs); end

  # +interval+ must be a timestamp, numeric or something that acts
  #   numeric (like an activesupport time interval).
  #
  # source://sidekiq//lib/sidekiq/job.rb#332
  def perform_in(interval, *args); end

  # Inline execution of job's perform method after passing through Sidekiq.client_middleware and Sidekiq.server_middleware
  #
  # source://sidekiq//lib/sidekiq/job.rb#301
  def perform_inline(*args); end

  # Inline execution of job's perform method after passing through Sidekiq.client_middleware and Sidekiq.server_middleware
  #
  # source://sidekiq//lib/sidekiq/job.rb#301
  def perform_sync(*args); end

  # source://sidekiq//lib/sidekiq/job.rb#288
  def queue_as(q); end

  # source://sidekiq//lib/sidekiq/job.rb#292
  def set(options); end

  # Allows customization for this type of Job.
  # Legal options:
  #
  #   queue - use a named queue for this Job, default 'default'
  #   retry - enable the RetryJobs middleware for this Job, *true* to use the default
  #      or *Integer* count
  #   backtrace - whether to save any error backtrace in the retry payload to display in web UI,
  #      can be true, false or an integer number of lines to save, default *false*
  #   pool - use the given Redis connection pool to push this type of job to a given shard.
  #
  # In practice, any option is allowed.  This is the main mechanism to configure the
  # options for a specific job.
  #
  # source://sidekiq//lib/sidekiq/job.rb#359
  def sidekiq_options(opts = T.unsafe(nil)); end
end

# source://sidekiq//lib/sidekiq/job/iterable.rb#7
class Sidekiq::Job::Interrupted < ::RuntimeError; end

# source://sidekiq//lib/sidekiq/job/iterable/active_record_enumerator.rb#5
module Sidekiq::Job::Iterable
  include ::Sidekiq::Job::Iterable::Enumerators

  mixes_in_class_methods ::Sidekiq::Job::Iterable::ClassMethods

  # @api private
  #
  # source://sidekiq//lib/sidekiq/job/iterable.rb#26
  def initialize; end

  # A hook to override that will be called around each iteration.
  #
  # Can be useful for some metrics collection, performance tracking etc.
  #
  # source://sidekiq//lib/sidekiq/job/iterable.rb#46
  def around_iteration; end

  # The enumerator to be iterated over.
  #
  # @raise [NotImplementedError] with a message advising subclasses to
  #   implement an override for this method.
  # @return [Enumerator]
  #
  # source://sidekiq//lib/sidekiq/job/iterable.rb#74
  def build_enumerator(*_arg0); end

  # The action to be performed on each item from the enumerator.
  #
  # @raise [NotImplementedError] with a message advising subclasses to
  #   implement an override for this method.
  # @return [void]
  #
  # source://sidekiq//lib/sidekiq/job/iterable.rb#85
  def each_iteration(*_arg0); end

  # source://sidekiq//lib/sidekiq/job/iterable.rb#89
  def iteration_key; end

  # A hook to override that will be called when the job finished iterating.
  #
  # source://sidekiq//lib/sidekiq/job/iterable.rb#64
  def on_complete; end

  # A hook to override that will be called when the job resumes iterating.
  #
  # source://sidekiq//lib/sidekiq/job/iterable.rb#52
  def on_resume; end

  # A hook to override that will be called when the job starts iterating.
  #
  # It is called only once, for the first time.
  #
  # source://sidekiq//lib/sidekiq/job/iterable.rb#39
  def on_start; end

  # A hook to override that will be called each time the job is interrupted.
  #
  # This can be due to interruption or sidekiq stopping.
  #
  # source://sidekiq//lib/sidekiq/job/iterable.rb#59
  def on_stop; end

  # @api private
  #
  # source://sidekiq//lib/sidekiq/job/iterable.rb#94
  def perform(*arguments); end

  private

  # source://sidekiq//lib/sidekiq/job/iterable.rb#180
  def assert_enumerator!(enum); end

  # source://sidekiq//lib/sidekiq/job/iterable.rb#211
  def cleanup; end

  # source://sidekiq//lib/sidekiq/job/iterable.rb#131
  def fetch_previous_iteration_state; end

  # source://sidekiq//lib/sidekiq/job/iterable.rb#195
  def flush_state; end

  # source://sidekiq//lib/sidekiq/job/iterable.rb#218
  def handle_completed(completed); end

  # one month
  #
  # source://sidekiq//lib/sidekiq/job/iterable.rb#146
  def iterate_with_enumerator(enumerator, arguments); end

  # @raise [Interrupted]
  #
  # source://sidekiq//lib/sidekiq/job/iterable.rb#173
  def reenqueue_iteration_job; end

  class << self
    # @api private
    # @private
    #
    # source://sidekiq//lib/sidekiq/job/iterable.rb#13
    def included(base); end
  end
end

# @api private
#
# source://sidekiq//lib/sidekiq/job/iterable/active_record_enumerator.rb#7
class Sidekiq::Job::Iterable::ActiveRecordEnumerator
  # @api private
  # @return [ActiveRecordEnumerator] a new instance of ActiveRecordEnumerator
  #
  # source://sidekiq//lib/sidekiq/job/iterable/active_record_enumerator.rb#8
  def initialize(relation, cursor: T.unsafe(nil), **options); end

  # @api private
  #
  # source://sidekiq//lib/sidekiq/job/iterable/active_record_enumerator.rb#22
  def batches; end

  # @api private
  #
  # source://sidekiq//lib/sidekiq/job/iterable/active_record_enumerator.rb#14
  def records; end

  # @api private
  #
  # source://sidekiq//lib/sidekiq/job/iterable/active_record_enumerator.rb#30
  def relations; end

  private

  # @api private
  #
  # source://sidekiq//lib/sidekiq/job/iterable/active_record_enumerator.rb#46
  def relations_size; end
end

# @api private
#
# source://sidekiq//lib/sidekiq/job/iterable.rb#18
module Sidekiq::Job::Iterable::ClassMethods
  # @api private
  #
  # source://sidekiq//lib/sidekiq/job/iterable.rb#19
  def method_added(method_name); end
end

# @api private
#
# source://sidekiq//lib/sidekiq/job/iterable/csv_enumerator.rb#7
class Sidekiq::Job::Iterable::CsvEnumerator
  # @api private
  # @return [CsvEnumerator] a new instance of CsvEnumerator
  #
  # source://sidekiq//lib/sidekiq/job/iterable/csv_enumerator.rb#8
  def initialize(csv); end

  # @api private
  #
  # source://sidekiq//lib/sidekiq/job/iterable/csv_enumerator.rb#23
  def batches(cursor:, batch_size: T.unsafe(nil)); end

  # @api private
  #
  # source://sidekiq//lib/sidekiq/job/iterable/csv_enumerator.rb#16
  def rows(cursor:); end

  private

  # @api private
  #
  # source://sidekiq//lib/sidekiq/job/iterable/csv_enumerator.rb#33
  def count_of_rows_in_file; end
end

# source://sidekiq//lib/sidekiq/job/iterable/enumerators.rb#9
module Sidekiq::Job::Iterable::Enumerators
  # Builds Enumerator from `ActiveRecord::Relation` and enumerates on batches of records.
  # Each Enumerator tick moves the cursor `:batch_size` rows forward.
  #
  # @example
  #   def build_enumerator(product_id, cursor:)
  #   active_record_batches_enumerator(
  #   Comment.where(product_id: product_id).select(:id),
  #   cursor: cursor,
  #   batch_size: 100
  #   )
  #   end
  #
  #   def each_iteration(batch_of_comments, product_id)
  #   comment_ids = batch_of_comments.map(&:id)
  #   CommentService.call(comment_ids: comment_ids)
  #   end
  # @see #active_record_records_enumerator
  #
  # source://sidekiq//lib/sidekiq/job/iterable/enumerators.rb#68
  def active_record_batches_enumerator(relation, cursor:, **options); end

  # Builds Enumerator from `ActiveRecord::Relation`.
  # Each Enumerator tick moves the cursor one row forward.
  #
  # @example
  #   def build_enumerator(cursor:)
  #   active_record_records_enumerator(User.all, cursor: cursor)
  #   end
  #
  #   def each_iteration(user)
  #   user.notify_about_something
  #   end
  # @param relation [ActiveRecord::Relation] relation to iterate
  # @param cursor [Object] offset id to start iteration from
  # @param options [Hash] additional options that will be passed to relevant
  #   ActiveRecord batching methods
  # @return [ActiveRecordEnumerator]
  #
  # source://sidekiq//lib/sidekiq/job/iterable/enumerators.rb#46
  def active_record_records_enumerator(relation, cursor:, **options); end

  # Builds Enumerator from `ActiveRecord::Relation` and enumerates on batches,
  # yielding `ActiveRecord::Relation`s.
  #
  # @example
  #   def build_enumerator(product_id, cursor:)
  #   active_record_relations_enumerator(
  #   Product.find(product_id).comments,
  #   cursor: cursor,
  #   batch_size: 100,
  #   )
  #   end
  #
  #   def each_iteration(batch_of_comments, product_id)
  #   # batch_of_comments will be a Comment::ActiveRecord_Relation
  #   batch_of_comments.update_all(deleted: true)
  #   end
  # @see #active_record_records_enumerator
  #
  # source://sidekiq//lib/sidekiq/job/iterable/enumerators.rb#90
  def active_record_relations_enumerator(relation, cursor:, **options); end

  # Builds Enumerator object from a given array, using +cursor+ as an offset.
  #
  # @example
  #   array_enumerator(['build', 'enumerator', 'from', 'any', 'array'], cursor: cursor)
  # @param array [Array]
  # @param cursor [Integer] offset to start iteration from
  # @raise [ArgumentError]
  # @return [Enumerator]
  #
  # source://sidekiq//lib/sidekiq/job/iterable/enumerators.rb#20
  def array_enumerator(array, cursor:); end

  # Builds Enumerator from a CSV file and enumerates on batches of records.
  #
  # @example
  #   def build_enumerator(import_id, cursor:)
  #   import = Import.find(import_id)
  #   csv_batches_enumerator(import.csv, cursor: cursor)
  #   end
  #
  #   def each_iteration(batch_of_csv_rows)
  #   # ...
  #   end
  # @option options
  # @param csv [CSV] an instance of CSV object
  # @param cursor [Integer] offset to start iteration from
  # @param options [Hash] a customizable set of options
  #
  # source://sidekiq//lib/sidekiq/job/iterable/enumerators.rb#129
  def csv_batches_enumerator(csv, cursor:, **options); end

  # Builds Enumerator from a CSV file.
  #
  # @example
  #   def build_enumerator(import_id, cursor:)
  #   import = Import.find(import_id)
  #   csv_enumerator(import.csv, cursor: cursor)
  #   end
  #
  #   def each_iteration(csv_row)
  #   # insert csv_row into database
  #   end
  # @param csv [CSV] an instance of CSV object
  # @param cursor [Integer] offset to start iteration from
  #
  # source://sidekiq//lib/sidekiq/job/iterable/enumerators.rb#109
  def csv_enumerator(csv, cursor:); end
end

# seconds
#
# source://sidekiq//lib/sidekiq/job/iterable.rb#141
Sidekiq::Job::Iterable::STATE_FLUSH_INTERVAL = T.let(T.unsafe(nil), Integer)

# we need to keep the state around as long as the job
# might be retrying
#
# source://sidekiq//lib/sidekiq/job/iterable.rb#144
Sidekiq::Job::Iterable::STATE_TTL = T.let(T.unsafe(nil), Integer)

# The Options module is extracted so we can include it in ActiveJob::Base
# and allow native AJs to configure Sidekiq features/internals.
#
# source://sidekiq//lib/sidekiq/job.rb#48
module Sidekiq::Job::Options
  mixes_in_class_methods ::Sidekiq::Job::Options::ClassMethods

  class << self
    # @private
    #
    # source://sidekiq//lib/sidekiq/job.rb#49
    def included(base); end
  end
end

# source://sidekiq//lib/sidekiq/job.rb#56
module Sidekiq::Job::Options::ClassMethods
  # source://sidekiq//lib/sidekiq/job.rb#88
  def get_sidekiq_options; end

  # source://sidekiq//lib/sidekiq/job.rb#92
  def sidekiq_class_attribute(*attrs); end

  # Allows customization for this type of Job.
  # Legal options:
  #
  #   queue - name of queue to use for this job type, default *default*
  #   retry - enable retries for this Job in case of error during execution,
  #      *true* to use the default or *Integer* count
  #   backtrace - whether to save any error backtrace in the retry payload to display in web UI,
  #      can be true, false or an integer number of lines to save, default *false*
  #
  # In practice, any option is allowed.  This is the main mechanism to configure the
  # options for a specific job.
  #
  # source://sidekiq//lib/sidekiq/job.rb#71
  def sidekiq_options(opts = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/job.rb#84
  def sidekiq_retries_exhausted(&block); end

  # source://sidekiq//lib/sidekiq/job.rb#80
  def sidekiq_retry_in(&block); end
end

# source://sidekiq//lib/sidekiq/job.rb#57
Sidekiq::Job::Options::ClassMethods::ACCESSOR_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)

# This helper class encapsulates the set options for `set`, e.g.
#
#     SomeJob.set(queue: 'foo').perform_async(....)
#
# source://sidekiq//lib/sidekiq/job.rb#184
class Sidekiq::Job::Setter
  include ::Sidekiq::JobUtil

  # @return [Setter] a new instance of Setter
  #
  # source://sidekiq//lib/sidekiq/job.rb#187
  def initialize(klass, opts); end

  # source://sidekiq//lib/sidekiq/job.rb#205
  def perform_async(*args); end

  # +interval+ must be a timestamp, numeric or something that acts
  #   numeric (like an activesupport time interval).
  #
  # source://sidekiq//lib/sidekiq/job.rb#258
  def perform_at(interval, *args); end

  # source://sidekiq//lib/sidekiq/job.rb#251
  def perform_bulk(args, batch_size: T.unsafe(nil)); end

  # +interval+ must be a timestamp, numeric or something that acts
  #   numeric (like an activesupport time interval).
  #
  # source://sidekiq//lib/sidekiq/job.rb#258
  def perform_in(interval, *args); end

  # Explicit inline execution of a job. Returns nil if the job did not
  # execute, true otherwise.
  #
  # source://sidekiq//lib/sidekiq/job.rb#215
  def perform_inline(*args); end

  # Explicit inline execution of a job. Returns nil if the job did not
  # execute, true otherwise.
  #
  # source://sidekiq//lib/sidekiq/job.rb#215
  def perform_sync(*args); end

  # source://sidekiq//lib/sidekiq/job.rb#197
  def set(options); end

  private

  # source://sidekiq//lib/sidekiq/job.rb#265
  def at(interval); end
end

# Represents a pending job within a Sidekiq queue.
#
# The job should be considered immutable but may be
# removed from the queue via JobRecord#delete.
#
# source://sidekiq//lib/sidekiq/api.rb#334
class Sidekiq::JobRecord
  # @api private
  # @return [JobRecord] a new instance of JobRecord
  #
  # source://sidekiq//lib/sidekiq/api.rb#347
  def initialize(item, queue_name = T.unsafe(nil)); end

  # Access arbitrary attributes within the job hash
  #
  # source://sidekiq//lib/sidekiq/api.rb#460
  def [](name); end

  # source://sidekiq//lib/sidekiq/api.rb#412
  def args; end

  # source://sidekiq//lib/sidekiq/api.rb#420
  def bid; end

  # source://sidekiq//lib/sidekiq/api.rb#428
  def created_at; end

  # Remove this job from the queue
  #
  # source://sidekiq//lib/sidekiq/api.rb#452
  def delete; end

  # source://sidekiq//lib/sidekiq/api.rb#390
  def display_args; end

  # source://sidekiq//lib/sidekiq/api.rb#373
  def display_class; end

  # source://sidekiq//lib/sidekiq/api.rb#424
  def enqueued_at; end

  # source://sidekiq//lib/sidekiq/api.rb#436
  def error_backtrace; end

  # the parsed Hash of job data
  #
  # source://sidekiq//lib/sidekiq/api.rb#337
  def item; end

  # source://sidekiq//lib/sidekiq/api.rb#416
  def jid; end

  # This is the job class which Sidekiq will execute. If using ActiveJob,
  # this class will be the ActiveJob adapter class rather than a specific job.
  #
  # source://sidekiq//lib/sidekiq/api.rb#369
  def klass; end

  # source://sidekiq//lib/sidekiq/api.rb#446
  def latency; end

  # @api private
  #
  # source://sidekiq//lib/sidekiq/api.rb#356
  def parse(item); end

  # the queue associated with this job
  #
  # source://sidekiq//lib/sidekiq/api.rb#343
  def queue; end

  # source://sidekiq//lib/sidekiq/api.rb#432
  def tags; end

  # the underlying String in Redis
  #
  # source://sidekiq//lib/sidekiq/api.rb#340
  def value; end

  private

  # source://sidekiq//lib/sidekiq/api.rb#472
  def deserialize_argument(argument); end

  # @return [Boolean]
  #
  # source://sidekiq//lib/sidekiq/api.rb#488
  def serialized_global_id?(hash); end

  # source://sidekiq//lib/sidekiq/api.rb#492
  def uncompress_backtrace(backtrace); end
end

# source://sidekiq//lib/sidekiq/api.rb#469
Sidekiq::JobRecord::ACTIVE_JOB_PREFIX = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/api.rb#470
Sidekiq::JobRecord::GLOBALID_KEY = T.let(T.unsafe(nil), String)

# Base class for all sorted sets which contain jobs, e.g. scheduled, retry and dead.
# Sidekiq Pro and Enterprise add additional sorted sets which do not contain job data,
# e.g. Batches.
#
# source://sidekiq//lib/sidekiq/api.rb#661
class Sidekiq::JobSet < ::Sidekiq::SortedSet
  # @api private
  #
  # source://sidekiq//lib/sidekiq/api.rb#747
  def delete(score, jid); end

  # @api private
  #
  # source://sidekiq//lib/sidekiq/api.rb#747
  def delete_by_jid(score, jid); end

  # @api private
  #
  # source://sidekiq//lib/sidekiq/api.rb#737
  def delete_by_value(name, value); end

  # source://sidekiq//lib/sidekiq/api.rb#671
  def each; end

  # Fetch jobs that match a given time or Range. Job ID is an
  # optional second argument.
  #
  # @param score [Time, Range] a specific timestamp or range
  # @param jid [String, optional] find a specific JID within the score
  # @return [Array<SortedEntry>] any results found, can be empty
  #
  # source://sidekiq//lib/sidekiq/api.rb#699
  def fetch(score, jid = T.unsafe(nil)); end

  # Find the job with the given JID within this sorted set.
  # *This is a slow O(n) operation*.  Do not use for app logic.
  #
  # @param jid [String] the job identifier
  # @return [SortedEntry] the record or nil
  #
  # source://sidekiq//lib/sidekiq/api.rb#724
  def find_job(jid); end

  # Add a job with the associated timestamp to this set.
  #
  # @param timestamp [Time] the score for the job
  # @param job [Hash] the job data
  #
  # source://sidekiq//lib/sidekiq/api.rb#665
  def schedule(timestamp, job); end
end

# source://sidekiq//lib/sidekiq/job_util.rb#5
module Sidekiq::JobUtil
  # @raise [ArgumentError]
  #
  # source://sidekiq//lib/sidekiq/job_util.rb#41
  def normalize_item(item); end

  # source://sidekiq//lib/sidekiq/job_util.rb#63
  def normalized_hash(item_class); end

  # @raise [ArgumentError]
  #
  # source://sidekiq//lib/sidekiq/job_util.rb#10
  def validate(item); end

  # source://sidekiq//lib/sidekiq/job_util.rb#19
  def verify_json(item); end

  private

  # @return [Boolean]
  #
  # source://sidekiq//lib/sidekiq/job_util.rb#103
  def json_unsafe?(item); end
end

# source://sidekiq//lib/sidekiq/job_util.rb#74
Sidekiq::JobUtil::RECURSIVE_JSON_UNSAFE = T.let(T.unsafe(nil), Hash)

# These functions encapsulate various job utilities.
#
# source://sidekiq//lib/sidekiq/job_util.rb#8
Sidekiq::JobUtil::TRANSIENT_ATTRIBUTES = T.let(T.unsafe(nil), Array)

# source://sidekiq//lib/sidekiq.rb#43
Sidekiq::LICENSE = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/logger.rb#75
class Sidekiq::Logger < ::Logger
  include ::Sidekiq::LoggingUtils
end

# source://sidekiq//lib/sidekiq/logger.rb#78
module Sidekiq::Logger::Formatters; end

# source://sidekiq//lib/sidekiq/logger.rb#79
class Sidekiq::Logger::Formatters::Base < ::Logger::Formatter
  # source://sidekiq//lib/sidekiq/logger.rb#84
  def ctx; end

  # source://sidekiq//lib/sidekiq/logger.rb#88
  def format_context; end

  # source://sidekiq//lib/sidekiq/logger.rb#80
  def tid; end
end

# source://sidekiq//lib/sidekiq/logger.rb#114
class Sidekiq::Logger::Formatters::JSON < ::Sidekiq::Logger::Formatters::Base
  # source://sidekiq//lib/sidekiq/logger.rb#115
  def call(severity, time, program_name, message); end
end

# source://sidekiq//lib/sidekiq/logger.rb#102
class Sidekiq::Logger::Formatters::Pretty < ::Sidekiq::Logger::Formatters::Base
  # source://sidekiq//lib/sidekiq/logger.rb#103
  def call(severity, time, program_name, message); end
end

# source://sidekiq//lib/sidekiq/logger.rb#108
class Sidekiq::Logger::Formatters::WithoutTimestamp < ::Sidekiq::Logger::Formatters::Pretty
  # source://sidekiq//lib/sidekiq/logger.rb#109
  def call(severity, time, program_name, message); end
end

# source://sidekiq//lib/sidekiq/logger.rb#25
module Sidekiq::LoggingUtils
  # source://sidekiq//lib/sidekiq/logger.rb#39
  def debug?; end

  # source://sidekiq//lib/sidekiq/logger.rb#39
  def error?; end

  # source://sidekiq//lib/sidekiq/logger.rb#39
  def fatal?; end

  # source://sidekiq//lib/sidekiq/logger.rb#39
  def info?; end

  # source://sidekiq//lib/sidekiq/logger.rb#61
  def level; end

  # source://sidekiq//lib/sidekiq/logger.rb#44
  def local_level; end

  # source://sidekiq//lib/sidekiq/logger.rb#48
  def local_level=(level); end

  # Change the thread-local level for the duration of the given block.
  #
  # source://sidekiq//lib/sidekiq/logger.rb#66
  def log_at(level); end

  # source://sidekiq//lib/sidekiq/logger.rb#39
  def warn?; end
end

# source://sidekiq//lib/sidekiq/logger.rb#26
Sidekiq::LoggingUtils::LEVELS = T.let(T.unsafe(nil), Hash)

# source://sidekiq//lib/sidekiq/version.rb#5
Sidekiq::MAJOR = T.let(T.unsafe(nil), Integer)

# source://sidekiq//lib/sidekiq/metrics/shared.rb#4
module Sidekiq::Metrics; end

# This is the only dependency on concurrent-ruby in Sidekiq but it's
# mandatory for thread-safety until MRI supports atomic operations on values.
#
# source://sidekiq//lib/sidekiq/metrics/shared.rb#7
Sidekiq::Metrics::Counter = Concurrent::AtomicFixnum

# Implements space-efficient but statistically useful histogram storage.
# A precise time histogram stores every time. Instead we break times into a set of
# known buckets and increment counts of the associated time bucket. Even if we call
# the histogram a million times, we'll still only store 26 buckets.
# NB: needs to be thread-safe or resiliant to races.
#
# To store this data, we use Redis' BITFIELD command to store unsigned 16-bit counters
# per bucket per klass per minute. It's unlikely that most people will be executing more
# than 1000 job/sec for a full minute of a specific type.
#
# source://sidekiq//lib/sidekiq/metrics/shared.rb#18
class Sidekiq::Metrics::Histogram
  include ::Enumerable

  # @return [Histogram] a new instance of Histogram
  #
  # source://sidekiq//lib/sidekiq/metrics/shared.rb#60
  def initialize(klass); end

  # Returns the value of attribute buckets.
  #
  # source://sidekiq//lib/sidekiq/metrics/shared.rb#59
  def buckets; end

  # source://sidekiq//lib/sidekiq/metrics/shared.rb#51
  def each; end

  # source://sidekiq//lib/sidekiq/metrics/shared.rb#73
  def fetch(conn, now = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/metrics/shared.rb#55
  def label(idx); end

  # source://sidekiq//lib/sidekiq/metrics/shared.rb#79
  def persist(conn, now = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/metrics/shared.rb#65
  def record_time(ms); end
end

# This number represents the maximum milliseconds for this bucket.
# 20 means all job executions up to 20ms, e.g. if a job takes
# 280ms, it'll increment bucket[7]. Note we can track job executions
# up to about 5.5 minutes. After that, it's assumed you're probably
# not too concerned with its performance.
#
# source://sidekiq//lib/sidekiq/metrics/shared.rb#26
Sidekiq::Metrics::Histogram::BUCKET_INTERVALS = T.let(T.unsafe(nil), Array)

# source://sidekiq//lib/sidekiq/metrics/shared.rb#42
Sidekiq::Metrics::Histogram::FETCH = T.let(T.unsafe(nil), Array)

# source://sidekiq//lib/sidekiq/metrics/shared.rb#49
Sidekiq::Metrics::Histogram::HISTOGRAM_TTL = T.let(T.unsafe(nil), Integer)

# source://sidekiq//lib/sidekiq/metrics/shared.rb#34
Sidekiq::Metrics::Histogram::LABELS = T.let(T.unsafe(nil), Array)

# Allows caller to query for Sidekiq execution metrics within Redis.
# Caller sets a set of attributes to act as filters. {#fetch} will call
# Redis and return a Hash of results.
#
# NB: all metrics and times/dates are UTC only. We specifically do not
# support timezones.
#
# source://sidekiq//lib/sidekiq/metrics/query.rb#15
class Sidekiq::Metrics::Query
  # @return [Query] a new instance of Query
  #
  # source://sidekiq//lib/sidekiq/metrics/query.rb#16
  def initialize(pool: T.unsafe(nil), now: T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/metrics/query.rb#54
  def for_job(klass, minutes: T.unsafe(nil)); end

  # Get metric data for all jobs from the last hour
  #  +class_filter+: return only results for classes matching filter
  #
  # source://sidekiq//lib/sidekiq/metrics/query.rb#24
  def top_jobs(class_filter: T.unsafe(nil), minutes: T.unsafe(nil)); end

  private

  # source://sidekiq//lib/sidekiq/metrics/query.rb#142
  def fetch_marks(time_range); end
end

# source://sidekiq//lib/sidekiq/metrics/query.rb#100
class Sidekiq::Metrics::Query::JobResult < ::Struct
  # @return [JobResult] a new instance of JobResult
  #
  # source://sidekiq//lib/sidekiq/metrics/query.rb#101
  def initialize; end

  # source://sidekiq//lib/sidekiq/metrics/query.rb#116
  def add_hist(time, hist_result); end

  # source://sidekiq//lib/sidekiq/metrics/query.rb#108
  def add_metric(metric, time, value); end

  # source://sidekiq//lib/sidekiq/metrics/query.rb#126
  def series_avg(metric = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/metrics/query.rb#120
  def total_avg(metric = T.unsafe(nil)); end
end

# source://sidekiq//lib/sidekiq/metrics/query.rb#134
class Sidekiq::Metrics::Query::MarkResult < ::Struct
  # source://sidekiq//lib/sidekiq/metrics/query.rb#135
  def bucket; end
end

# source://sidekiq//lib/sidekiq/metrics/query.rb#85
class Sidekiq::Metrics::Query::Result < ::Struct
  # @return [Result] a new instance of Result
  #
  # source://sidekiq//lib/sidekiq/metrics/query.rb#86
  def initialize; end

  # source://sidekiq//lib/sidekiq/metrics/query.rb#93
  def prepend_bucket(time); end
end

# Middleware is code configured to run before/after
# a job is processed.  It is patterned after Rack
# middleware. Middleware exists for the client side
# (pushing jobs onto the queue) as well as the server
# side (when jobs are actually processed).
#
# Callers will register middleware Classes and Sidekiq will
# create new instances of the middleware for every job. This
# is important so that instance state is not shared accidentally
# between job executions.
#
# To add middleware for the client:
#
#   Sidekiq.configure_client do |config|
#     config.client_middleware do |chain|
#       chain.add MyClientHook
#     end
#   end
#
# To modify middleware for the server, just call
# with another block:
#
#   Sidekiq.configure_server do |config|
#     config.server_middleware do |chain|
#       chain.add MyServerHook
#       chain.remove ActiveRecord
#     end
#   end
#
# To insert immediately preceding another entry:
#
#   Sidekiq.configure_client do |config|
#     config.client_middleware do |chain|
#       chain.insert_before ActiveRecord, MyClientHook
#     end
#   end
#
# To insert immediately after another entry:
#
#   Sidekiq.configure_client do |config|
#     config.client_middleware do |chain|
#       chain.insert_after ActiveRecord, MyClientHook
#     end
#   end
#
# This is an example of a minimal server middleware:
#
#   class MyServerHook
#     include Sidekiq::ServerMiddleware
#
#     def call(job_instance, msg, queue)
#       logger.info "Before job"
#       redis {|conn| conn.get("foo") } # do something in Redis
#       yield
#       logger.info "After job"
#     end
#   end
#
# This is an example of a minimal client middleware, note
# the method must return the result or the job will not push
# to Redis:
#
#   class MyClientHook
#     include Sidekiq::ClientMiddleware
#
#     def call(job_class, msg, queue, redis_pool)
#       logger.info "Before push"
#       result = yield
#       logger.info "After push"
#       result
#     end
#   end
#
# source://sidekiq//lib/sidekiq/middleware/chain.rb#79
module Sidekiq::Middleware; end

# source://sidekiq//lib/sidekiq/middleware/chain.rb#80
class Sidekiq::Middleware::Chain
  include ::Enumerable

  # @api private
  # @return [Chain] a new instance of Chain
  # @yield [_self]
  # @yieldparam _self [Sidekiq::Middleware::Chain] the object that the method was called on
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#89
  def initialize(config = T.unsafe(nil)); end

  # Add the given middleware to the end of the chain.
  # Sidekiq will call `klass.new(*args)` to create a clean
  # copy of your middleware for every job executed.
  #
  #   chain.add(Statsd::Metrics, { collector: "localhost:8125" })
  #
  # @param klass [Class] Your middleware class
  # @param *args [Array<Object>] Set of arguments to pass to every instance of your middleware
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#119
  def add(klass, *args); end

  # source://sidekiq//lib/sidekiq/middleware/chain.rb#163
  def clear; end

  # source://sidekiq//lib/sidekiq/middleware/chain.rb#99
  def copy_for(capsule); end

  # Iterate through each middleware in the chain
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#84
  def each(&block); end

  # @return [Boolean] if the chain contains no middleware
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#155
  def empty?; end

  # source://sidekiq//lib/sidekiq/middleware/chain.rb#95
  def entries; end

  # @return [Boolean] if the given class is already in the chain
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#149
  def exists?(klass); end

  # @return [Boolean] if the given class is already in the chain
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#149
  def include?(klass); end

  # Inserts +newklass+ after +oldklass+ in the chain.
  # Useful if one middleware must run after another middleware.
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#141
  def insert_after(oldklass, newklass, *args); end

  # Inserts +newklass+ before +oldklass+ in the chain.
  # Useful if one middleware must run before another middleware.
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#132
  def insert_before(oldklass, newklass, *args); end

  # Used by Sidekiq to execute the middleware at runtime
  #
  # @api private
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#169
  def invoke(*args, &block); end

  # Identical to {#add} except the middleware is added to the front of the chain.
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#125
  def prepend(klass, *args); end

  # Remove all middleware matching the given Class
  #
  # @param klass [Class]
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#107
  def remove(klass); end

  # source://sidekiq//lib/sidekiq/middleware/chain.rb#159
  def retrieve; end

  private

  # source://sidekiq//lib/sidekiq/middleware/chain.rb#178
  def traverse(chain, index, args, &block); end
end

# Represents each link in the middleware chain
#
# @api private
#
# source://sidekiq//lib/sidekiq/middleware/chain.rb#191
class Sidekiq::Middleware::Entry
  # @api private
  # @return [Entry] a new instance of Entry
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#194
  def initialize(config, klass, *args); end

  # @api private
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#192
  def klass; end

  # @api private
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#200
  def make_new; end
end

# source://sidekiq//lib/sidekiq.rb#42
Sidekiq::NAME = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/paginator.rb#4
module Sidekiq::Paginator
  # source://sidekiq//lib/sidekiq/paginator.rb#5
  def page(key, pageidx = T.unsafe(nil), page_size = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/paginator.rb#47
  def page_items(items, pageidx = T.unsafe(nil), page_size = T.unsafe(nil)); end
end

# Sidekiq::Process represents an active Sidekiq process talking with Redis.
# Each process has a set of attributes which look like this:
#
# {
#   'hostname' => 'app-1.example.com',
#   'started_at' => <process start time>,
#   'pid' => 12345,
#   'tag' => 'myapp'
#   'concurrency' => 25,
#   'queues' => ['default', 'low'],
#   'busy' => 10,
#   'beat' => <last heartbeat>,
#   'identity' => <unique string identifying the process>,
#   'embedded' => true,
# }
#
# source://sidekiq//lib/sidekiq/api.rb#988
class Sidekiq::Process
  # @api private
  # @return [Process] a new instance of Process
  #
  # source://sidekiq//lib/sidekiq/api.rb#991
  def initialize(hash); end

  # source://sidekiq//lib/sidekiq/api.rb#1003
  def [](key); end

  # Signal this process to log backtraces for all threads.
  # Useful if you have a frozen or deadlocked process which is
  # still sending a heartbeat.
  # This method is *asynchronous* and it can take 5-10 seconds.
  #
  # source://sidekiq//lib/sidekiq/api.rb#1051
  def dump_threads; end

  # @return [Boolean]
  #
  # source://sidekiq//lib/sidekiq/api.rb#1023
  def embedded?; end

  # source://sidekiq//lib/sidekiq/api.rb#1007
  def identity; end

  # source://sidekiq//lib/sidekiq/api.rb#999
  def labels; end

  # source://sidekiq//lib/sidekiq/api.rb#1011
  def queues; end

  # Signal this process to stop processing new jobs.
  # It will continue to execute jobs it has already fetched.
  # This method is *asynchronous* and it can take 5-10
  # seconds for the process to quiet.
  #
  # source://sidekiq//lib/sidekiq/api.rb#1031
  def quiet!; end

  # Signal this process to shutdown.
  # It will shutdown within its configured :timeout value, default 25 seconds.
  # This method is *asynchronous* and it can take 5-10
  # seconds for the process to start shutting down.
  #
  # source://sidekiq//lib/sidekiq/api.rb#1041
  def stop!; end

  # @return [Boolean] true if this process is quiet or shutting down
  #
  # source://sidekiq//lib/sidekiq/api.rb#1056
  def stopping?; end

  # source://sidekiq//lib/sidekiq/api.rb#995
  def tag; end

  # source://sidekiq//lib/sidekiq/api.rb#1019
  def version; end

  # source://sidekiq//lib/sidekiq/api.rb#1015
  def weights; end

  private

  # source://sidekiq//lib/sidekiq/api.rb#1062
  def signal(sig); end
end

# Enumerates the set of Sidekiq processes which are actively working
# right now.  Each process sends a heartbeat to Redis every 5 seconds
# so this set should be relatively accurate, barring network partitions.
#
# @yieldparam [Sidekiq::Process]
#
# source://sidekiq//lib/sidekiq/api.rb#850
class Sidekiq::ProcessSet
  include ::Enumerable

  # @api private
  # @return [ProcessSet] a new instance of ProcessSet
  #
  # source://sidekiq//lib/sidekiq/api.rb#873
  def initialize(clean_plz = T.unsafe(nil)); end

  # Cleans up dead processes recorded in Redis.
  # Returns the number of processes cleaned.
  #
  # @api private
  #
  # source://sidekiq//lib/sidekiq/api.rb#881
  def cleanup; end

  # source://sidekiq//lib/sidekiq/api.rb#905
  def each; end

  # Returns the identity of the current cluster leader or "" if no leader.
  # This is a Sidekiq Enterprise feature, will always return "" in Sidekiq
  # or Sidekiq Pro.
  #
  # @return [String] Identity of cluster leader
  # @return [String] empty string if no leader
  #
  # source://sidekiq//lib/sidekiq/api.rb#962
  def leader; end

  # This method is not guaranteed accurate since it does not prune the set
  # based on current heartbeat.  #each does that and ensures the set only
  # contains Sidekiq processes which have sent a heartbeat within the last
  # 60 seconds.
  #
  # @return [Integer] current number of registered Sidekiq processes
  #
  # source://sidekiq//lib/sidekiq/api.rb#939
  def size; end

  # source://sidekiq//lib/sidekiq/api.rb#947
  def total_concurrency; end

  # @return [Integer] total amount of RSS memory consumed by Sidekiq processes
  #
  # source://sidekiq//lib/sidekiq/api.rb#952
  def total_rss; end

  # @return [Integer] total amount of RSS memory consumed by Sidekiq processes
  #
  # source://sidekiq//lib/sidekiq/api.rb#952
  def total_rss_in_kb; end

  class << self
    # source://sidekiq//lib/sidekiq/api.rb#853
    def [](identity); end
  end
end

# Represents a queue within Sidekiq.
# Allows enumeration of all jobs within the queue
# and deletion of jobs. NB: this queue data is real-time
# and is changing within Redis moment by moment.
#
#   queue = Sidekiq::Queue.new("mailer")
#   queue.each do |job|
#     job.klass # => 'MyWorker'
#     job.args # => [1, 2, 3]
#     job.delete if job.jid == 'abcdef1234567890'
#   end
#
# source://sidekiq//lib/sidekiq/api.rb#227
class Sidekiq::Queue
  include ::Enumerable

  # @param name [String] the name of the queue
  # @return [Queue] a new instance of Queue
  #
  # source://sidekiq//lib/sidekiq/api.rb#241
  def initialize(name = T.unsafe(nil)); end

  # @api private
  #
  # source://sidekiq//lib/sidekiq/api.rb#324
  def as_json(options = T.unsafe(nil)); end

  # delete all jobs within this queue
  #
  # @return [Boolean] true
  #
  # source://sidekiq//lib/sidekiq/api.rb#311
  def clear; end

  # source://sidekiq//lib/sidekiq/api.rb#275
  def each; end

  # Find the job with the given JID within this queue.
  #
  # This is a *slow, inefficient* operation.  Do not use under
  # normal conditions.
  #
  # @param jid [String] the job_id to look for
  # @return [Sidekiq::JobRecord]
  # @return [nil] if not found
  #
  # source://sidekiq//lib/sidekiq/api.rb#305
  def find_job(jid); end

  # Calculates this queue's latency, the difference in seconds since the oldest
  # job in the queue was enqueued.
  #
  # @return [Float] in seconds
  #
  # source://sidekiq//lib/sidekiq/api.rb#264
  def latency; end

  # Returns the value of attribute name.
  #
  # source://sidekiq//lib/sidekiq/api.rb#238
  def name; end

  # @return [Boolean] if the queue is currently paused
  #
  # source://sidekiq//lib/sidekiq/api.rb#255
  def paused?; end

  # The current size of the queue within Redis.
  # This value is real-time and can change between calls.
  #
  # @return [Integer] the size
  #
  # source://sidekiq//lib/sidekiq/api.rb#250
  def size; end

  # delete all jobs within this queue
  #
  # @return [Boolean] true
  #
  # source://sidekiq//lib/sidekiq/api.rb#311
  def 💣; end

  class << self
    # Fetch all known queues within Redis.
    #
    # @return [Array<Sidekiq::Queue>]
    #
    # source://sidekiq//lib/sidekiq/api.rb#234
    def all; end
  end
end

# source://sidekiq//lib/sidekiq/rails.rb#7
class Sidekiq::Rails < ::Rails::Engine
  class << self
    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
    def __callbacks; end
  end
end

# source://sidekiq//lib/sidekiq/rails.rb#8
class Sidekiq::Rails::Reloader
  # @return [Reloader] a new instance of Reloader
  #
  # source://sidekiq//lib/sidekiq/rails.rb#9
  def initialize(app = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/rails.rb#13
  def call; end

  # source://sidekiq//lib/sidekiq/rails.rb#20
  def inspect; end

  # source://sidekiq//lib/sidekiq/rails.rb#24
  def to_hash; end
end

# source://sidekiq//lib/sidekiq/redis_client_adapter.rb#8
class Sidekiq::RedisClientAdapter
  # @return [RedisClientAdapter] a new instance of RedisClientAdapter
  #
  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#63
  def initialize(options); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#79
  def new_client; end

  private

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#85
  def client_opts(options); end
end

# source://sidekiq//lib/sidekiq/redis_client_adapter.rb#9
Sidekiq::RedisClientAdapter::BaseError = RedisClient::Error

# source://sidekiq//lib/sidekiq/redis_client_adapter.rb#10
Sidekiq::RedisClientAdapter::CommandError = RedisClient::CommandError

# source://sidekiq//lib/sidekiq/redis_client_adapter.rb#0
class Sidekiq::RedisClientAdapter::CompatClient < ::RedisClient::Decorator::Client
  include ::Sidekiq::RedisClientAdapter::CompatMethods

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#58
  def config; end
end

# source://sidekiq//lib/sidekiq/redis_client_adapter.rb#0
class Sidekiq::RedisClientAdapter::CompatClient::Pipeline < ::RedisClient::Decorator::Pipeline
  include ::Sidekiq::RedisClientAdapter::CompatMethods
end

# source://sidekiq//lib/sidekiq/redis_client_adapter.rb#15
module Sidekiq::RedisClientAdapter::CompatMethods
  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def bitfield(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def bitfield_ro(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def del(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#20
  def evalsha(sha, keys, argv); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def exists(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def expire(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def flushdb(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def get(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def hdel(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def hget(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def hgetall(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def hincrby(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def hlen(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def hmget(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def hset(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def hsetnx(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def incr(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def incrby(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#16
  def info; end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def lindex(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def llen(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def lmove(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def lpop(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def lpush(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def lrange(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def lrem(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def mget(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def mset(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def ping(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def pttl(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def publish(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def rpop(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def rpush(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def sadd(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def scard(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def script(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def set(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def sismember(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def smembers(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def srem(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def ttl(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def type(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def unlink(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def zadd(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def zcard(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def zincrby(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def zrange(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def zrem(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def zremrangebyrank(*args, **kwargs); end

  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#35
  def zremrangebyscore(*args, **kwargs); end

  private

  # this allows us to use methods like `conn.hmset(...)` instead of having to use
  # redis-client's native `conn.call("hmset", ...)`
  #
  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#44
  def method_missing(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://sidekiq//lib/sidekiq/redis_client_adapter.rb#50
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

# this is the set of Redis commands used by Sidekiq. Not guaranteed
# to be comprehensive, we use this as a performance enhancement to
# avoid calling method_missing on most commands
#
# source://sidekiq//lib/sidekiq/redis_client_adapter.rb#27
Sidekiq::RedisClientAdapter::CompatMethods::USED_COMMANDS = T.let(T.unsafe(nil), Array)

# You can add/remove items or clear the whole thing if you don't want deprecation warnings.
#
# source://sidekiq//lib/sidekiq/redis_client_adapter.rb#13
Sidekiq::RedisClientAdapter::DEPRECATED_COMMANDS = T.let(T.unsafe(nil), Set)

# source://sidekiq//lib/sidekiq/redis_connection.rb#8
module Sidekiq::RedisConnection
  class << self
    # source://sidekiq//lib/sidekiq/redis_connection.rb#10
    def create(options = T.unsafe(nil)); end

    private

    # source://sidekiq//lib/sidekiq/redis_connection.rb#41
    def deep_symbolize_keys(object); end

    # source://sidekiq//lib/sidekiq/redis_connection.rb#74
    def determine_redis_provider; end

    # source://sidekiq//lib/sidekiq/redis_connection.rb#54
    def scrub(options); end
  end
end

# The set of retries within Sidekiq.
# Based on this, you can search/filter for jobs.  Here's an
# example where I'm selecting all jobs of a certain type
# and deleting them from the retry queue.
#
# See the API wiki page for usage notes and examples.
#
# source://sidekiq//lib/sidekiq/api.rb#788
class Sidekiq::RetrySet < ::Sidekiq::JobSet
  # @return [RetrySet] a new instance of RetrySet
  #
  # source://sidekiq//lib/sidekiq/api.rb#789
  def initialize; end

  # Kills all jobs pending within the retry set.
  #
  # source://sidekiq//lib/sidekiq/api.rb#799
  def kill_all; end

  # Enqueues all jobs pending within the retry set.
  #
  # source://sidekiq//lib/sidekiq/api.rb#794
  def retry_all; end
end

# source://sidekiq//lib/sidekiq/scheduled.rb#7
module Sidekiq::Scheduled; end

# source://sidekiq//lib/sidekiq/scheduled.rb#10
class Sidekiq::Scheduled::Enq
  include ::Sidekiq::Component

  # @return [Enq] a new instance of Enq
  #
  # source://sidekiq//lib/sidekiq/scheduled.rb#22
  def initialize(container); end

  # source://sidekiq//lib/sidekiq/scheduled.rb#29
  def enqueue_jobs(sorted_sets = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/scheduled.rb#46
  def terminate; end

  private

  # source://sidekiq//lib/sidekiq/scheduled.rb#52
  def zpopbyscore(conn, keys: T.unsafe(nil), argv: T.unsafe(nil)); end
end

# source://sidekiq//lib/sidekiq/scheduled.rb#13
Sidekiq::Scheduled::Enq::LUA_ZPOPBYSCORE = T.let(T.unsafe(nil), String)

# The Poller checks Redis every N seconds for jobs in the retry or scheduled
# set have passed their timestamp and should be enqueued.  If so, it
# just pops the job back onto its original queue so the
# workers can pick it up like any other job.
#
# source://sidekiq//lib/sidekiq/scheduled.rb#71
class Sidekiq::Scheduled::Poller
  include ::Sidekiq::Component

  # @return [Poller] a new instance of Poller
  #
  # source://sidekiq//lib/sidekiq/scheduled.rb#76
  def initialize(config); end

  # source://sidekiq//lib/sidekiq/scheduled.rb#106
  def enqueue; end

  # source://sidekiq//lib/sidekiq/scheduled.rb#94
  def start; end

  # Shut down this instance, will pause until the thread is dead.
  #
  # source://sidekiq//lib/sidekiq/scheduled.rb#86
  def terminate; end

  private

  # A copy of Sidekiq::ProcessSet#cleanup because server
  # should never depend on sidekiq/api.
  #
  # source://sidekiq//lib/sidekiq/scheduled.rb#194
  def cleanup; end

  # source://sidekiq//lib/sidekiq/scheduled.rb#218
  def initial_wait; end

  # We do our best to tune the poll interval to the size of the active Sidekiq
  # cluster.  If you have 30 processes and poll every 15 seconds, that means one
  # Sidekiq is checking Redis every 0.5 seconds - way too often for most people
  # and really bad if the retry or scheduled sets are large.
  #
  # Instead try to avoid polling more than once every 15 seconds.  If you have
  # 30 Sidekiq processes, we'll poll every 30 * 15 or 450 seconds.
  # To keep things statistically random, we'll sleep a random amount between
  # 225 and 675 seconds for each poll or 450 seconds on average.  Otherwise restarting
  # all your Sidekiq processes at the same time will lead to them all polling at
  # the same time: the thundering herd problem.
  #
  # We only do this if poll_interval_average is unset (the default).
  #
  # source://sidekiq//lib/sidekiq/scheduled.rb#175
  def poll_interval_average(count); end

  # source://sidekiq//lib/sidekiq/scheduled.rb#186
  def process_count; end

  # source://sidekiq//lib/sidekiq/scheduled.rb#129
  def random_poll_interval; end

  # Calculates an average poll interval based on the number of known Sidekiq processes.
  # This minimizes a single point of failure by dispersing check-ins but without taxing
  # Redis if you run many Sidekiq processes.
  #
  # source://sidekiq//lib/sidekiq/scheduled.rb#182
  def scaled_poll_interval(process_count); end

  # source://sidekiq//lib/sidekiq/scheduled.rb#117
  def wait; end
end

# source://sidekiq//lib/sidekiq/scheduled.rb#74
Sidekiq::Scheduled::Poller::INITIAL_WAIT = T.let(T.unsafe(nil), Integer)

# source://sidekiq//lib/sidekiq/scheduled.rb#8
Sidekiq::Scheduled::SETS = T.let(T.unsafe(nil), Array)

# The set of scheduled jobs within Sidekiq.
# Based on this, you can search/filter for jobs.  Here's an
# example where I'm selecting jobs based on some complex logic
# and deleting them from the scheduled set.
#
# See the API wiki page for usage notes and examples.
#
# source://sidekiq//lib/sidekiq/api.rb#774
class Sidekiq::ScheduledSet < ::Sidekiq::JobSet
  # @return [ScheduledSet] a new instance of ScheduledSet
  #
  # source://sidekiq//lib/sidekiq/api.rb#775
  def initialize; end
end

# Server-side middleware must import this Module in order
# to get access to server resources during `call`.
#
# source://sidekiq//lib/sidekiq/middleware/modules.rb#4
module Sidekiq::ServerMiddleware
  # Returns the value of attribute config.
  #
  # source://sidekiq//lib/sidekiq/middleware/modules.rb#5
  def config; end

  # Sets the attribute config
  #
  # @param value the value to set the attribute config to.
  #
  # source://sidekiq//lib/sidekiq/middleware/modules.rb#5
  def config=(_arg0); end

  # source://sidekiq//lib/sidekiq/middleware/modules.rb#10
  def logger; end

  # source://sidekiq//lib/sidekiq/middleware/modules.rb#14
  def redis(&block); end

  # source://sidekiq//lib/sidekiq/middleware/modules.rb#6
  def redis_pool; end
end

# We are shutting down Sidekiq but what about threads that
# are working on some long job?  This error is
# raised in jobs that have not finished within the hard
# timeout limit.  This is needed to rollback db transactions,
# otherwise Ruby's Thread#kill will commit.  See #377.
# DO NOT RESCUE THIS ERROR IN YOUR JOBS
#
# source://sidekiq//lib/sidekiq.rb#145
class Sidekiq::Shutdown < ::Interrupt; end

# Represents a job within a Redis sorted set where the score
# represents a timestamp associated with the job. This timestamp
# could be the scheduled time for it to run (e.g. scheduled set),
# or the expiration date after which the entry should be deleted (e.g. dead set).
#
# source://sidekiq//lib/sidekiq/api.rb#503
class Sidekiq::SortedEntry < ::Sidekiq::JobRecord
  # @api private
  # @return [SortedEntry] a new instance of SortedEntry
  #
  # source://sidekiq//lib/sidekiq/api.rb#509
  def initialize(parent, score, item); end

  # Enqueue this job from the scheduled or dead set so it will
  # be executed at some point in the near future.
  #
  # source://sidekiq//lib/sidekiq/api.rb#540
  def add_to_queue; end

  # The timestamp associated with this entry
  #
  # source://sidekiq//lib/sidekiq/api.rb#516
  def at; end

  # remove this entry from the sorted set
  #
  # source://sidekiq//lib/sidekiq/api.rb#521
  def delete; end

  # @return [Boolean]
  #
  # source://sidekiq//lib/sidekiq/api.rb#564
  def error?; end

  # Move this job from its current set into the Dead set.
  #
  # source://sidekiq//lib/sidekiq/api.rb#558
  def kill; end

  # Returns the value of attribute parent.
  #
  # source://sidekiq//lib/sidekiq/api.rb#505
  def parent; end

  # Change the scheduled time for this job.
  #
  # @param at [Time] the new timestamp for this job
  #
  # source://sidekiq//lib/sidekiq/api.rb#532
  def reschedule(at); end

  # enqueue this job from the retry set so it will be executed
  # at some point in the near future.
  #
  # source://sidekiq//lib/sidekiq/api.rb#549
  def retry; end

  # Returns the value of attribute score.
  #
  # source://sidekiq//lib/sidekiq/api.rb#504
  def score; end

  private

  # source://sidekiq//lib/sidekiq/api.rb#570
  def remove_job; end
end

# Base class for all sorted sets within Sidekiq.
#
# source://sidekiq//lib/sidekiq/api.rb#606
class Sidekiq::SortedSet
  include ::Enumerable

  # @api private
  # @return [SortedSet] a new instance of SortedSet
  #
  # source://sidekiq//lib/sidekiq/api.rb#615
  def initialize(name); end

  # @api private
  #
  # source://sidekiq//lib/sidekiq/api.rb#653
  def as_json(options = T.unsafe(nil)); end

  # @return [Boolean] always true
  #
  # source://sidekiq//lib/sidekiq/api.rb#643
  def clear; end

  # Redis key of the set
  #
  # source://sidekiq//lib/sidekiq/api.rb#611
  def name; end

  # Scan through each element of the sorted set, yielding each to the supplied block.
  # Please see Redis's <a href="https://redis.io/commands/scan/">SCAN documentation</a> for implementation details.
  #
  # @param match [String] a snippet or regexp to filter matches.
  # @param count [Integer] number of elements to retrieve at a time, default 100
  # @yieldparam each [Sidekiq::SortedEntry] entry
  #
  # source://sidekiq//lib/sidekiq/api.rb#631
  def scan(match, count = T.unsafe(nil)); end

  # real-time size of the set, will change
  #
  # source://sidekiq//lib/sidekiq/api.rb#621
  def size; end

  # @return [Boolean] always true
  #
  # source://sidekiq//lib/sidekiq/api.rb#643
  def 💣; end
end

# Retrieve runtime statistics from Redis regarding
# this Sidekiq cluster.
#
#   stat = Sidekiq::Stats.new
#   stat.processed
#
# source://sidekiq//lib/sidekiq/api.rb#27
class Sidekiq::Stats
  # @return [Stats] a new instance of Stats
  #
  # source://sidekiq//lib/sidekiq/api.rb#28
  def initialize; end

  # source://sidekiq//lib/sidekiq/api.rb#48
  def dead_size; end

  # source://sidekiq//lib/sidekiq/api.rb#64
  def default_queue_latency; end

  # source://sidekiq//lib/sidekiq/api.rb#52
  def enqueued; end

  # source://sidekiq//lib/sidekiq/api.rb#36
  def failed; end

  # @api private
  #
  # source://sidekiq//lib/sidekiq/api.rb#151
  def fetch_stats!; end

  # O(1) redis calls
  #
  # @api private
  #
  # source://sidekiq//lib/sidekiq/api.rb#85
  def fetch_stats_fast!; end

  # O(number of processes + number of queues) redis calls
  #
  # @api private
  #
  # source://sidekiq//lib/sidekiq/api.rb#125
  def fetch_stats_slow!; end

  # source://sidekiq//lib/sidekiq/api.rb#32
  def processed; end

  # source://sidekiq//lib/sidekiq/api.rb#56
  def processes_size; end

  # source://sidekiq//lib/sidekiq/api.rb#68
  def queues; end

  # @api private
  #
  # source://sidekiq//lib/sidekiq/api.rb#157
  def reset(*stats); end

  # source://sidekiq//lib/sidekiq/api.rb#44
  def retry_size; end

  # source://sidekiq//lib/sidekiq/api.rb#40
  def scheduled_size; end

  # source://sidekiq//lib/sidekiq/api.rb#60
  def workers_size; end

  private

  # source://sidekiq//lib/sidekiq/api.rb#173
  def stat(s); end
end

# source://sidekiq//lib/sidekiq/api.rb#178
class Sidekiq::Stats::History
  # @raise [ArgumentError]
  # @return [History] a new instance of History
  #
  # source://sidekiq//lib/sidekiq/api.rb#179
  def initialize(days_previous, start_date = T.unsafe(nil), pool: T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/api.rb#190
  def failed; end

  # source://sidekiq//lib/sidekiq/api.rb#186
  def processed; end

  private

  # source://sidekiq//lib/sidekiq/api.rb#196
  def date_stat_hash(stat); end
end

# source://sidekiq//lib/sidekiq/transaction_aware_client.rb#7
class Sidekiq::TransactionAwareClient
  # @return [TransactionAwareClient] a new instance of TransactionAwareClient
  #
  # source://sidekiq//lib/sidekiq/transaction_aware_client.rb#8
  def initialize(pool: T.unsafe(nil), config: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://sidekiq//lib/sidekiq/transaction_aware_client.rb#12
  def batching?; end

  # source://sidekiq//lib/sidekiq/transaction_aware_client.rb#16
  def push(item); end

  # We don't provide transactionality for push_bulk because we don't want
  # to hold potentially hundreds of thousands of job records in memory due to
  # a long running enqueue process.
  #
  # source://sidekiq//lib/sidekiq/transaction_aware_client.rb#31
  def push_bulk(items); end
end

# source://sidekiq//lib/sidekiq/version.rb#4
Sidekiq::VERSION = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web/csrf_protection.rb#33
class Sidekiq::Web
  # source://sidekiq//lib/sidekiq/web.rb#127
  def app; end

  # source://sidekiq//lib/sidekiq/web.rb#117
  def call(env); end

  # source://sidekiq//lib/sidekiq/web.rb#135
  def disable(*opts); end

  # source://sidekiq//lib/sidekiq/web.rb#131
  def enable(*opts); end

  # source://sidekiq//lib/sidekiq/web.rb#109
  def middlewares; end

  # source://sidekiq//lib/sidekiq/web.rb#139
  def set(attribute, value); end

  # source://sidekiq//lib/sidekiq/web.rb#105
  def settings; end

  # source://sidekiq//lib/sidekiq/web.rb#113
  def use(*args, &block); end

  private

  # source://sidekiq//lib/sidekiq/web.rb#192
  def build; end

  class << self
    # Returns the value of attribute app_url.
    #
    # source://sidekiq//lib/sidekiq/web.rb#96
    def app_url; end

    # Sets the attribute app_url
    #
    # @param value the value to set the attribute app_url to.
    #
    # source://sidekiq//lib/sidekiq/web.rb#96
    def app_url=(_arg0); end

    # source://sidekiq//lib/sidekiq/web.rb#122
    def call(env); end

    # source://sidekiq//lib/sidekiq/web.rb#64
    def custom_job_info_rows; end

    # source://sidekiq//lib/sidekiq/web.rb#59
    def custom_tabs; end

    # source://sidekiq//lib/sidekiq/web.rb#55
    def default_tabs; end

    # source://sidekiq//lib/sidekiq/web.rb#80
    def disable(*opts); end

    # source://sidekiq//lib/sidekiq/web.rb#76
    def enable(*opts); end

    # @private
    #
    # source://sidekiq//lib/sidekiq/web.rb#100
    def inherited(child); end

    # source://sidekiq//lib/sidekiq/web.rb#68
    def locales; end

    # Sets the attribute locales
    #
    # @param value the value to set the attribute locales to.
    #
    # source://sidekiq//lib/sidekiq/web.rb#97
    def locales=(_arg0); end

    # source://sidekiq//lib/sidekiq/web.rb#84
    def middlewares; end

    # Returns the value of attribute redis_pool.
    #
    # source://sidekiq//lib/sidekiq/web.rb#96
    def redis_pool; end

    # Sets the attribute redis_pool
    #
    # @param value the value to set the attribute redis_pool to.
    #
    # source://sidekiq//lib/sidekiq/web.rb#96
    def redis_pool=(_arg0); end

    # Register a class as a Sidekiq Web UI extension. The class should
    # provide one or more tabs which map to an index route. Options:
    #
    # TODO name, tab and index will be mandatory in 8.0
    #
    # Web extensions will have a root `web/` directory with `locales/`, `assets/`
    # and `views/` subdirectories.
    #
    # @param extension [Class] Class which contains the HTTP actions, required
    # @param name [String] the name of the extension, used to namespace assets
    # @param tab [String | Array] labels(s) of the UI tabs
    # @param index [String | Array] index route(s) for each tab
    # @param root_dir [String] directory location to find assets, locales and views, typically `web/` within the gemfile
    # @param asset_paths [Array] one or more directories under {root}/assets/{name} to be publicly served, e.g. ["js", "css", "img"]
    # @param cache_for [Integer] amount of time to cache assets, default one day
    # @yield [_self]
    # @yieldparam _self [Sidekiq::Web] the object that the method was called on
    #
    # source://sidekiq//lib/sidekiq/web.rb#158
    def register(extension, name: T.unsafe(nil), tab: T.unsafe(nil), index: T.unsafe(nil), root_dir: T.unsafe(nil), cache_for: T.unsafe(nil), asset_paths: T.unsafe(nil)); end

    # source://sidekiq//lib/sidekiq/web.rb#92
    def set(attribute, value); end

    # source://sidekiq//lib/sidekiq/web.rb#51
    def settings; end

    # source://sidekiq//lib/sidekiq/web.rb#59
    def tabs; end

    # source://sidekiq//lib/sidekiq/web.rb#88
    def use(*args, &block); end

    # source://sidekiq//lib/sidekiq/web.rb#72
    def views; end

    # Sets the attribute views
    #
    # @param value the value to set the attribute views to.
    #
    # source://sidekiq//lib/sidekiq/web.rb#97
    def views=(_arg0); end
  end
end

# source://sidekiq//lib/sidekiq/web.rb#26
Sidekiq::Web::ASSETS = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web.rb#44
Sidekiq::Web::CONTENT_LANGUAGE = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web.rb#45
Sidekiq::Web::CONTENT_SECURITY_POLICY = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web/csrf_protection.rb#34
class Sidekiq::Web::CsrfProtection
  # @return [CsrfProtection] a new instance of CsrfProtection
  #
  # source://sidekiq//lib/sidekiq/web/csrf_protection.rb#35
  def initialize(app, options = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/web/csrf_protection.rb#39
  def call(env); end

  private

  # @return [Boolean]
  #
  # source://sidekiq//lib/sidekiq/web/csrf_protection.rb#95
  def accept?(env); end

  # source://sidekiq//lib/sidekiq/web/csrf_protection.rb#45
  def admit(env); end

  # source://sidekiq//lib/sidekiq/web/csrf_protection.rb#166
  def compare_with_real_token(token, local); end

  # source://sidekiq//lib/sidekiq/web/csrf_protection.rb#174
  def decode_token(token); end

  # source://sidekiq//lib/sidekiq/web/csrf_protection.rb#62
  def deny(env); end

  # source://sidekiq//lib/sidekiq/web/csrf_protection.rb#170
  def encode_token(token); end

  # source://sidekiq//lib/sidekiq/web/csrf_protection.rb#58
  def logger(env); end

  # Creates a masked version of the authenticity token that varies
  # on each request. The masking is used to mitigate SSL attacks
  # like BREACH.
  #
  # source://sidekiq//lib/sidekiq/web/csrf_protection.rb#140
  def mask_token(token); end

  # @return [Boolean]
  #
  # source://sidekiq//lib/sidekiq/web/csrf_protection.rb#162
  def masked_token?(token); end

  # @return [Boolean]
  #
  # source://sidekiq//lib/sidekiq/web/csrf_protection.rb#54
  def safe?(env); end

  # source://sidekiq//lib/sidekiq/web/csrf_protection.rb#67
  def session(env); end

  # Essentially the inverse of +mask_token+.
  #
  # source://sidekiq//lib/sidekiq/web/csrf_protection.rb#149
  def unmask_token(masked_token); end

  # @return [Boolean]
  #
  # source://sidekiq//lib/sidekiq/web/csrf_protection.rb#158
  def unmasked_token?(token); end

  # Checks that the token given to us as a parameter matches
  # the token stored in the session.
  #
  # @return [Boolean]
  #
  # source://sidekiq//lib/sidekiq/web/csrf_protection.rb#106
  def valid_token?(env, giventoken); end

  # source://sidekiq//lib/sidekiq/web/csrf_protection.rb#178
  def xor_byte_strings(s1, s2); end
end

# source://sidekiq//lib/sidekiq/web/csrf_protection.rb#102
Sidekiq::Web::CsrfProtection::TOKEN_LENGTH = T.let(T.unsafe(nil), Integer)

# source://sidekiq//lib/sidekiq/web.rb#28
Sidekiq::Web::DEFAULT_TABS = T.let(T.unsafe(nil), Hash)

# source://sidekiq//lib/sidekiq/web.rb#25
Sidekiq::Web::LAYOUT = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web.rb#24
Sidekiq::Web::LOCALES = T.let(T.unsafe(nil), Array)

# source://sidekiq//lib/sidekiq/web.rb#46
Sidekiq::Web::LOCATION = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web.rb#22
Sidekiq::Web::ROOT = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web.rb#23
Sidekiq::Web::VIEWS = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web.rb#47
Sidekiq::Web::X_CASCADE = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web/action.rb#4
class Sidekiq::WebAction
  include ::Sidekiq::WebHelpers
  include ::Sidekiq::Paginator

  # @return [WebAction] a new instance of WebAction
  #
  # source://sidekiq//lib/sidekiq/web/action.rb#80
  def initialize(env, block); end

  # source://sidekiq//lib/sidekiq/web.rb#215
  def _render; end

  # Returns the value of attribute block.
  #
  # source://sidekiq//lib/sidekiq/web/action.rb#7
  def block; end

  # Sets the attribute block
  #
  # @param value the value to set the attribute block to.
  #
  # source://sidekiq//lib/sidekiq/web/action.rb#7
  def block=(_arg0); end

  # Returns the value of attribute env.
  #
  # source://sidekiq//lib/sidekiq/web/action.rb#7
  def env; end

  # Sets the attribute env
  #
  # @param value the value to set the attribute env to.
  #
  # source://sidekiq//lib/sidekiq/web/action.rb#7
  def env=(_arg0); end

  # source://sidekiq//lib/sidekiq/web/action.rb#47
  def erb(content, options = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/web/action.rb#17
  def halt(res); end

  # source://sidekiq//lib/sidekiq/web/action.rb#76
  def json(payload); end

  # source://sidekiq//lib/sidekiq/web/action.rb#30
  def params; end

  # source://sidekiq//lib/sidekiq/web/action.rb#21
  def redirect(location); end

  # source://sidekiq//lib/sidekiq/web/action.rb#25
  def reload_page; end

  # source://sidekiq//lib/sidekiq/web/action.rb#70
  def render(engine, content, options = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/web/action.rb#13
  def request; end

  # source://sidekiq//lib/sidekiq/web/action.rb#39
  def route_params; end

  # source://sidekiq//lib/sidekiq/web/action.rb#43
  def session; end

  # source://sidekiq//lib/sidekiq/web/action.rb#9
  def settings; end

  # Returns the value of attribute type.
  #
  # source://sidekiq//lib/sidekiq/web/action.rb#7
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://sidekiq//lib/sidekiq/web/action.rb#7
  def type=(_arg0); end

  private

  # source://sidekiq//lib/sidekiq/web/action.rb#89
  def _erb(file, locals); end
end

# source://sidekiq//lib/sidekiq/web/action.rb#5
Sidekiq::WebAction::RACK_SESSION = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web/application.rb#4
class Sidekiq::WebApplication
  extend ::Sidekiq::WebRouter

  # @return [WebApplication] a new instance of WebApplication
  #
  # source://sidekiq//lib/sidekiq/web/application.rb#30
  def initialize(klass); end

  # source://sidekiq//lib/sidekiq/web/application.rb#409
  def call(env); end

  # source://sidekiq//lib/sidekiq/web/application.rb#438
  def process_csp(env, input); end

  # source://sidekiq//lib/sidekiq/web/application.rb#34
  def settings; end

  class << self
    # source://sidekiq//lib/sidekiq/web/application.rb#454
    def after(path = T.unsafe(nil), &block); end

    # source://sidekiq//lib/sidekiq/web/application.rb#475
    def afters; end

    # source://sidekiq//lib/sidekiq/web/application.rb#450
    def before(path = T.unsafe(nil), &block); end

    # source://sidekiq//lib/sidekiq/web/application.rb#471
    def befores; end

    # source://sidekiq//lib/sidekiq/web/application.rb#442
    def helpers(mod = T.unsafe(nil), &block); end

    # source://sidekiq//lib/sidekiq/web/application.rb#462
    def run_afters(app, action); end

    # source://sidekiq//lib/sidekiq/web/application.rb#458
    def run_befores(app, action); end

    # source://sidekiq//lib/sidekiq/web/application.rb#466
    def run_hooks(hooks, app, action); end

    # source://sidekiq//lib/sidekiq/web/application.rb#46
    def set(key, val); end

    # source://sidekiq//lib/sidekiq/web/application.rb#38
    def settings; end

    # source://sidekiq//lib/sidekiq/web/application.rb#42
    def tabs; end
  end
end

# source://sidekiq//lib/sidekiq/web/application.rb#8
Sidekiq::WebApplication::CSP_HEADER_TEMPLATE = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web/application.rb#23
Sidekiq::WebApplication::METRICS_PERIODS = T.let(T.unsafe(nil), Hash)

# source://sidekiq//lib/sidekiq/web/application.rb#119
Sidekiq::WebApplication::QUEUE_NAME = T.let(T.unsafe(nil), Regexp)

# source://sidekiq//lib/sidekiq/web/application.rb#7
Sidekiq::WebApplication::REDIS_KEYS = T.let(T.unsafe(nil), Array)

# These methods are available to pages within the Web UI and UI extensions.
# They are not public APIs for applications to use.
#
# source://sidekiq//lib/sidekiq/web/helpers.rb#11
module Sidekiq::WebHelpers
  # This view helper provide ability display you html code in
  # to head of page. Example:
  #
  #   <% add_to_head do %>
  #     <link rel="stylesheet" .../>
  #     <meta .../>
  #   <% end %>
  #
  # source://sidekiq//lib/sidekiq/web/helpers.rb#132
  def add_to_head; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#91
  def available_locales; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#228
  def busy_weights(capsule_weights); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#79
  def clear_caches; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#312
  def csp_nonce; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#308
  def csrf_tag; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#254
  def current_path; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#258
  def current_status; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#407
  def delete_or_add_queue(job, params); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#295
  def display_args(args, truncate_after_chars = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#137
  def display_custom_head; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#118
  def display_tags(job, within = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#378
  def environment_title_prefix; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#110
  def filter_link(jid, within = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#106
  def filtering(which); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#95
  def find_locale_files(lang); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#341
  def format_memory(rss_kb); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#190
  def get_locale; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#358
  def h(text); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#267
  def job_params(job, score); end

  # Given an Accept-Language header like "fr-FR,fr;q=0.8,en-US;q=0.6,en;q=0.4,ru;q=0.2"
  # this method will try to best match the available locales to the user's preferred languages.
  #
  # Inspiration taken from https://github.com/iain/http_accept_language/blob/master/lib/http_accept_language/parser.rb
  #
  # source://sidekiq//lib/sidekiq/web/helpers.rb#166
  def locale; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#85
  def locale_files; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#353
  def number_with_delimiter(number, options = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#271
  def parse_params(params); end

  # @return [Boolean]
  #
  # source://sidekiq//lib/sidekiq/web/helpers.rb#392
  def pollable?; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#211
  def processes; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#384
  def product_version; end

  # Merge options with current params, filter safe params, and stringify to query string
  #
  # source://sidekiq//lib/sidekiq/web/helpers.rb#279
  def qparams(options); end

  # Any paginated list that performs an action needs to redirect
  # back to the proper page after performing that action.
  #
  # source://sidekiq//lib/sidekiq/web/helpers.rb#368
  def redirect_with_query(url); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#246
  def redis_info; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#240
  def redis_url; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#262
  def relative_time(time); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#333
  def retry_extra_items(retry_job); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#397
  def retry_or_delete_or_kill(job, params); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#250
  def root_path; end

  # @return [Boolean]
  #
  # source://sidekiq//lib/sidekiq/web/helpers.rb#145
  def rtl?; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#25
  def script_tag(location, **kwargs); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#99
  def search(jobset, substr); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#388
  def server_utc_time; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#71
  def singularize(str, count); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#203
  def sort_direction_label; end

  # Sorts processes by hostname following the natural sort order
  #
  # source://sidekiq//lib/sidekiq/web/helpers.rb#216
  def sorted_processes; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#236
  def stats; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#54
  def strings(lang); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#12
  def style_tag(location, **kwargs); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#194
  def t(msg, options = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#141
  def text_direction; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#316
  def to_display(arg); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#67
  def to_json(x); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#285
  def to_query_string(params); end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#291
  def truncate(text, truncate_after_chars = T.unsafe(nil)); end

  # sidekiq/sidekiq#3243
  #
  # @return [Boolean]
  #
  # source://sidekiq//lib/sidekiq/web/helpers.rb#186
  def unfiltered?; end

  # See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4
  #
  # source://sidekiq//lib/sidekiq/web/helpers.rb#150
  def user_preferred_languages; end

  # source://sidekiq//lib/sidekiq/web/helpers.rb#207
  def workset; end

  private

  # NB: keys and values are not escaped; do not allow user input
  # in the attributes
  #
  # source://sidekiq//lib/sidekiq/web/helpers.rb#38
  def html_tag(tagname, attrs); end
end

# source://sidekiq//lib/sidekiq/web/helpers.rb#326
Sidekiq::WebHelpers::RETRY_JOB_KEYS = T.let(T.unsafe(nil), Set)

# source://sidekiq//lib/sidekiq/web/helpers.rb#276
Sidekiq::WebHelpers::SAFE_QPARAMS = T.let(T.unsafe(nil), Array)

# source://sidekiq//lib/sidekiq/web/router.rb#69
class Sidekiq::WebRoute
  # @return [WebRoute] a new instance of WebRoute
  #
  # source://sidekiq//lib/sidekiq/web/router.rb#74
  def initialize(request_method, pattern, block); end

  # Returns the value of attribute block.
  #
  # source://sidekiq//lib/sidekiq/web/router.rb#70
  def block; end

  # Sets the attribute block
  #
  # @param value the value to set the attribute block to.
  #
  # source://sidekiq//lib/sidekiq/web/router.rb#70
  def block=(_arg0); end

  # source://sidekiq//lib/sidekiq/web/router.rb#84
  def compile; end

  # source://sidekiq//lib/sidekiq/web/router.rb#94
  def match(request_method, path); end

  # source://sidekiq//lib/sidekiq/web/router.rb#80
  def matcher; end

  # Returns the value of attribute name.
  #
  # source://sidekiq//lib/sidekiq/web/router.rb#70
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://sidekiq//lib/sidekiq/web/router.rb#70
  def name=(_arg0); end

  # Returns the value of attribute pattern.
  #
  # source://sidekiq//lib/sidekiq/web/router.rb#70
  def pattern; end

  # Sets the attribute pattern
  #
  # @param value the value to set the attribute pattern to.
  #
  # source://sidekiq//lib/sidekiq/web/router.rb#70
  def pattern=(_arg0); end

  # Returns the value of attribute request_method.
  #
  # source://sidekiq//lib/sidekiq/web/router.rb#70
  def request_method; end

  # Sets the attribute request_method
  #
  # @param value the value to set the attribute request_method to.
  #
  # source://sidekiq//lib/sidekiq/web/router.rb#70
  def request_method=(_arg0); end
end

# source://sidekiq//lib/sidekiq/web/router.rb#72
Sidekiq::WebRoute::NAMED_SEGMENTS_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://sidekiq//lib/sidekiq/web/router.rb#6
module Sidekiq::WebRouter
  # source://sidekiq//lib/sidekiq/web/router.rb#38
  def delete(path, &block); end

  # source://sidekiq//lib/sidekiq/web/router.rb#22
  def get(path, &block); end

  # source://sidekiq//lib/sidekiq/web/router.rb#18
  def head(path, &block); end

  # source://sidekiq//lib/sidekiq/web/router.rb#48
  def match(env); end

  # source://sidekiq//lib/sidekiq/web/router.rb#34
  def patch(path, &block); end

  # source://sidekiq//lib/sidekiq/web/router.rb#26
  def post(path, &block); end

  # source://sidekiq//lib/sidekiq/web/router.rb#30
  def put(path, &block); end

  # source://sidekiq//lib/sidekiq/web/router.rb#42
  def route(method, path, &block); end
end

# source://sidekiq//lib/sidekiq/web/router.rb#8
Sidekiq::WebRouter::DELETE = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web/router.rb#7
Sidekiq::WebRouter::GET = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web/router.rb#12
Sidekiq::WebRouter::HEAD = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web/router.rb#11
Sidekiq::WebRouter::PATCH = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web/router.rb#16
Sidekiq::WebRouter::PATH_INFO = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web/router.rb#9
Sidekiq::WebRouter::POST = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web/router.rb#10
Sidekiq::WebRouter::PUT = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web/router.rb#15
Sidekiq::WebRouter::REQUEST_METHOD = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/web/router.rb#14
Sidekiq::WebRouter::ROUTE_PARAMS = T.let(T.unsafe(nil), String)

# Sidekiq::Work represents a job which is currently executing.
#
# source://sidekiq//lib/sidekiq/api.rb#1156
class Sidekiq::Work
  # @return [Work] a new instance of Work
  #
  # source://sidekiq//lib/sidekiq/api.rb#1160
  def initialize(pid, tid, hsh); end

  # deprecated
  #
  # source://sidekiq//lib/sidekiq/api.rb#1184
  def [](key); end

  # source://sidekiq//lib/sidekiq/api.rb#1175
  def job; end

  # source://sidekiq//lib/sidekiq/api.rb#1198
  def method_missing(*all); end

  # source://sidekiq//lib/sidekiq/api.rb#1179
  def payload; end

  # Returns the value of attribute process_id.
  #
  # source://sidekiq//lib/sidekiq/api.rb#1157
  def process_id; end

  # source://sidekiq//lib/sidekiq/api.rb#1167
  def queue; end

  # @api private
  #
  # source://sidekiq//lib/sidekiq/api.rb#1194
  def raw(name); end

  # source://sidekiq//lib/sidekiq/api.rb#1171
  def run_at; end

  # Returns the value of attribute thread_id.
  #
  # source://sidekiq//lib/sidekiq/api.rb#1158
  def thread_id; end

  private

  # @return [Boolean]
  #
  # source://sidekiq//lib/sidekiq/api.rb#1202
  def respond_to_missing?(name, *args); end
end

# The WorkSet stores the work being done by this Sidekiq cluster.
# It tracks the process and thread working on each job.
#
# WARNING WARNING WARNING
#
# This is live data that can change every millisecond.
# If you call #size => 5 and then expect #each to be
# called 5 times, you're going to have a bad time.
#
#    works = Sidekiq::WorkSet.new
#    works.size => 2
#    works.each do |process_id, thread_id, work|
#      # process_id is a unique identifier per Sidekiq process
#      # thread_id is a unique identifier per thread
#      # work is a Hash which looks like:
#      # { 'queue' => name, 'run_at' => timestamp, 'payload' => job_hash }
#      # run_at is an epoch Integer.
#    end
#
# source://sidekiq//lib/sidekiq/api.rb#1093
class Sidekiq::WorkSet
  include ::Enumerable

  # source://sidekiq//lib/sidekiq/api.rb#1096
  def each(&block); end

  # Find the work which represents a job with the given JID.
  # *This is a slow O(n) operation*.  Do not use for app logic.
  #
  # @param jid [String] the job identifier
  # @return [Sidekiq::Work] the work or nil
  #
  # source://sidekiq//lib/sidekiq/api.rb#1146
  def find_work_by_jid(jid); end

  # Note that #size is only as accurate as Sidekiq's heartbeat,
  # which happens every 5 seconds.  It is NOT real-time.
  #
  # Not very efficient if you have lots of Sidekiq
  # processes but the alternative is a global counter
  # which can easily get out of sync with crashy processes.
  #
  # source://sidekiq//lib/sidekiq/api.rb#1125
  def size; end
end

# Sidekiq::Job is a new alias for Sidekiq::Worker as of Sidekiq 6.3.0.
# Use `include Sidekiq::Job` rather than `include Sidekiq::Worker`.
#
# The term "worker" is too generic and overly confusing, used in several
# different contexts meaning different things. Many people call a Sidekiq
# process a "worker". Some people call the thread that executes jobs a
# "worker". This change brings Sidekiq closer to ActiveJob where your job
# classes extend ApplicationJob.
#
# source://sidekiq//lib/sidekiq/worker_compatibility_alias.rb#12
Sidekiq::Worker = Sidekiq::Job

# Since "worker" is a nebulous term, we've deprecated the use of this class name.
# Is "worker" a process, a type of job, a thread? Undefined!
# WorkSet better describes the data.
#
# source://sidekiq//lib/sidekiq/api.rb#1210
Sidekiq::Workers = Sidekiq::WorkSet
