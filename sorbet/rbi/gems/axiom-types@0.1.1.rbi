# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `axiom-types` gem.
# Please instead update this file by running `bin/tapioca gem axiom-types`.

# source://axiom-types//lib/axiom/types.rb#12
module Axiom; end

# Gem namespace
#
# source://axiom-types//lib/axiom/types.rb#15
module Axiom::Types
  class << self
    # Finalize Axiom::Types::Type subclasses
    #
    # @api public
    # @example
    #   Axiom::Types.finalize  # => Axiom::Types
    # @return [Module<Axiom::Types>]
    #
    # source://axiom-types//lib/axiom/types.rb#58
    def finalize; end

    # Infer the type of an object
    #
    # @api public
    # @example
    #   Axiom::Types.infer(Integer)  # => Axiom::Types::Integer
    # @param object [Object] object to infer the type of
    # @return [Class<Axiom::Types::Type>]
    #
    # source://axiom-types//lib/axiom/types.rb#46
    def infer(object); end
  end
end

# Represents an array type
#
# source://axiom-types//lib/axiom/types/array.rb#7
class Axiom::Types::Array < ::Axiom::Types::Collection
  class << self
    private

    # Test if the type is a base type
    #
    # @api private
    # @return [Boolean]
    #
    # source://axiom-types//lib/axiom/types/array.rb#16
    def base?; end
  end
end

# Represents a boolean type
#
# source://axiom-types//lib/axiom/types/boolean.rb#7
class Axiom::Types::Boolean < ::Axiom::Types::Object
  class << self
    private

    # Infer the type if the primitive class matches
    #
    # @api private
    # @param object [Object]
    # @return [Class<Axiom::Types::Boolean>] returned if the primitive class matches
    # @return [nil] returned if the primitive class does not match
    #
    # source://axiom-types//lib/axiom/types/boolean.rb#22
    def infer_from_primitive_class(object); end
  end
end

# Represents a Class type
#
# source://axiom-types//lib/axiom/types/class.rb#7
class Axiom::Types::Class < ::Axiom::Types::Object; end

# Represents a collection type
#
# source://axiom-types//lib/axiom/types/collection.rb#7
class Axiom::Types::Collection < ::Axiom::Types::Object
  class << self
    # Finalize by setting up constraints for the member
    #
    # @api private
    # @return [Class<Axiom::Types::Collection>]
    #
    # source://axiom-types//lib/axiom/types/collection.rb#57
    def finalize; end

    # Infer the type of the object
    #
    # @api public
    # @example with a type
    #   Axiom::Types::Array.infer(Axiom::Types::Array)
    #   # => Axiom::Types::Array
    # @example with a primitive class
    #   Axiom::Types::Collection.infer(::Array)
    #   # => Axiom::Types::Array
    # @example with a primitive instance
    #   Axiom::Types::Array.infer(Array[])
    #   # => Axiom::Types::Array
    # @example with a primitive instance and a member type
    #   Axiom::Types::Collection.infer(Array[Axiom::Types::String])
    #   # => Axiom::Types::Array subclass w/String member type
    # @example with a primitive instance and a member primitive
    #   Axiom::Types::Collection.infer(Array[String])
    #   # => Axiom::Types::Array subclass w/String member type
    # @param object [Object]
    # @return [Class<Axiom::Types::Collection>] returned if the type matches
    # @return [nil] returned if the type does not match
    #
    # source://axiom-types//lib/axiom/types/collection.rb#43
    def infer(object); end

    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def member_type(*args); end

    private

    # Test if the type is a base type
    #
    # @api private
    # @return [Boolean]
    #
    # source://axiom-types//lib/axiom/types/collection.rb#127
    def base?; end

    # Infer the type from the member_type
    #
    # @api private
    # @param member_type [Class<Axiom::Types::Object>]
    # @return [Class<Axiom::Types::Collection>] returned if the member_type matches
    # @return [nil] returned if the member_type does not match
    #
    # source://axiom-types//lib/axiom/types/collection.rb#102
    def infer_from(member_type); end

    # Infer the type from a primitive instance
    #
    # @api private
    # @param object [Object]
    # @return [Class<Axiom::Types::Collection>] returned if the primitive instance matches
    # @return [nil] returned if the primitive instance does not match
    #
    # source://axiom-types//lib/axiom/types/collection.rb#86
    def infer_from_primitive_instance(object); end

    # Test if the type matches a primitive class
    #
    # @api private
    # @param object [Object]
    # @return [Boolean]
    #
    # source://axiom-types//lib/axiom/types/collection.rb#71
    def match_primitive?(*_arg0); end

    # Add a constraints for the member
    #
    # @api private
    # @return [undefined]
    #
    # source://axiom-types//lib/axiom/types/collection.rb#137
    def matches_member_type; end

    # Instantiate a new type from a base type
    #
    # @api private
    # @param member_type [Class<Axiom::Types::Object>]
    # @return [Class<Axiom::Types::Collection>] returned if a base type
    # @return [nil] returned if not a base type
    #
    # source://axiom-types//lib/axiom/types/collection.rb#117
    def new_from(member_type); end
  end
end

# A false proposition
#
# source://axiom-types//lib/axiom/types.rb#24
Axiom::Types::Contradiction = T.let(T.unsafe(nil), Proc)

# Represents a date type
#
# source://axiom-types//lib/axiom/types/date.rb#7
class Axiom::Types::Date < ::Axiom::Types::Object
  extend ::Axiom::Types::ValueComparable

  class << self
    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def maximum(*args); end

    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def minimum(*args); end
  end
end

# Represents a date time type
#
# source://axiom-types//lib/axiom/types/date_time.rb#7
class Axiom::Types::DateTime < ::Axiom::Types::Object
  extend ::Axiom::Types::ValueComparable

  class << self
    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def maximum(*args); end

    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def minimum(*args); end
  end
end

# The maximum seconds for DateTime
#
# source://axiom-types//lib/axiom/types/date_time.rb#11
Axiom::Types::DateTime::MAXIMUM_SECONDS = T.let(T.unsafe(nil), Rational)

# Represents a decimal type
#
# source://axiom-types//lib/axiom/types/decimal.rb#7
class Axiom::Types::Decimal < ::Axiom::Types::Numeric; end

# Add encoding constraints to a type
#
# source://axiom-types//lib/axiom/types/encodable.rb#7
module Axiom::Types::Encodable
  # Finalize by setting up a primitive constraint
  #
  # @api private
  # @return [Axiom::Types::Encodable]
  #
  # source://axiom-types//lib/axiom/types/encodable.rb#35
  def finalize; end

  private

  # Test if the encoding is ascii compatible
  #
  # @api private
  # @return [Boolean]
  #
  # source://axiom-types//lib/axiom/types/encodable.rb#48
  def ascii_compatible?; end

  # Add constraint for the ascii compatible encoding
  #
  # @api private
  # @return [undefined]
  #
  # source://axiom-types//lib/axiom/types/encodable.rb#57
  def use_ascii_compatible_encoding; end

  # Add constraint for the encoding
  #
  # @api private
  # @return [undefined]
  #
  # source://axiom-types//lib/axiom/types/encodable.rb#68
  def use_encoding; end

  class << self
    private

    # Hook called when module is extended
    #
    # Add #encoding DSL method to descendant and set the default to UTF-8.
    #
    # @api private
    # @param descendant [Class<Axiom::Types::Type>]
    # @return [undefined]
    #
    # source://axiom-types//lib/axiom/types/encodable.rb#22
    def extended(descendant); end
  end
end

# Represents a decimal type
#
# source://axiom-types//lib/axiom/types/float.rb#7
class Axiom::Types::Float < ::Axiom::Types::Numeric; end

# Represents a hash type
#
# source://axiom-types//lib/axiom/types/hash.rb#7
class Axiom::Types::Hash < ::Axiom::Types::Object
  class << self
    # Finalize by setting up constraints for the key and value
    #
    # @api private
    # @return [Class<Axiom::Types::Hash>]
    #
    # source://axiom-types//lib/axiom/types/hash.rb#42
    def finalize; end

    # Infer the type of the object
    #
    # @api public
    # @example
    #   type = Axiom::Types.infer(object)
    # @param object [Object]
    # @return [Class<Axiom::Types::Hash>] returned if the type matches
    # @return [nil] returned if the type does not match
    #
    # source://axiom-types//lib/axiom/types/hash.rb#28
    def infer(object); end

    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def key_type(*args); end

    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def value_type(*args); end

    private

    # Test if the type is a base type
    #
    # @api private
    # @return [Boolean]
    #
    # source://axiom-types//lib/axiom/types/hash.rb#118
    def base?; end

    # Infer the type from the key_type and value_type
    #
    # @api private
    # @param key_type [Class<Axiom::Types::Object>]
    # @param value_type [Class<Axiom::Types::Object>]
    # @return [Class<Axiom::Types::Hash>] returned if the key_type and value_type match
    # @return [nil] returned if the key_type and value_type do not match
    #
    # source://axiom-types//lib/axiom/types/hash.rb#91
    def infer_from(key_type, value_type); end

    # Infer the type from a primitive instance
    #
    # @api private
    # @param object [Object]
    # @return [Class<Axiom::Types::Hash>] returned if the primitive instance matches
    # @return [nil] returned if the primitive instance does not match
    #
    # source://axiom-types//lib/axiom/types/hash.rb#72
    def infer_from_primitive_instance(object); end

    # Test if the type matches a primitive class
    #
    # @api private
    # @param object [Object]
    # @return [Boolean]
    #
    # source://axiom-types//lib/axiom/types/hash.rb#57
    def match_primitive?(*_arg0); end

    # Add a constraints for the key and value
    #
    # @api private
    # @return [undefined]
    #
    # source://axiom-types//lib/axiom/types/hash.rb#128
    def matches_key_and_value_types; end

    # Instantiate a new type from a base type
    #
    # @api private
    # @param key_type [Class<Axiom::Types::Object>]
    # @param value_type [Class<Axiom::Types::Object>]
    # @return [Class<Axiom::Types::Hash>] returned if a base type
    # @return [nil] returned if not a base type
    #
    # source://axiom-types//lib/axiom/types/hash.rb#108
    def new_from(key_type, value_type); end
  end
end

# Represent an infinite number
#
# source://axiom-types//lib/axiom/types/support/infinity.rb#7
class Axiom::Types::Infinity
  include ::Singleton
  include ::Comparable
  extend ::DescendantsTracker
  extend ::Axiom::Types::Options
  extend ::Singleton::SingletonClassMethods

  # Test the number against infinity
  #
  # @api private
  # @param other [Numeric, Infinity]
  # @return [0] returned if the other object is infinity
  # @return [1] returned if the other object is something other than infinity
  #
  # source://axiom-types//lib/axiom/types/support/infinity.rb#25
  def <=>(other); end

  # Coerce a number into an Infinity instance for comparison
  #
  # @api private
  # @param other [::Numeric]
  # @return [Array(Infinity, Infinity)]
  #
  # source://axiom-types//lib/axiom/types/support/infinity.rb#41
  def coerce(other); end

  # Return the next successive object, which is always self
  #
  # @api private
  # @return [Infinity]
  #
  # source://axiom-types//lib/axiom/types/support/infinity.rb#56
  def succ; end

  private

  # The inverse instance
  #
  # @api private
  # @return [Infinity]
  #
  # source://axiom-types//lib/axiom/types/support/infinity.rb#67
  def inverse; end

  class << self
    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def inverse(*args); end

    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def number(*args); end
  end
end

# Represents a decimal type
#
# source://axiom-types//lib/axiom/types/integer.rb#7
class Axiom::Types::Integer < ::Axiom::Types::Numeric; end

# Add a minimum and maximum length constraint to a type
#
# source://axiom-types//lib/axiom/types/length_comparable.rb#7
module Axiom::Types::LengthComparable
  # Finalize by setting up a length range constraint
  #
  # @api private
  # @return [Axiom::Types::LengthComparable]
  #
  # source://axiom-types//lib/axiom/types/length_comparable.rb#39
  def finalize; end

  # The range of allowed lengths
  #
  # @api public
  # @return [Range]
  #
  # source://axiom-types//lib/axiom/types/length_comparable.rb#14
  def range; end

  private

  # Add a constraint for a length within a range
  #
  # @api private
  # @return [undefined]
  # @todo freeze the minimum_length and maximum_length
  #
  # source://axiom-types//lib/axiom/types/length_comparable.rb#55
  def use_length_within_range; end

  class << self
    # Hook called when module is extended
    #
    # Add #minimum_length and #maximum_length DSL methods to descendant.
    #
    # @api private
    # @param descendant [Class<Axiom::Types::Type>]
    # @return [undefined]
    #
    # source://axiom-types//lib/axiom/types/length_comparable.rb#25
    def extended(descendant); end
  end
end

# Represent a negative infinite number
#
# source://axiom-types//lib/axiom/types/support/infinity.rb#74
class Axiom::Types::NegativeInfinity < ::Axiom::Types::Infinity
  # Test the number against negative infinity
  #
  # @api private
  # @param _other [Numeric, Infinity]
  # @return [0] returned if the other object is negative infinity
  # @return [-1] returned if the other object is not negative infinity
  #
  # source://axiom-types//lib/axiom/types/support/infinity.rb#87
  def <=>(_other); end
end

# Represents a numeric type
#
# source://axiom-types//lib/axiom/types/numeric.rb#7
class Axiom::Types::Numeric < ::Axiom::Types::Object
  extend ::Axiom::Types::ValueComparable

  class << self
    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def maximum(*args); end

    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def minimum(*args); end
  end
end

# Represents an object type
#
# source://axiom-types//lib/axiom/types/object.rb#7
class Axiom::Types::Object < ::Axiom::Types::Type
  class << self
    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def coercion_method(*args); end

    # Finalize by setting up a primitive constraint
    #
    # @api private
    # @return [Class<Axiom::Types::Object>]
    #
    # source://axiom-types//lib/axiom/types/object.rb#34
    def finalize; end

    # Infer the type of the object
    #
    # @api public
    # @example
    #   Axiom::Types::Object.infer(::Object)  # => Axiom::Types::Object
    # @param object [Object]
    # @return [Class<Axiom::Types::Object>] returned if the type matches
    # @return [nil] returned if the type does not match
    #
    # source://axiom-types//lib/axiom/types/object.rb#25
    def infer(object); end

    # The type name and primitive
    #
    # @api public
    # @return [String]
    #
    # source://axiom-types//lib/axiom/types/object.rb#45
    def inspect; end

    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def primitive(*args); end

    private

    # Infer the type if the primitive class matches
    #
    # @api private
    # @param object [Object]
    # @return [Class<Axiom::Types::Object>] returned if the primitive class matches
    # @return [nil] returned if the primitive class does not match
    #
    # source://axiom-types//lib/axiom/types/object.rb#59
    def infer_from_primitive_class(object); end

    # Add a constraint for the primitive
    #
    # @api private
    # @return [undefined]
    #
    # source://axiom-types//lib/axiom/types/object.rb#82
    def inherits_from_primitive; end

    # Test if the type matches a primitive class
    #
    # @api private
    # @param object [Object]
    # @return [Boolean]
    #
    # source://axiom-types//lib/axiom/types/object.rb#71
    def match_primitive?(object); end
  end
end

# A module that adds class and instance level options
#
# source://axiom-types//lib/axiom/types/support/options.rb#7
module Axiom::Types::Options
  # Defines which options are valid for a given attribute class
  #
  # @api public
  # @example
  #   class MyTypes < Axiom::Types::Object
  #   accept_options :foo, :bar
  #   end
  # @return [self]
  #
  # source://axiom-types//lib/axiom/types/support/options.rb#22
  def accept_options(*new_options); end

  protected

  # Set up the option in the current class and descendants
  #
  # @api private
  # @param new_option [Symbol] new option to be added
  # @return [self]
  #
  # source://axiom-types//lib/axiom/types/support/options.rb#41
  def setup_option(new_option); end

  private

  # Returns an array of valid options
  #
  # @api private
  # @example
  #   Axiom::Types::String.accepted_options
  #   # => [:primitive, :accessor, :reader, :writer]
  # @return [Array] the array of valid option names
  #
  # source://axiom-types//lib/axiom/types/support/options.rb#92
  def accepted_options; end

  # Assert that the option is not already defined
  #
  # @api private
  # @param name [Symbol]
  # @raise [ReservedMethodError] raised when the method is already defined
  # @return [undefined]
  #
  # source://axiom-types//lib/axiom/types/support/options.rb#106
  def assert_method_available(name); end

  # Adds a reader/writer method for the give option name
  #
  # @api private
  # @param name [#to_s]
  # @return [undefined]
  #
  # source://axiom-types//lib/axiom/types/support/options.rb#121
  def define_option_method(name); end

  # Adds descendant to descendants array and inherits default options
  #
  # @api private
  # @param descendant [Class]
  # @return [undefined]
  #
  # source://axiom-types//lib/axiom/types/support/options.rb#59
  def inherited(descendant); end

  # Returns default options hash for a given attribute class
  #
  # @api private
  # @example
  #   Axiom::Types::String.options
  #   # => {:primitive => String}
  # @return [Hash] a hash of default option values
  #
  # source://axiom-types//lib/axiom/types/support/options.rb#76
  def options; end
end

# Raised when the method is already used
#
# source://axiom-types//lib/axiom/types/support/options.rb#10
class Axiom::Types::Options::ReservedMethodError < ::ArgumentError; end

# Represents a set type
#
# source://axiom-types//lib/axiom/types/set.rb#7
class Axiom::Types::Set < ::Axiom::Types::Collection
  class << self
    private

    # Test if the type is a base type
    #
    # @api private
    # @return [Boolean]
    #
    # source://axiom-types//lib/axiom/types/set.rb#16
    def base?; end
  end
end

# Represents a string type
#
# source://axiom-types//lib/axiom/types/string.rb#7
class Axiom::Types::String < ::Axiom::Types::Object
  extend ::Axiom::Types::Encodable
  extend ::Axiom::Types::LengthComparable

  class << self
    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def encoding(*args); end

    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def maximum_length(*args); end

    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def minimum_length(*args); end
  end
end

# Represents a symbol type
#
# source://axiom-types//lib/axiom/types/symbol.rb#7
class Axiom::Types::Symbol < ::Axiom::Types::Object
  extend ::Axiom::Types::Encodable
  extend ::Axiom::Types::LengthComparable

  class << self
    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def encoding(*args); end

    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def maximum_length(*args); end

    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def minimum_length(*args); end
  end
end

# A true proposition
#
# source://axiom-types//lib/axiom/types.rb#21
Axiom::Types::Tautology = T.let(T.unsafe(nil), Proc)

# Represents a date time type
#
# source://axiom-types//lib/axiom/types/time.rb#7
class Axiom::Types::Time < ::Axiom::Types::Object
  extend ::Axiom::Types::ValueComparable

  class << self
    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def maximum(*args); end

    # source://axiom-types//lib/axiom/types/support/options.rb#123
    def minimum(*args); end
  end
end

# source://axiom-types//lib/axiom/types/time.rb#12
Axiom::Types::Time::MAXIMUM_SECONDS = T.let(T.unsafe(nil), Integer)

# The minimum and maximum seconds for Time on 32-bit systems
#
# source://axiom-types//lib/axiom/types/time.rb#11
Axiom::Types::Time::MINIMUM_SECONDS = T.let(T.unsafe(nil), Integer)

# Abstract base class for every type
#
# source://axiom-types//lib/axiom/types/type.rb#7
class Axiom::Types::Type
  extend ::DescendantsTracker
  extend ::Axiom::Types::Options

  class << self
    # Test if the type is anonymous
    #
    # @api public
    # @return [Boolean]
    #
    # source://axiom-types//lib/axiom/types/type.rb#157
    def anonymous?; end

    # The base type for the type
    #
    # @api public
    # @return [Class<Axiom::Types::Type>]
    #
    # source://axiom-types//lib/axiom/types/type.rb#139
    def base; end

    # Test if the type is a base type
    #
    # @api public
    # @return [Boolean]
    #
    # source://axiom-types//lib/axiom/types/type.rb#148
    def base?; end

    # Add a constraint to the type
    #
    # @api public
    # @example with an argument
    #   type.constraint(->(object) { object == 42 }
    # @example with a block
    #   type.constraint { |object| object == 42 }
    # @example with no arguments
    #   type.constraint  # => constraint
    # @param constraint [#call] optional constraint
    # @return [Class<Axiom::Types::Type>]
    # @yield [object]
    # @yieldparam object [Object] test if the object matches the type constraint
    # @yieldreturn [Boolean] true if the object matches the type constraint
    #
    # source://axiom-types//lib/axiom/types/type.rb#113
    def constraint(constraint = T.unsafe(nil), &block); end

    # Finalize by deep freezing
    #
    # @api private
    # @return [Class<Axiom::Types::Type>]
    #
    # source://axiom-types//lib/axiom/types/type.rb#58
    def finalize; end

    # Test if the object matches the type constraint
    #
    # @api public
    # @example
    #   type = Axiom::Types::Integer.new do
    #   minimum 1
    #   maximum 100
    #   end
    #
    #   type.include?(1)    # => true
    #   type.include?(100)  # => true
    #   type.include?(0)    # => false
    #   type.include?(101)  # => false
    # @param object [Object]
    # @return [Boolean]
    #
    # source://axiom-types//lib/axiom/types/type.rb#81
    def include?(object); end

    # Add a constraint that the object must be included in a set
    #
    # @api private
    # @param members [Array<Object>]
    # @return [undefined]
    # @todo move into a module
    #
    # source://axiom-types//lib/axiom/types/type.rb#129
    def includes(*members); end

    # Infer the type of the object
    #
    # @api public
    # @example
    #   type = Axiom::Types::Type.infer(Axiom::Types::Integer)
    #   # => Axiom::Types::Integer
    # @param object [Object]
    # @return [Class<Axiom::Types::Type>]
    #
    # source://axiom-types//lib/axiom/types/type.rb#24
    def infer(object); end

    # Instantiate a new Axiom::Types::Type subclass
    #
    # @api public
    # @example
    #   type = Axiom::Types::Type.new  # => Axiom::Types::Type
    # @param args [Array(#call)] optional constraint for the new type
    # @return [Class<Axiom::Types::Type>]
    # @yield [object]
    # @yieldparam object [Object] test if the object matches the type constraint
    # @yieldreturn [Boolean] true if the object matches the type constraint
    #
    # source://axiom-types//lib/axiom/types/type.rb#47
    def new(*args, &block); end

    private

    # Add new constraint to existing constraint, if any
    #
    # @api private
    # @param constraint [#call]
    # @return [undefined]
    #
    # source://axiom-types//lib/axiom/types/type.rb#168
    def add_constraint(constraint); end
  end
end

# Represent an undefined argument
#
# source://axiom-types//lib/axiom/types.rb#18
Axiom::Types::Undefined = T.let(T.unsafe(nil), Object)

# Gem version
#
# source://axiom-types//lib/axiom/types/version.rb#7
Axiom::Types::VERSION = T.let(T.unsafe(nil), String)

# Add a minimum and maximum value constraint to a type
#
# source://axiom-types//lib/axiom/types/value_comparable.rb#7
module Axiom::Types::ValueComparable
  # Finalize by setting up a value range constraint
  #
  # @api private
  # @return [Axiom::Types::ValueComparable]
  #
  # source://axiom-types//lib/axiom/types/value_comparable.rb#35
  def finalize; end

  # The range of allowed values
  #
  # @api public
  # @return [Range]
  #
  # source://axiom-types//lib/axiom/types/value_comparable.rb#14
  def range; end

  private

  # Add a constraint for a value within a range
  #
  # @api private
  # @return [undefined]
  # @todo freeze the minimum and maximum
  #
  # source://axiom-types//lib/axiom/types/value_comparable.rb#51
  def use_value_within_range; end

  class << self
    # Hook called when module is extended
    #
    # Add #minimum and #maximum DSL methods to descendant.
    #
    # @api private
    # @param descendant [Class<Axiom::Types::Type>]
    # @return [undefined]
    #
    # source://axiom-types//lib/axiom/types/value_comparable.rb#25
    def extended(descendant); end
  end
end
