# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rgeo` gem.
# Please instead update this file by running `bin/tapioca gem rgeo`.


# -----------------------------------------------------------------------------
#
# Well-known text generator for RGeo
#
# -----------------------------------------------------------------------------
#
# source://rgeo//lib/rgeo/version.rb#3
module RGeo; end

# source://rgeo//lib/rgeo/cartesian/calculations.rb#10
module RGeo::Cartesian
  class << self
    # Creates and returns a cartesian factory of the preferred
    # Cartesian implementation.
    #
    # The actual implementation returned depends on which ruby
    # interpreter is running and what libraries are available.
    # RGeo will try to provide a fully-functional and performant
    # implementation if possible. If not, the simple Cartesian
    # implementation will be returned.
    # In practice, this means it returns a Geos implementation if
    # available; otherwise it falls back to the simple implementation.
    #
    # The given options are passed to the factory's constructor.
    # What options are available depends on the particular
    # implementation. See RGeo::Geos.factory and
    # RGeo::Cartesian.simple_factory for details. Unsupported options
    # are ignored.
    #
    # source://rgeo//lib/rgeo/cartesian/interface.rb#29
    def factory(opts = T.unsafe(nil)); end

    # Creates and returns a cartesian factory of the preferred
    # Cartesian implementation.
    #
    # The actual implementation returned depends on which ruby
    # interpreter is running and what libraries are available.
    # RGeo will try to provide a fully-functional and performant
    # implementation if possible. If not, the simple Cartesian
    # implementation will be returned.
    # In practice, this means it returns a Geos implementation if
    # available; otherwise it falls back to the simple implementation.
    #
    # The given options are passed to the factory's constructor.
    # What options are available depends on the particular
    # implementation. See RGeo::Geos.factory and
    # RGeo::Cartesian.simple_factory for details. Unsupported options
    # are ignored.
    #
    # source://rgeo//lib/rgeo/cartesian/interface.rb#29
    def preferred_factory(opts = T.unsafe(nil)); end

    # Returns a factory for the simple Cartesian implementation. This
    # implementation provides all SFS 1.1 types, and also allows Z and
    # M coordinates. It does not depend on external libraries, and is
    # thus always available, but it does not implement many of the more
    # advanced geometric operations. These limitations are:
    #
    # * Relational operators such as Feature::Geometry#intersects? are
    #   not implemented for most types.
    # * Relational constructors such as Feature::Geometry#union are
    #   not implemented for most types.
    # * Buffer and convex hull calculations are not implemented for most
    #   types. Boundaries are available except for GeometryCollection.
    # * Length calculations are available, but areas are not. Distances
    #   are available only between points.
    # * Equality and simplicity evaluation are implemented for some but
    #   not all types.
    # * Assertions for polygons and multipolygons are not implemented.
    #
    # Unimplemented operations may raise Error::UnsupportedOperation
    # if invoked.
    #
    # Options include:
    #
    # [<tt>:srid</tt>]
    #   Set the SRID returned by geometries created by this factory.
    #   Default is 0.
    # [<tt>:coord_sys</tt>]
    #   The coordinate system in OGC form, either as a subclass of
    #   CoordSys::CS::CoordinateSystem, or as a string in WKT format.
    #   Optional. If no coord_sys is given, but an SRID is the factory
    #   will try to create one using the CoordSys::CONFIG.default_coord_sys_class
    #   or the given :coord_sys_class option.
    # [<tt>:coord_sys_class</tt>]
    #   CoordSys::CS::CoordinateSystem implementation used to instansiate
    #   a coord_sys based on the :srid given.
    # [<tt>:has_z_coordinate</tt>]
    #   Support a Z coordinate. Default is false.
    # [<tt>:has_m_coordinate</tt>]
    #   Support an M coordinate. Default is false.
    # [<tt>:wkt_parser</tt>]
    #   Configure the parser for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTParser.new. Default is
    #   the empty hash, indicating the default configuration for
    #   WKRep::WKTParser.
    # [<tt>:wkb_parser</tt>]
    #   Configure the parser for WKB. The value is a hash of
    #   configuration parameters for WKRep::WKBParser.new. Default is
    #   the empty hash, indicating the default configuration for
    #   WKRep::WKBParser.
    # [<tt>:wkt_generator</tt>]
    #   Configure the generator for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTGenerator.new.
    #   Default is <tt>{:convert_case => :upper}</tt>.
    # [<tt>:wkb_generator</tt>]
    #   Configure the generator for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTGenerator.new.
    #   Default is the empty hash, indicating the default configuration
    #   for WKRep::WKBGenerator.
    #
    # source://rgeo//lib/rgeo/cartesian/interface.rb#97
    def simple_factory(opts = T.unsafe(nil)); end
  end
end

# This provides includes some spatial analysis algorithms supporting
# Cartesian data.
#
# source://rgeo//lib/rgeo/cartesian/analysis.rb#13
module RGeo::Cartesian::Analysis
  class << self
    # Check orientation of a ring, returns `true` if it is counter-clockwise
    # and false otherwise.
    #
    # If the factory used is GEOS based, use the GEOS implementation to
    # check that. Otherwise, this methods falls back to `ring_direction`.
    #
    # == Note
    #
    # This method does not ensure a correct result for an invalid geometry.
    # You should make sure your ring is valid beforehand using `ring?`
    # if you are using a LineString, or directly `valid?` for a
    # `linear_ring?`.
    # This will be subject to changes in v3.
    #
    # @return [Boolean]
    #
    # source://rgeo//lib/rgeo/cartesian/analysis.rb#28
    def ccw?(ring); end

    # Check orientation of a ring, returns `true` if it is counter-clockwise
    # and false otherwise.
    #
    # If the factory used is GEOS based, use the GEOS implementation to
    # check that. Otherwise, this methods falls back to `ring_direction`.
    #
    # == Note
    #
    # This method does not ensure a correct result for an invalid geometry.
    # You should make sure your ring is valid beforehand using `ring?`
    # if you are using a LineString, or directly `valid?` for a
    # `linear_ring?`.
    # This will be subject to changes in v3.
    #
    # @return [Boolean]
    #
    # source://rgeo//lib/rgeo/cartesian/analysis.rb#28
    def counter_clockwise?(ring); end

    # Given a LineString, which must be a ring, determine whether the
    # ring proceeds clockwise or counterclockwise.
    # Returns 1 for counterclockwise, or -1 for clockwise.
    #
    # Returns 0 if the ring is empty.
    # The return value is undefined if the object is not a ring, or
    # is not in a Cartesian coordinate system.
    #
    # source://rgeo//lib/rgeo/cartesian/analysis.rb#45
    def ring_direction(ring); end
  end
end

# This is a bounding box for Cartesian data.
# The simple cartesian implementation uses this internally to compute
# envelopes. You may also use it directly to compute and represent
# bounding boxes.
#
# A bounding box is a set of ranges in each dimension: X, Y, as well
# as Z and M if supported. You can compute a bounding box for one or
# more geometry objects by creating a new bounding box object, and
# adding the geometries to it. You may then query it for the bounds,
# or use it to determine whether it encloses other geometries or
# bounding boxes.
#
# source://rgeo//lib/rgeo/cartesian/bounding_box.rb#22
class RGeo::Cartesian::BoundingBox
  # Create a new empty bounding box with the given factory.
  #
  # The factory defines the coordinate system for the bounding box,
  # and also defines whether it should track Z and M coordinates.
  # All geometries will be cast to this factory when added to this
  # bounding box, and any generated envelope geometry will have this
  # as its factory.
  #
  # Options include:
  #
  # [<tt>:ignore_z</tt>]
  #   If true, ignore z coordinates even if the factory supports them.
  #   Default is false.
  # [<tt>:ignore_m</tt>]
  #   If true, ignore m coordinates even if the factory supports them.
  #   Default is false.
  #
  # @return [BoundingBox] a new instance of BoundingBox
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#93
  def initialize(factory, opts = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#104
  def ==(other); end

  # Adjusts the extents of this bounding box to encompass the given
  # object, which may be a geometry or another bounding box.
  # Returns self.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#222
  def add(geometry); end

  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#348
  def add_geometry(geometry); end

  # Returns the midpoint M, or nil if this bounding box is empty or has no M.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#178
  def center_m; end

  # Returns the midpoint X, or nil if this bounding box is empty.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#138
  def center_x; end

  # Returns the midpoint Y, or nil if this bounding box is empty.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#150
  def center_y; end

  # Returns the midpoint Z, or nil if this bounding box is empty or has no Z.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#162
  def center_z; end

  # Returns true if this bounding box contains the given object,
  # which may be a geometry or another bounding box.
  #
  # Supports these options:
  #
  # [<tt>:ignore_z</tt>]
  #   Ignore the Z coordinate when testing, even if both objects
  #   have Z. Default is false.
  # [<tt>:ignore_m</tt>]
  #   Ignore the M coordinate when testing, even if both objects
  #   have M. Default is false.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#280
  def contains?(rhs, opts = T.unsafe(nil)); end

  # Returns true if this bounding box is degenerate. That is,
  # it is nonempty but has zero area because either or both
  # of the X or Y spans are 0.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#132
  def degenerate?; end

  # Returns true if this bounding box is still empty.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#115
  def empty?; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#104
  def eql?(other); end

  # Returns the bounding box's factory.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#24
  def factory; end

  # Returns true if this bounding box tracks M coordinates.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#30
  def has_m; end

  # Returns true if this bounding box tracks Z coordinates.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#27
  def has_z; end

  # Returns true if this bounding box is degenerate. That is,
  # it is nonempty but contains only a single point because both
  # the X and Y spans are 0. Infinitesimal boxes are also
  # always degenerate.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#124
  def infinitesimal?; end

  # Returns the M span, 0 if this bounding box is empty, or nil if it has no M.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#184
  def m_span; end

  # Returns the maximum M, or nil if this bounding box is empty.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#54
  def max_m; end

  # Returns a point representing the maximum extent in all dimensions,
  # or nil if this bounding box is empty.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#208
  def max_point; end

  # Returns the maximum X, or nil if this bounding box is empty.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#36
  def max_x; end

  # Returns the maximum Y, or nil if this bounding box is empty.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#42
  def max_y; end

  # Returns the maximum Z, or nil if this bounding box is empty.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#48
  def max_z; end

  # Returns the minimum M, or nil if this bounding box is empty.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#51
  def min_m; end

  # Returns a point representing the minimum extent in all dimensions,
  # or nil if this bounding box is empty.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#195
  def min_point; end

  # Returns the minimum X, or nil if this bounding box is empty.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#33
  def min_x; end

  # Returns the minimum Y, or nil if this bounding box is empty.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#39
  def min_y; end

  # Returns the minimum Z, or nil if this bounding box is empty.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#45
  def min_z; end

  # Returns this bounding box subdivided, as an array of bounding boxes.
  # If this bounding box is empty, returns the empty array.
  # If this bounding box is a point, returns a one-element array
  # containing the current point.
  # If the x or y span is 0, bisects the line.
  # Otherwise, generally returns a 4-1 subdivision in the X-Y plane.
  # Does not subdivide on Z or M.
  #
  # [<tt>:bisect_factor</tt>]
  #   An optional floating point value that should be greater than 1.0.
  #   If the ratio between the larger span and the smaller span is
  #   greater than this factor, the bounding box is divided only in
  #   half instead of fourths.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#309
  def subdivide(opts = T.unsafe(nil)); end

  # Converts this bounding box to an envelope, which will be the
  # empty collection (if the bounding box is empty), a point (if the
  # bounding box is not empty but both spans are 0), a line (if only
  # one of the two spans is 0) or a polygon (if neither span is 0).
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#242
  def to_geometry; end

  # Returns the X span, or 0 if this bounding box is empty.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#144
  def x_span; end

  # Returns the Y span, or 0 if this bounding box is empty.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#156
  def y_span; end

  # Returns the Z span, 0 if this bounding box is empty, or nil if it has no Z.
  #
  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#168
  def z_span; end

  private

  # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#370
  def add_point(point); end

  class << self
    # Create a bounding box given a geometry to surround.
    # The bounding box will be given the factory of the geometry.
    # You may also provide the same options available to
    # BoundingBox.new.
    #
    # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#71
    def create_from_geometry(geom, opts = T.unsafe(nil)); end

    # Create a bounding box given two corner points.
    # The bounding box will be given the factory of the first point.
    # You may also provide the same options available to
    # BoundingBox.new.
    #
    # source://rgeo//lib/rgeo/cartesian/bounding_box.rb#61
    def create_from_points(point1, point2, opts = T.unsafe(nil)); end
  end
end

# This class implements the factory for the simple cartesian
# implementation.
#
# source://rgeo//lib/rgeo/cartesian/factory.rb#13
class RGeo::Cartesian::Factory
  include ::RGeo::Feature::Factory::Instance
  include ::RGeo::ImplHelper::Utils

  # Create a new simple cartesian factory.
  #
  # See RGeo::Cartesian.simple_factory for a list of supported options.
  #
  # @return [Factory] a new instance of Factory
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#29
  def initialize(opts = T.unsafe(nil)); end

  # Equivalence test.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#80
  def ==(other); end

  # See RGeo::Feature::Factory#collection
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#218
  def collection(elems); end

  # See RGeo::Feature::Factory#coord_sys
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#23
  def coord_sys; end

  # Returns the value of attribute coordinate_dimension.
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#17
  def coordinate_dimension; end

  # Psych support
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#130
  def encode_with(coder); end

  # Equivalence test.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#80
  def eql?(other); end

  # source://rgeo//lib/rgeo/cartesian/factory.rb#244
  def generate_wkb(obj); end

  # source://rgeo//lib/rgeo/cartesian/factory.rb#240
  def generate_wkt(obj); end

  # Standard hash code
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#90
  def hash; end

  # source://rgeo//lib/rgeo/cartesian/factory.rb#142
  def init_with(coder); end

  # See RGeo::Feature::Factory#line
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#200
  def line(start, stop); end

  # See RGeo::Feature::Factory#line_string
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#194
  def line_string(points); end

  # See RGeo::Feature::Factory#linear_ring
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#206
  def linear_ring(points); end

  # Marshal support
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#96
  def marshal_dump; end

  # source://rgeo//lib/rgeo/cartesian/factory.rb#111
  def marshal_load(data); end

  # source://rgeo//lib/rgeo/cartesian/factory.rb#248
  def marshal_wkb_generator; end

  # source://rgeo//lib/rgeo/cartesian/factory.rb#252
  def marshal_wkb_parser; end

  # See RGeo::Feature::Factory#multi_line_string
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#230
  def multi_line_string(elems); end

  # See RGeo::Feature::Factory#multi_point
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#224
  def multi_point(elems); end

  # See RGeo::Feature::Factory#multi_polygon
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#236
  def multi_polygon(elems); end

  # See RGeo::Feature::Factory#parse_wkb
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#182
  def parse_wkb(str); end

  # See RGeo::Feature::Factory#parse_wkt
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#176
  def parse_wkt(str); end

  # See RGeo::Feature::Factory#point
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#188
  def point(x, y, *extra); end

  # See RGeo::Feature::Factory#polygon
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#212
  def polygon(outer_ring, inner_rings = T.unsafe(nil)); end

  # See RGeo::Feature::Factory#property
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#161
  def property(name); end

  # source://rgeo//lib/rgeo/cartesian/factory.rb#256
  def psych_wkt_generator; end

  # source://rgeo//lib/rgeo/cartesian/factory.rb#260
  def psych_wkt_parser; end

  # Returns the value of attribute spatial_dimension.
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#17
  def spatial_dimension; end

  # Returns the SRID.
  #
  # source://rgeo//lib/rgeo/cartesian/factory.rb#20
  def srid; end
end

# source://rgeo//lib/rgeo/cartesian/feature_classes.rb#64
class RGeo::Cartesian::GeometryCollectionImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::ValidOp
  include ::RGeo::Cartesian::GeometryMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def node(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def size(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#277
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#516
  def unsafe_buffer(_distance_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#410
  def unsafe_contains?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#529
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#372
  def unsafe_crosses?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def unsafe_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def unsafe_disjoint?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#501
  def unsafe_distance(_another_geometry); end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#16
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def unsafe_intersection(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#334
  def unsafe_intersects?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#86
  def unsafe_node; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def unsafe_overlaps?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#105
  def unsafe_point_on_surface; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#66
  def unsafe_size; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def unsafe_sym_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def unsafe_touches?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def unsafe_union(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def unsafe_within?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# GeometryGraph is a PlanarGraph that is built by adding
# geometries instead of edges. The GeometryGraph will
# hold a reference to an arbitrary HalfEdge on the
# interior of the geometry for every boundary in the geometry.
# For example, a polygon will have a reference to a HalfEdge for its
# exterior shell and one for every hole.
#
# source://rgeo//lib/rgeo/cartesian/planar_graph.rb#257
class RGeo::Cartesian::GeometryGraph < ::RGeo::Cartesian::PlanarGraph
  # @return [GeometryGraph] a new instance of GeometryGraph
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#261
  def initialize(geom); end

  # Returns the value of attribute geom_edges.
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#267
  def geom_edges; end

  # Returns the value of attribute parent_geometry.
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#267
  def parent_geometry; end

  private

  # Adds a GeometryCollection to the graph.
  #
  # @param col [RGeo::Feature::GeometryCollection]
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#331
  def add_collection(col); end

  # Adds a geometry to the graph and finds its
  # reference HalfEdge(s).
  #
  # @param geom [RGeo::Feature::Instance]
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#275
  def add_geometry(geom); end

  # Adds a LineString or LinearRing
  # to the graph.
  #
  # @param geom [RGeo::Feature::LineString]
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#295
  def add_line_string(geom); end

  # Adds a Polygon to the graph.
  #
  # Will add each shell seperately and find a CCW half-edge
  # for the exterior ring and a CW half-edge for interior rings
  # since these are designated as being on the interior of the polygon.
  #
  # It is possible that the half-edge will be nil if a suitable one cannot
  # be found. This indicates the polygon is likely invalid.
  #
  # @param geom [RGeo::Feature::Polygon]
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#313
  def add_polygon(geom); end

  # Finds a Half-Edge that is part of a CCW or CW rotation
  # from the input ring. Returns nil if none found.
  #
  # Will only consider half-edges that are colinear with
  # the first or last segments of the ring.
  #
  # @param ring [RGeo::Feature::LinearRing]
  # @param ccw [Boolean] true for CCW, false for CW
  # @return [HalfEdge, nil]
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#346
  def find_hedge(ring, ccw: T.unsafe(nil)); end
end

# GeomEdge will be used to store the references to the HalfEdges
#
# source://rgeo//lib/rgeo/cartesian/planar_graph.rb#259
class RGeo::Cartesian::GeometryGraph::GeomEdge < ::Struct
  # Returns the value of attribute exterior_edge
  #
  # @return [Object] the current value of exterior_edge
  def exterior_edge; end

  # Sets the attribute exterior_edge
  #
  # @param value [Object] the value to set the attribute exterior_edge to.
  # @return [Object] the newly set value
  def exterior_edge=(_); end

  # Returns the value of attribute interior_edges
  #
  # @return [Object] the current value of interior_edges
  def interior_edges; end

  # Sets the attribute interior_edges
  #
  # @param value [Object] the value to set the attribute interior_edges to.
  # @return [Object] the newly set value
  def interior_edges=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rgeo//lib/rgeo/cartesian/feature_methods.rb#11
module RGeo::Cartesian::GeometryMethods
  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#20
  def coordinate_dimension; end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#16
  def envelope; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#28
  def is_3d?; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#32
  def measured?; end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#24
  def spatial_dimension; end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#12
  def srid; end

  private

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#38
  def graph; end
end

# source://rgeo//lib/rgeo/cartesian/feature_classes.rb#33
class RGeo::Cartesian::LineImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::Line
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::BasicLineMethods
  include ::RGeo::ImplHelper::ValidOp
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::Cartesian::LineStringMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def length(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def ring?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#50
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#516
  def unsafe_buffer(_distance_); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#90
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#529
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#89
  def unsafe_crosses?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def unsafe_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def unsafe_disjoint?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#501
  def unsafe_distance(_another_geometry); end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#16
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def unsafe_intersection(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#334
  def unsafe_intersects?(_another_geometry); end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#85
  def unsafe_length; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def unsafe_overlaps?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#70
  def unsafe_ring?; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def unsafe_sym_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def unsafe_touches?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def unsafe_union(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def unsafe_within?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/cartesian/feature_classes.rb#23
class RGeo::Cartesian::LineStringImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::ValidOp
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::Cartesian::LineStringMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def length(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def ring?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#50
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#516
  def unsafe_buffer(_distance_); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#90
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#529
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#89
  def unsafe_crosses?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def unsafe_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def unsafe_disjoint?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#501
  def unsafe_distance(_another_geometry); end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#16
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def unsafe_intersection(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#334
  def unsafe_intersects?(_another_geometry); end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#85
  def unsafe_length; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def unsafe_overlaps?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#70
  def unsafe_ring?; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def unsafe_sym_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def unsafe_touches?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def unsafe_union(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def unsafe_within?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/cartesian/feature_methods.rb#67
module RGeo::Cartesian::LineStringMethods
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#89
  def crosses?(rhs); end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#85
  def length; end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#68
  def segments; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#74
  def simple?; end

  private

  # Determines if a cross occurs with another linestring.
  # Process is to get the number of proper intersections in each geom
  # then overlay and get the number of proper intersections from that.
  # If the overlaid number is higher than the sum of individual self-ints
  # then there is an intersection. Finally, we need to check the intersection
  # to see that it is not a boundary point of either segment.
  #
  # @param rhs [Feature::LineString]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#110
  def crosses_line_string?(rhs); end
end

# source://rgeo//lib/rgeo/cartesian/feature_classes.rb#44
class RGeo::Cartesian::LinearRingImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::LinearRing
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::BasicLinearRingMethods
  include ::RGeo::ImplHelper::ValidOp
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::Cartesian::LineStringMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def ccw?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def length(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def ring?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#50
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#516
  def unsafe_buffer(_distance_); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#163
  def unsafe_ccw?; end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#90
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#529
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#89
  def unsafe_crosses?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def unsafe_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def unsafe_disjoint?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#501
  def unsafe_distance(_another_geometry); end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#16
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def unsafe_intersection(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#334
  def unsafe_intersects?(_another_geometry); end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#85
  def unsafe_length; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def unsafe_overlaps?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#70
  def unsafe_ring?; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def unsafe_sym_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def unsafe_touches?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def unsafe_union(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def unsafe_within?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/cartesian/feature_classes.rb#83
class RGeo::Cartesian::MultiLineStringImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiCurve
  include ::RGeo::Feature::MultiLineString
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiLineStringMethods
  include ::RGeo::ImplHelper::ValidOp
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::Cartesian::MultiLineStringMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def length(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def node(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def size(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#101
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#516
  def unsafe_buffer(_distance_); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#120
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#529
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#372
  def unsafe_crosses?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def unsafe_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def unsafe_disjoint?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#501
  def unsafe_distance(_another_geometry); end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#16
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def unsafe_intersection(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#334
  def unsafe_intersects?(_another_geometry); end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#128
  def unsafe_length; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#86
  def unsafe_node; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def unsafe_overlaps?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#105
  def unsafe_point_on_surface; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#66
  def unsafe_size; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def unsafe_sym_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def unsafe_touches?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def unsafe_union(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def unsafe_within?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/cartesian/feature_methods.rb#127
module RGeo::Cartesian::MultiLineStringMethods
  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#128
  def length; end
end

# source://rgeo//lib/rgeo/cartesian/feature_classes.rb#73
class RGeo::Cartesian::MultiPointImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiPoint
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiPointMethods
  include ::RGeo::ImplHelper::ValidOp
  include ::RGeo::Cartesian::GeometryMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def node(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def size(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#149
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#516
  def unsafe_buffer(_distance_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#410
  def unsafe_contains?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#529
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#372
  def unsafe_crosses?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def unsafe_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def unsafe_disjoint?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#501
  def unsafe_distance(_another_geometry); end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#16
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def unsafe_intersection(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#334
  def unsafe_intersects?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#86
  def unsafe_node; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def unsafe_overlaps?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#105
  def unsafe_point_on_surface; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#66
  def unsafe_size; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def unsafe_sym_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def unsafe_touches?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def unsafe_union(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def unsafe_within?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/cartesian/feature_classes.rb#94
class RGeo::Cartesian::MultiPolygonImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiSurface
  include ::RGeo::Feature::MultiPolygon
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiPolygonMethods
  include ::RGeo::ImplHelper::ValidOp
  include ::RGeo::Cartesian::GeometryMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def area(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def centroid(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def node(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def size(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#173
  def unsafe_area; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#177
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#516
  def unsafe_buffer(_distance_); end

  # source://rgeo//lib/rgeo/feature/multi_surface.rb#57
  def unsafe_centroid; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#190
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#529
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#372
  def unsafe_crosses?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def unsafe_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def unsafe_disjoint?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#501
  def unsafe_distance(_another_geometry); end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#16
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def unsafe_intersection(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#334
  def unsafe_intersects?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#86
  def unsafe_node; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def unsafe_overlaps?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/multi_surface.rb#69
  def unsafe_point_on_surface; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#66
  def unsafe_size; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def unsafe_sym_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def unsafe_touches?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def unsafe_union(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def unsafe_within?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# A Doubly Connected Edge List (DCEL) implementation of a Planar Graph.
# It represents geometries as vertices and half-edges.
#
# It includes an incident_edges hash that maps vertices to an array
# of half-edges whose origins are that vertex.
#
# Upon instantiation, the graph will compute the intersections using
# the SweeplineIntersector, populate the incident_edges map, and
# link all cyclic edges.
#
# source://rgeo//lib/rgeo/cartesian/planar_graph.rb#14
class RGeo::Cartesian::PlanarGraph
  # Create a new PlanarGraph
  #
  # @param edges [Array<RGeo::Cartesian::Segment>] of Segments
  # @return [PlanarGraph] a new instance of PlanarGraph
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#110
  def initialize(edges = T.unsafe(nil)); end

  # Insert an edge into the graph. This will automatically
  # calculate intersections and add new vertices if necessary.
  #
  # @param edge [RGeo::Cartesian::Segment]
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#122
  def add_edge(edge); end

  # Insert multiple edges into the graph. Like +add_edge+, this automatically
  # calculates intersections and adds new vertices.
  #
  # @param new_edges [Array<RGeo::Cartesian::Segment>]
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#138
  def add_edges(new_edges); end

  # Returns the value of attribute edges.
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#116
  def edges; end

  # Returns the value of attribute incident_edges.
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#116
  def incident_edges; end

  private

  # It is possible that intersections occur when new edges are added.
  # This will split those edges into more half-edges while preserving
  # the existing half-edges when possible since geometries may reference
  # them.
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#221
  def compute_split_edges(seg, ints); end

  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#189
  def create_half_edge(edge); end

  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#183
  def create_half_edges; end

  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#195
  def insert_half_edge(half_edge); end

  # Creates a map of +proper_intersections+ for each segment
  # from a sweepline intersector.
  #
  # Can be used to determine which edges need to be split
  # after adding edges.
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#158
  def intersection_map; end

  # Links all half-edges where possible.
  # Defines +next+ and +prev+ for every half-edge by rotating
  # through all half-edges originating at a vertex.
  #
  # Assuming half-edges are sorted CCW, every sequential pair of
  # half-edges (e1, e2) can be linked by saying e1.prev = e2.twin
  # and e2.twin.next = e1.
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#207
  def link_half_edges; end
end

# HalfEdge represents an edge as 2 directed edges.
# One half-edge will have it's origin at edge.s, the other
# at edge.e. Both half-edges will be linked as each other's twins.
#
# HalfEdges also contain references to the next and prev half-edges,
# where next's origin is this half-edges destination. Prev's destination
# is this half-edge's origin.
#
# source://rgeo//lib/rgeo/cartesian/planar_graph.rb#22
class RGeo::Cartesian::PlanarGraph::HalfEdge
  include ::Comparable

  # @return [HalfEdge] a new instance of HalfEdge
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#42
  def initialize(origin); end

  # HalfEdges will be sorted around their shared vertex
  # in a CW fashion. This means that face interiors will be
  # a CCW.
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#54
  def <=>(other); end

  # Will find attempt to find a cycle starting at this
  # HalfEdge. Will end upon finding the first repeated HalfEdge
  # or a HalfEdge where +next+ is nil.
  #
  # If a block is given, each HalfEdge seen will be yielded to the block.
  #
  # @return [Enumerator]
  # @yield [_self]
  # @yieldparam _self [RGeo::Cartesian::PlanarGraph::HalfEdge] the object that the method was called on
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#65
  def and_connected; end

  # Compute the angle from the positive x-axis.
  # Used for sorting at each node.
  #
  # @return [Float]
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#91
  def angle; end

  # Return the destination of the half edge
  #
  # @return [RGeo::Feature::Point]
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#83
  def destination; end

  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#95
  def inspect; end

  # Returns the value of attribute next.
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#49
  def next; end

  # Sets the attribute next
  #
  # @param value the value to set the attribute next to.
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#49
  def next=(_arg0); end

  # Returns the value of attribute origin.
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#48
  def origin; end

  # Returns the value of attribute prev.
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#49
  def prev; end

  # Sets the attribute prev
  #
  # @param value the value to set the attribute prev to.
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#49
  def prev=(_arg0); end

  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#99
  def to_s; end

  # Returns the value of attribute twin.
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#49
  def twin; end

  # Sets the attribute twin
  #
  # @param value the value to set the attribute twin to.
  #
  # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#49
  def twin=(_arg0); end

  class << self
    # Creates 2 half edges from an edge.
    # They will be assigned as each other's twins.
    # The Half Edges will be returned in the order of points
    # of the edge (start, end).
    #
    # @param edge [RGeo::Cartesian::Segment]
    # @return [Array]
    #
    # source://rgeo//lib/rgeo/cartesian/planar_graph.rb#33
    def from_edge(edge); end
  end
end

# source://rgeo//lib/rgeo/cartesian/feature_classes.rb#13
class RGeo::Cartesian::PointImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Point
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicPointMethods
  include ::RGeo::ImplHelper::ValidOp
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::Cartesian::PointMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#58
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#56
  def unsafe_buffer(distance); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#410
  def unsafe_contains?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#62
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#372
  def unsafe_crosses?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def unsafe_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def unsafe_disjoint?(_another_geometry); end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#44
  def unsafe_distance(rhs); end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#16
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def unsafe_intersection(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#334
  def unsafe_intersects?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def unsafe_overlaps?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def unsafe_sym_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def unsafe_touches?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def unsafe_union(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def unsafe_within?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/cartesian/feature_methods.rb#43
module RGeo::Cartesian::PointMethods
  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#56
  def buffer(distance); end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#44
  def distance(rhs); end
end

# source://rgeo//lib/rgeo/cartesian/feature_classes.rb#55
class RGeo::Cartesian::PolygonImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Surface
  include ::RGeo::Feature::Polygon
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicPolygonMethods
  include ::RGeo::ImplHelper::ValidOp
  include ::RGeo::Cartesian::ValidOp
  include ::RGeo::Cartesian::GeometryMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def area(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def centroid(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def interior_ring_n(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/feature/surface.rb#50
  def unsafe_area; end

  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#52
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#516
  def unsafe_buffer(_distance_); end

  # source://rgeo//lib/rgeo/feature/surface.rb#63
  def unsafe_centroid; end

  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#78
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#529
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#372
  def unsafe_crosses?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def unsafe_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def unsafe_disjoint?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#501
  def unsafe_distance(_another_geometry); end

  # source://rgeo//lib/rgeo/cartesian/feature_methods.rb#16
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#32
  def unsafe_interior_ring_n(idx); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def unsafe_intersection(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#334
  def unsafe_intersects?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def unsafe_overlaps?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/surface.rb#75
  def unsafe_point_on_surface; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def unsafe_sym_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def unsafe_touches?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def unsafe_union(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def unsafe_within?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# Represents a line segment in the plane.
#
# source://rgeo//lib/rgeo/cartesian/calculations.rb#13
class RGeo::Cartesian::Segment
  # @return [Segment] a new instance of Segment
  #
  # source://rgeo//lib/rgeo/cartesian/calculations.rb#14
  def initialize(start, stop); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/cartesian/calculations.rb#32
  def ==(other); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/cartesian/calculations.rb#59
  def contains_point?(point); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/cartesian/calculations.rb#37
  def degenerate?; end

  # Returns the value of attribute dx.
  #
  # source://rgeo//lib/rgeo/cartesian/calculations.rb#26
  def dx; end

  # Returns the value of attribute dy.
  #
  # source://rgeo//lib/rgeo/cartesian/calculations.rb#26
  def dy; end

  # Returns the value of attribute e.
  #
  # source://rgeo//lib/rgeo/cartesian/calculations.rb#26
  def e; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/cartesian/calculations.rb#32
  def eql?(other); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/cartesian/calculations.rb#68
  def intersects_segment?(seg); end

  # source://rgeo//lib/rgeo/cartesian/calculations.rb#141
  def length; end

  # Returns the value of attribute s.
  #
  # source://rgeo//lib/rgeo/cartesian/calculations.rb#26
  def s; end

  # If this and the other segment intersect, this method will return the coordinate
  # at which they intersect, otherwise nil.
  # In the case of a partial overlap (parallel segments), this will return
  # a single point on the overlapping portion.
  #
  # @param seg [Segment]
  # @return [RGeo::Feature::Point, nil]
  #
  # source://rgeo//lib/rgeo/cartesian/calculations.rb#80
  def segment_intersection(seg); end

  # Returns a negative value if the point is to the left,
  # a positive value if the point is to the right, or
  # 0 if the point is collinear to the segment.
  #
  # source://rgeo//lib/rgeo/cartesian/calculations.rb#45
  def side(point); end

  # source://rgeo//lib/rgeo/cartesian/calculations.rb#28
  def to_s; end

  # source://rgeo//lib/rgeo/cartesian/calculations.rb#51
  def tproj(point); end
end

# Implements a Sweepline intersector to find all intersections
# in a group of segments. The idea is to use a horizontal line starting
# at y = +Infinity that sweeps down to y = -Infinity and every time it hits
# a new line, it will check if it intersects with any of the segments
# the line currently intersects at that y value.
# This is a more simplistic implementation that uses an array to hold
# observed segments instead of a sorted BST, so performance may be significantly
# worse in the case of lots of segments overlapping in y-ranges.
#
# source://rgeo//lib/rgeo/cartesian/sweepline_intersector.rb#19
class RGeo::Cartesian::SweeplineIntersector
  # @return [SweeplineIntersector] a new instance of SweeplineIntersector
  #
  # source://rgeo//lib/rgeo/cartesian/sweepline_intersector.rb#23
  def initialize(segments); end

  # Returns an ordered array of events from the input segments. Events
  # are the start and endpoints of each segment with an is_start tag to
  # indicate if this is the starting or ending event for that segment.
  #
  # Ordering is done by greatest-y -> smallest-x -> is_start = true.
  #
  # @return [Array]
  #
  # source://rgeo//lib/rgeo/cartesian/sweepline_intersector.rb#96
  def events; end

  # Computes the intersections of the input segments.
  #
  # Creates an event queue from the +events+ and adds segments to the
  # +observed_segments+ array while their ending event has not been popped
  # from the queue.
  #
  # Compares the new segment from the +is_start+ event to each observed segment
  # then adds it to +observed_segments+. Records any intersections in to the
  # returned array.
  #
  # @return [Array<RGeo::Cartesian::SweeplineIntersector::Intersection>]
  #
  # source://rgeo//lib/rgeo/cartesian/sweepline_intersector.rb#65
  def intersections; end

  # Returns the "proper" intersections from the list of segments.
  #
  # This will only return intersections that are not the start/end or
  # end/start of the 2 segments. This could be useful for finding intersections
  # in a ring for example, because knowing that segments are connected in a linestring
  # is not always helpful, but those are reported by default.
  #
  # Note: This is not the true definition of a proper intersection. A
  # truly proper intersection does not include colinear intersections and
  # the intersection must lie in the interior of both segments.
  #
  # @return [Array<RGeo::Cartesian::SweeplineIntersector::Intersection>]
  #
  # source://rgeo//lib/rgeo/cartesian/sweepline_intersector.rb#40
  def proper_intersections; end

  # Returns the value of attribute segments.
  #
  # source://rgeo//lib/rgeo/cartesian/sweepline_intersector.rb#26
  def segments; end

  private

  # Creates a pair of events from a segment
  #
  # @param segment [Segment]
  # @return [Array]
  #
  # source://rgeo//lib/rgeo/cartesian/sweepline_intersector.rb#128
  def create_event_pair(segment); end
end

# source://rgeo//lib/rgeo/cartesian/sweepline_intersector.rb#20
class RGeo::Cartesian::SweeplineIntersector::Event < ::Struct
  # Returns the value of attribute is_start
  #
  # @return [Object] the current value of is_start
  def is_start; end

  # Sets the attribute is_start
  #
  # @param value [Object] the value to set the attribute is_start to.
  # @return [Object] the newly set value
  def is_start=(_); end

  # Returns the value of attribute point
  #
  # @return [Object] the current value of point
  def point; end

  # Sets the attribute point
  #
  # @param value [Object] the value to set the attribute point to.
  # @return [Object] the newly set value
  def point=(_); end

  # Returns the value of attribute segment
  #
  # @return [Object] the current value of segment
  def segment; end

  # Sets the attribute segment
  #
  # @param value [Object] the value to set the attribute segment to.
  # @return [Object] the newly set value
  def segment=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rgeo//lib/rgeo/cartesian/sweepline_intersector.rb#21
class RGeo::Cartesian::SweeplineIntersector::Intersection < ::Struct
  # Returns the value of attribute point
  #
  # @return [Object] the current value of point
  def point; end

  # Sets the attribute point
  #
  # @param value [Object] the value to set the attribute point to.
  # @return [Object] the newly set value
  def point=(_); end

  # Returns the value of attribute s1
  #
  # @return [Object] the current value of s1
  def s1; end

  # Sets the attribute s1
  #
  # @param value [Object] the value to set the attribute s1 to.
  # @return [Object] the newly set value
  def s1=(_); end

  # Returns the value of attribute s2
  #
  # @return [Object] the current value of s2
  def s2; end

  # Sets the attribute s2
  #
  # @param value [Object] the value to set the attribute s2 to.
  # @return [Object] the newly set value
  def s2=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rgeo//lib/rgeo/cartesian/valid_op.rb#5
module RGeo::Cartesian::ValidOp
  include ::RGeo::ImplHelper::ValidOp

  # source://rgeo//lib/rgeo/cartesian/valid_op.rb#8
  def validity_helper; end
end

# source://rgeo//lib/rgeo/cartesian/valid_op.rb#13
module RGeo::Cartesian::ValidOpHelpers
  include ::RGeo::ImplHelper::ValidOpHelpers

  private

  # Checks that the interior of a polygon is connected.
  #
  # Process to do this is to walk around an interior cycle of the
  # exterior shell in the polygon's geometry graph. It will keep track
  # of all the nodes it visited and if that set is a superset of the
  # coordinates in the exterior_ring, the interior is connected, otherwise
  # it is split somewhere.
  #
  # @param poly [RGeo::Feature::Polygon]
  # @return [String] invalid_reason
  #
  # source://rgeo//lib/rgeo/cartesian/valid_op.rb#55
  def check_connected_interiors(poly); end

  # Checks that there are no invalid intersections between the components
  # of a polygon.
  #
  # @param poly [RGeo::Feature::Polygon]
  # @return [String] invalid_reason
  #
  # source://rgeo//lib/rgeo/cartesian/valid_op.rb#26
  def check_consistent_area(poly); end

  class << self
    # Checks that the interior of a polygon is connected.
    #
    # Process to do this is to walk around an interior cycle of the
    # exterior shell in the polygon's geometry graph. It will keep track
    # of all the nodes it visited and if that set is a superset of the
    # coordinates in the exterior_ring, the interior is connected, otherwise
    # it is split somewhere.
    #
    # @param poly [RGeo::Feature::Polygon]
    # @return [String] invalid_reason
    #
    # source://rgeo//lib/rgeo/cartesian/valid_op.rb#55
    def check_connected_interiors(poly); end

    # Checks that there are no invalid intersections between the components
    # of a polygon.
    #
    # @param poly [RGeo::Feature::Polygon]
    # @return [String] invalid_reason
    #
    # source://rgeo//lib/rgeo/cartesian/valid_op.rb#26
    def check_consistent_area(poly); end

    # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#326
    def check_consistent_area_mp(mpoly); end

    # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#261
    def check_holes_in_shell(poly); end

    # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#279
    def check_holes_not_nested(poly); end

    # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#187
    def check_invalid_coordinate(point); end

    # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#239
    def check_no_self_intersecting_rings(poly); end

    # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#230
    def check_no_self_intersections(ring); end

    # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#338
    def check_shells_not_nested(mpoly); end
  end
end

# This module provides data structures and tools related to coordinate
# systems and coordinate transforms. It comprises the following parts:
#
# RGeo::CoordSys::Proj4 is a wrapper around the proj4 library, which
# defines a commonly-used syntax for specifying geographic and projected
# coordinate systems, and performs coordinate transformations.
#
# The RGeo::CoordSys::CS module contains an implementation of the CS
# (coordinate systems) package of the OGC Coordinate Transform spec.
# This includes classes for representing ellipsoids, datums, coordinate
# systems, and other related concepts, as well as a parser for the WKT
# format for specifying coordinate systems.
#
# source://rgeo//lib/rgeo/coord_sys/cs/factories.rb#10
module RGeo::CoordSys; end

# source://rgeo//lib/rgeo/coord_sys.rb#27
RGeo::CoordSys::CONFIG = T.let(T.unsafe(nil), T.untyped)

# This module contains an implementation of the CS (coordinate
# systems) package of the OGC Coordinate Transform spec. It provides
# classes for representing ellipsoids, datums, coordinate systems,
# and other related concepts, as well as a parser for the WKT format
# for specifying coordinate systems.
#
# Generally, the easiest way to create coordinate system objects is
# to use RGeo::CoordSys::CS.create_from_wkt, which parses the WKT
# format. You can also use the create methods available for each
# object class.
#
# Most but not all of the spec is implemented here.
# Currently missing are:
#
# * XML format is not implemented. We're assuming that WKT is the
#   preferred format.
# * The PT and CT packages are not implemented.
# * FittedCoordinateSystem is not implemented.
# * The defaultEnvelope attribute of CS_CoordinateSystem is not
#   implemented.
#
# source://rgeo//lib/rgeo/coord_sys/cs/factories.rb#31
module RGeo::CoordSys::CS
  class << self
    # Parsees OGC WKT format and returns the object created. Raises
    # Error::ParseError if a syntax error is encounterred.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/factories.rb#142
    def create_from_wkt(str); end
  end
end

# An axis orientation constant for AxisInfo.
# Increasing ordinates values go down. This is used for vertical
# coordinate systems.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#43
RGeo::CoordSys::CS::AO_DOWN = T.let(T.unsafe(nil), Integer)

# An axis orientation constant for AxisInfo.
# Increasing ordinates values go East. This is rarely used.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#28
RGeo::CoordSys::CS::AO_EAST = T.let(T.unsafe(nil), Integer)

# An axis orientation constant for AxisInfo.
# Increasing ordinates values go North. This is usually used for
# Grid Y coordinates and Latitude.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#20
RGeo::CoordSys::CS::AO_NORTH = T.let(T.unsafe(nil), Integer)

# An axis orientation constant for AxisInfo.
# Unknown or unspecified axis orientation. This can be used for
# local or fitted coordinate systems.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#15
RGeo::CoordSys::CS::AO_OTHER = T.let(T.unsafe(nil), Integer)

# An axis orientation constant for AxisInfo.
# Increasing ordinates values go South. This is rarely used.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#24
RGeo::CoordSys::CS::AO_SOUTH = T.let(T.unsafe(nil), Integer)

# An axis orientation constant for AxisInfo.
# Increasing ordinates values go up. This is used for vertical
# coordinate systems.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#38
RGeo::CoordSys::CS::AO_UP = T.let(T.unsafe(nil), Integer)

# An axis orientation constant for AxisInfo.
# Increasing ordinates values go West. This is usually used for
# Grid X coordinates and Longitude.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#33
RGeo::CoordSys::CS::AO_WEST = T.let(T.unsafe(nil), Integer)

# == OGC spec description
#
# Definition of angular units.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#550
class RGeo::CoordSys::CS::AngularUnit < ::RGeo::CoordSys::CS::Unit
  # Returns the number of radians per AngularUnit.
  # Also available as Unit#conversion_factor.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#554
  def radians_per_unit; end

  class << self
    # Create an AngularUnit given a unit name and a conversion
    # factor in radians per unit. You may also provide the optional
    # parameters specified by the Info interface.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#563
    def create(name, radians_per_unit, *optional); end
  end
end

# == OGC spec description
#
# Details of axis. This is used to label axes, and indicate the
# orientation.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#248
class RGeo::CoordSys::CS::AxisInfo < ::RGeo::CoordSys::CS::Base
  # :startdoc:
  #
  # @return [AxisInfo] a new instance of AxisInfo
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#253
  def initialize(name, orientation); end

  # Human readable name for axis. Possible values are "X", "Y",
  # "Long", "Lat" or any other short string.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#267
  def name; end

  # Gets enumerated value for orientation.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#270
  def orientation; end

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#272
  def wkt_typename; end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#292
  def wkt_content(_); end

  class << self
    # Creates an AxisInfo. you must pass the human readable name for
    # the axis (e.g. "X", "Y", "Long", "Lat", or other short string)
    # and either an integer orientation code or a string. Possible
    # orientation values are "<tt>OTHER</tt>", "<tt>NORTH</tt>",
    # "<tt>SOUTH</tt>", "<tt>EAST</tt>", "<tt>WEST</tt>",
    # "<tt>UP</tt>", and "<tt>DOWN</tt>", or the corresponding
    # integer values 0-5.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#285
    def create(name, orientation); end
  end
end

# :stopdoc:
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#250
RGeo::CoordSys::CS::AxisInfo::NAMES_BY_VALUE = T.let(T.unsafe(nil), Array)

# This is a base class for all OGC coordinate system objects.
# This includes both interfaces and data types from the OGC
# Coordinate Transformation spec.
#
# This is a non-instantiable abstract class.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#150
class RGeo::CoordSys::CS::Base
  # Tests for equality. Two objects are defined as equal if they
  # have the same type (class) and the same WKT representation.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#160
  def ==(other); end

  # Psych support
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#219
  def encode_with(coder); end

  # Tests for equality. Two objects are defined as equal if they
  # have the same type (class) and the same WKT representation.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#160
  def eql?(other); end

  # Standard hash code
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#167
  def hash; end

  # @raise [TypeError]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#223
  def init_with(coder); end

  # Standard object inspection output
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#153
  def inspect; end

  # Marshal support
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#202
  def marshal_dump; end

  # @raise [TypeError]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#206
  def marshal_load(data); end

  # Returns the default WKT representation.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#173
  def to_s; end

  # Return the WKT representation.
  #
  # <tt>:standard_brackets</tt>
  #   If true, outputs parentheses rather than square
  #   brackets. Default is false.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#182
  def to_wkt(standard_brackets: T.unsafe(nil)); end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#239
  def brackets(standard); end

  class << self
    private

    def new(*_arg0); end
  end
end

# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#143
RGeo::CoordSys::CS::CT_DF_DISCONTINUOUS = T.let(T.unsafe(nil), Integer)

# Flags indicating parts of domain covered by a convex hull. These flags can be combined. For
# example, the value 3 corresponds to a combination of CT_DF_Inside and MF_DF_Outside, which
# means that some parts of the convex hull are inside the domain, and some parts of the convex
# hull are outside the domain
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#141
RGeo::CoordSys::CS::CT_DF_INSIDE = T.let(T.unsafe(nil), Integer)

# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#142
RGeo::CoordSys::CS::CT_DF_OUTSIDE = T.let(T.unsafe(nil), Integer)

# == OGC spec description
#
# An aggregate of two coordinate systems (CRS). One of these is
# usually a CRS based on a two dimensional coordinate system such
# as a geographic or a projected coordinate system with a horizontal
# datum. The other is a vertical CRS which is a one-dimensional
# coordinate system with a vertical datum.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#987
class RGeo::CoordSys::CS::CompoundCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  # @return [CompoundCoordinateSystem] a new instance of CompoundCoordinateSystem
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#988
  def initialize(name, head, tail, *optional); end

  # Implements CoordinateSystem#get_axis
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1002
  def get_axis(index); end

  # Implements CoordinateSystem#get_units
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1009
  def get_units(index); end

  # Gets first sub-coordinate system.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#995
  def head; end

  # Gets second sub-coordinate system.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#998
  def tail; end

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1014
  def wkt_typename; end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1030
  def wkt_content(standard_brackets); end

  class << self
    # Create a CompoundCoordinateSystem given two sub-coordinate
    # systems. You may also provide the optional parameters
    # specified by the Info interface.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1023
    def create(name, head, tail, *optional); end
  end
end

# == OGC spec description
#
# Base interface for all coordinate systems.
#
# A coordinate system is a mathematical space, where the elements
# of the space are called positions. Each position is described by
# a list of numbers. The length of the list corresponds to the
# dimension of the coordinate system. So in a 2D coordinate system
# each position is described by a list containing 2 numbers.
#
# However, in a coordinate system, not all lists of numbers
# correspond to a position -- some lists may be outside the domain
# of the coordinate system. For example, in a 2D Lat/Lon coordinate
# system, the list (91,91) does not correspond to a position.
#
# Some coordinate systems also have a mapping from the mathematical
# space into locations in the real world. So in a Lat/Lon coordinate
# system, the mathematical position (lat, long) corresponds to a
# location on the surface of the Earth. This mapping from the
# mathematical space into real-world locations is called a Datum.
#
# == Notes
#
# This is a non-instantiable abstract class. You must instantiate
# one of the subclasses GeocentricCoordinateSystem,
# GeographicCoordinateSystem, ProjectedCoordinateSystem,
# VerticalCoordinateSystem, LocalCoordinateSystem, or
# CompoundCoordinateSystem.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#911
class RGeo::CoordSys::CS::CoordinateSystem < ::RGeo::CoordSys::CS::Info
  # @return [CoordinateSystem] a new instance of CoordinateSystem
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#912
  def initialize(name, dimension, *optional); end

  # Dimension of the coordinate system
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#918
  def dimension; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#934
  def geographic?; end

  # Gets axis details for dimension within coordinate system. Each
  # dimension in the coordinate system has a corresponding axis.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#923
  def get_axis(_dimension); end

  # Gets units for dimension within coordinate system. Each
  # dimension in the coordinate system has corresponding units.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#930
  def get_units(_dimension); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#938
  def projected?; end

  # Not an OGC method, but useful for being able to
  # transform directly from a CoordinateSystem object.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#948
  def transform_coords(target_cs, x, y, z = T.unsafe(nil)); end

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#942
  def wkt_typename; end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#975
  def wkt_content(_); end

  class << self
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#954
    def create(defn, dimension = T.unsafe(nil), *optional); end

    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#968
    def create_from_wkt(str); end
  end
end

# A class implementing the CS_CoordinateSystemFactory interface.
# It provides methods for building up complex objects from simpler
# objects or values.
#
# Note that the methods of CS_CoordinateSystemFactory do not provide
# facilities for setting the authority. If you need to set authority
# values, use the create methods for the object classes themselves.
#
# source://rgeo//lib/rgeo/coord_sys/cs/factories.rb#39
class RGeo::CoordSys::CS::CoordinateSystemFactory
  # Create a CompoundCoordinateSystem from a name, and two
  # constituent coordinate systems.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/factories.rb#43
  def create_compound_coordinate_system(name, head, tail); end

  # Create an Ellipsoid from a name, semi-major axis, and semi-minor
  # axis. You can also provide a LinearUnit, but this is optional
  # and may be set to nil.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/factories.rb#51
  def create_ellipsoid(name, semi_major_axis, semi_minor_axis, linear_unit); end

  # Create an Ellipsoid from a name, semi-major axis, and an inverse
  # flattening factor. You can also provide a LinearUnit, but this
  # is optional and may be set to nil.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/factories.rb#59
  def create_flattened_sphere(name, semi_major_axis, inverse_flattening, linear_unit); end

  # Create any object given the OGC WKT format. Raises
  # Error::ParseError if a syntax error is encounterred.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/factories.rb#66
  def create_from_wkt(str); end

  # Create a GeographicCoordinateSystem, given a name, an
  # AngularUnit, a HorizontalDatum, a PrimeMeridian, and two
  # AxisInfo objects. The AxisInfo objects are optional and may be
  # set to nil.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/factories.rb#75
  def create_geographic_coordinate_system(name, angular_unit, horizontal_datum, prime_meridian, axis0, axis1); end

  # Create a HorizontalDatum given a name, a horizontal datum type
  # code, an Ellipsoid, and a WGS84ConversionInfo. The
  # WGS84ConversionInfo is optional and may be set to nil.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/factories.rb#83
  def create_horizontal_datum(name, horizontal_datum_type, ellipsoid, to_wgs84); end

  # Create a LocalCoordinateSystem given a name, a LocalDatum, a
  # Unit, and an array of at least one AxisInfo.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/factories.rb#90
  def create_local_coordinate_system(name, datum, unit, axes); end

  # Create a LocalDatum given a name and a local datum type code.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/factories.rb#96
  def create_local_datum(_name, local_datum_type); end

  # Create a PrimeMeridian given a name, an AngularUnit, and a
  # longitude offset.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/factories.rb#103
  def create_prime_meridian(_name, angular_unit, longitude); end

  # Create a ProjectedCoordinateSystem given a name, a
  # GeographicCoordinateSystem, and Projection, a LinearUnit, and
  # two AxisInfo objects. The AxisInfo objects are optional and may
  # be set to nil.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/factories.rb#112
  def create_projected_coordinate_system(name, gcs, projection, linear_unit, axis0, axis1); end

  # Create a Projection given a name, a projection class, and an
  # array of ProjectionParameter.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/factories.rb#119
  def create_projection(name, wkt_projection_class, parameters); end

  # Create a VerticalCoordinateSystem given a name, a VerticalDatum,
  # a VerticalUnit, and an AxisInfo. The AxisInfo is optional and
  # may be nil.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/factories.rb#127
  def create_vertical_coordinate_system(name, vertical_datum, vertical_unit, axis); end

  # Create a VerticalDatum given a name ane a datum type code.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/factories.rb#133
  def create_vertical_datum(name, vertical_datum_type); end
end

# CoordinateTransform object. Note it is a combo of
# CoordinateTransform and MathTransform as specified in
# the OGC standard. This is just to simplify the model
# and keep all functionality in this class.
#
# @see https://portal.ogc.org/files/?artifact_id=999 page 79
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1417
class RGeo::CoordSys::CS::CoordinateTransform < ::RGeo::CoordSys::CS::Info
  # Initialize a new CoordinateTransform
  #
  # Note this class should not be used directly since it does not
  # implement any transformation logic. It merely defines
  # what methods actual implementations must use.
  #
  # @param source_cs [CoordinateSystem]
  # @param target_cs [CoordinateSystem]
  # @param optional [Array] any params for Info or Base
  # @return [CoordinateTransform]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1428
  def initialize(source_cs, target_cs, *optional); end

  # Human readable description of domain in source coordinate system.
  #
  # @raise [NotImplementedError]
  # @return [String]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1450
  def area_of_use; end

  # Gets transformed convex hull. The supplied ordinates are interpreted as a sequence of points,
  # which generates a convex hull in the source space. The returned sequence of ordinates
  # represents a convex hull in the output space. The number of output points will often be different
  # from the number of input points. Each of the input points should be inside the valid domain (this
  # can be checked by testing the points' domain flags individually). However, the convex hull of the
  # input points may go outside the valid domain. The returned convex hull should contain the
  # transformed image of the intersection of the source convex hull and the source domain.
  #
  # @param Array<<Array<Integer>>] [Array<<Array<Integer>>] points in tuples of (x,y,z) with z being optional] points in tuples of (x,y,z) with z being optional
  # @raise [NotImplementedError]
  # @return [Array<<Array<Integer>>]] Array<<Array<Integer>>]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1504
  def codomain_convex_hull(points); end

  # Dimension of the source_cs
  #
  # @return [Integer]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1464
  def dim_source; end

  # Dimension of the target_cs
  #
  # @return [Integer]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1471
  def dim_target; end

  # Gets flags classifying domain points within a convex hull. The supplied ordinates are interpreted
  # as a sequence of points, which generates a convex hull in the source space. Conceptually, each
  # of the (usually infinite) points inside the convex hull is then tested against the source domain.
  # The flags of all these tests are then combined. In practice, implementations of different
  # transforms will use different short-cuts to avoid doing an infinite number of tests.
  #
  # @param Array<<Array<Integer>>] [Array<<Array<Integer>>] points in tuples of (x,y,z) with z being optional] points in tuples of (x,y,z) with z being optional
  # @raise [NotImplementedError]
  # @return [Array<Integer>] the domain_flags of the input points
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1490
  def domain_flags(points); end

  # Tests whether this transform does not move any points
  #
  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1478
  def identity?; end

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1443
  def inspect; end

  # Creates the inverse transform of this object. This method may fail if the transform is not one to
  # one. However, all cartographic projections should succeed.
  #
  # @return [CoordinateTransform]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1530
  def inverse; end

  # Returns the value of attribute source_cs.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1433
  def source_cs; end

  # Sets the attribute source_cs
  #
  # @param value the value to set the attribute source_cs to.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1433
  def source_cs=(_arg0); end

  # Returns the value of attribute target_cs.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1433
  def target_cs; end

  # Sets the attribute target_cs
  #
  # @param value the value to set the attribute target_cs to.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1433
  def target_cs=(_arg0); end

  # Transforms a coordinate point. The passed parameter point should not be modified.
  #
  # @param x [Integer]
  # @param y [Integer]
  # @param z [Integer] optional
  # @raise [NotImplementedError]
  # @return [Array<Integer>] transformed point coordinates in (x,y,z) order
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1514
  def transform_coords(x, y, z = T.unsafe(nil)); end

  # Transforms a coordinate point. The passed parameter point should not be modified.
  #
  # @param points [Array<Array<Integer>>] in (x,y,z) tuples where z is optional
  # @return [Array<Array<Integer>>] list of transformed point coordinates in (x,y,z) order
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1522
  def transform_list(points); end

  # Semantic type of transform. For example, a datum transformation or a coordinate conversion.
  #
  # @raise [NotImplementedError]
  # @return [String]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1457
  def transform_type; end

  # TODO: This changes depending on what type of conversion is done
  # and we can't know unless we implement the conversion ourselves.
  # We should delegate all of the wkt generation to the library
  # if possible.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1439
  def wkt_typename; end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1552
  def wkt_content(standard_brackets); end

  class << self
    # Initialize a new CoordinateTransform
    #
    # Note this class should not be used directly since it does not
    # implement any transformation logic. It merely defines
    # what methods actual implementations must use.
    #
    # @param source_cs [CoordinateSystem]
    # @param target_cs [CoordinateSystem]
    # @param optional [Array] any params for Info or Base
    # @return [CoordinateTransform]
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1545
    def create(source_cs, target_cs, *optional); end
  end
end

# == OGC spec description
#
# A set of quantities from which other quantities are calculated.
# For the OGC abstract model, it can be defined as a set of real
# points on the earth that have coordinates. EG. A datum can be
# thought of as a set of parameters defining completely the origin
# and orientation of a coordinate system with respect to the earth.
# A textual description and/or a set of parameters describing the
# relationship of a coordinate system to some predefined physical
# locations (such as center of mass) and physical directions (such
# as axis of spin). The definition of the datum may also include
# the temporal behavior (such as the rate of change of the
# orientation of the coordinate axes).
#
# == Notes
#
# This is a non-instantiable abstract class. You must instantiate
# one of the subclasses HorizontalDatum, VerticalDatum, or
# LocalDatum.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#718
class RGeo::CoordSys::CS::Datum < ::RGeo::CoordSys::CS::Info
  # @return [Datum] a new instance of Datum
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#719
  def initialize(name, datum_type, *optional); end

  # Gets the type of the datum as an enumerated code.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#725
  def datum_type; end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#729
  def wkt_content(_); end
end

# == OGC spec description
#
# An approximation of the Earth's surface as a squashed sphere.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#611
class RGeo::CoordSys::CS::Ellipsoid < ::RGeo::CoordSys::CS::Info
  # @return [Ellipsoid] a new instance of Ellipsoid
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#612
  def initialize(name, semi_major_axis, semi_minor_axis, inverse_flattening, ivf_definitive, linear_unit, *optional); end

  # Returns the LinearUnit. The units of the semi-major and
  # semi-minor axis values.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#645
  def axisunit; end

  # Returns the value of the inverse of the flattening constant. The
  # inverse flattening is related to the equatorial/polar radius by
  # the formula ivf=re/(re-rp). For perfect spheres, this formula
  # breaks down, and a special IVF value of zero is used.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#634
  def inverse_flattening; end

  # Is the Inverse Flattening definitive for this ellipsoid? Some
  # ellipsoids use the IVF as the defining value, and calculate the
  # polar radius whenever asked. Other ellipsoids use the polar
  # radius to calculate the IVF whenever asked. This distinction can
  # be important to avoid floating-point rounding errors.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#641
  def ivf_definitive; end

  # Gets the equatorial radius. The returned length is expressed in
  # this object's axis units.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#624
  def semi_major_axis; end

  # Gets the polar radius. The returned length is expressed in this
  # object's axis units.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#628
  def semi_minor_axis; end

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#647
  def wkt_typename; end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#694
  def wkt_content(_); end

  class << self
    # Create an Ellipsoid given a name, semi-major and semi-minor
    # axes, the inverse flattening, a boolean indicating whether
    # the inverse flattening is definitive, and the LinearUnit
    # indicating the axis units. The LinearUnit is optional and
    # may be set to nil. You may also provide the optional parameters
    # specified by the Info interface.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#659
    def create(name, semi_major_axis, semi_minor_axis, inverse_flattening, ivf_definitive, linear_unit, *optional); end

    # Create an Ellipsoid given a name, semi-major and semi-minor
    # axes, and the LinearUnit indicating the axis units. In the
    # resulting ellipsoid, the inverse flattening is not definitive.
    # The LinearUnit is optional and may be set to nil. You may also
    # provide the optional parameters specified by the Info interface.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#669
    def create_ellipsoid(name, semi_major_axis, semi_minor_axis, linear_unit, *optional); end

    # Create an Ellipsoid given a name, semi-major axis, inverse
    # flattening, and the LinearUnit indicating the axis units. In
    # the resulting ellipsoid, the inverse flattening is definitive.
    # The LinearUnit is optional and may be set to nil. You may also
    # provide the optional parameters specified by the Info interface.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#683
    def create_flattened_sphere(name, semi_major_axis, inverse_flattening, linear_unit, *optional); end
  end
end

# == OGC spec description
#
# A 3D coordinate system, with its origin at the centre of the
# Earth. The X axis points towards the prime meridian. The Y axis
# points East or West. The Z axis points North or South. By default
# the Z axis will point North, and the Y axis will point East (e.g.
# a right handed system), but you should check the axes for
# non-default values.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1109
class RGeo::CoordSys::CS::GeocentricCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  # @return [GeocentricCoordinateSystem] a new instance of GeocentricCoordinateSystem
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1110
  def initialize(name, horizontal_datum, prime_meridian, linear_unit, axis0, axis1, axis2, *optional); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1144
  def geographic?; end

  # Implements CoordinateSystem#get_axis
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1140
  def get_axis(index); end

  # Implements CoordinateSystem#get_units
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1134
  def get_units(_index); end

  # Returns the HorizontalDatum. The horizontal datum is used to
  # determine where the centre of the Earth is considered to be.
  # All coordinate points will be measured from the centre of the
  # Earth, and not the surface.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1124
  def horizontal_datum; end

  # Gets the units used along all the axes.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1130
  def linear_unit; end

  # Returns the PrimeMeridian.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1127
  def prime_meridian; end

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1148
  def wkt_typename; end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1166
  def wkt_content(standard_brackets); end

  class << self
    # Create a GeocentricCoordinateSystem given a name, a
    # HorizontalDatum, a PrimeMeridian, a LinearUnit, and three
    # AxisInfo objects. The AxisInfo are optional and may be nil.
    # You may also provide the optional parameters specified by the
    # Info interface.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1159
    def create(name, horizontal_datum, prime_meridian, linear_unit, axis0, axis1, axis2, *optional); end
  end
end

# == OGC spec description
#
# A coordinate system based on latitude and longitude. Some
# geographic coordinate systems are Lat/Lon, and some are Lon/Lat.
# You can find out which this is by examining the axes. You should
# also check the angular units, since not all geographic coordinate
# systems use degrees.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1263
class RGeo::CoordSys::CS::GeographicCoordinateSystem < ::RGeo::CoordSys::CS::HorizontalCoordinateSystem
  # @return [GeographicCoordinateSystem] a new instance of GeographicCoordinateSystem
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1264
  def initialize(name, angular_unit, horizontal_datum, prime_meridian, axis0, axis1, *optional); end

  # Returns the AngularUnit. The angular unit must be the same as
  # the CS_CoordinateSystem units.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1277
  def angular_unit; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1307
  def geographic?; end

  # Implements CoordinateSystem#get_axis
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1287
  def get_axis(index); end

  # Implements CoordinateSystem#get_units
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1281
  def get_units(_index); end

  # Gets details on a conversion to WGS84. Some geographic
  # coordinate systems provide several transformations into WGS84,
  # which are designed to provide good accuracy in different areas
  # of interest. The first conversion (with index=0) should provide
  # acceptable accuracy over the largest possible area of interest.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1303
  def get_wgs84_conversion_info(_index); end

  # Gets the number of available conversions to WGS84 coordinates.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1293
  def num_conversion_to_wgs84; end

  # Returns the PrimeMeridian.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1273
  def prime_meridian; end

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1311
  def wkt_typename; end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1329
  def wkt_content(standard_brackets); end

  class << self
    # Create a GeographicCoordinateSystem, given a name, an
    # AngularUnit, a HorizontalDatum, a PrimeMeridian, and two
    # AxisInfo objects. The AxisInfo objects are optional and may
    # be set to nil. You may also provide the optional parameters
    # specified by the Info interface.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1322
    def create(name, angular_unit, horizontal_datum, prime_meridian, axis0, axis1, *optional); end
  end
end

# A datum type constant for HorizontalDatum.
# These datums, such as ED50, NAD27 and NAD83, have been designed
# to support horizontal positions on the ellipsoid as opposed to
# positions in 3-D space. These datums were designed mainly to
# support a horizontal component of a position in a domain of
# limited extent, such as a country, a region or a continent.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#61
RGeo::CoordSys::CS::HD_CLASSIC = T.let(T.unsafe(nil), Integer)

# A datum type constant for HorizontalDatum.
# A geocentric datum is a "satellite age" modern geodetic datum
# mainly of global extent, such as WGS84 (used in GPS), PZ90 (used
# in GLONASS) and ITRF. These datums were designed to support both
# a horizontal component of position and a vertical component of
# position (through ellipsoidal heights). The regional realizations
# of ITRF, such as ETRF, are also included in this category.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#70
RGeo::CoordSys::CS::HD_GEOCENTRIC = T.let(T.unsafe(nil), Integer)

# A datum type constant for HorizontalDatum.
# Highest possible value for horizontal datum types.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#74
RGeo::CoordSys::CS::HD_MAX = T.let(T.unsafe(nil), Integer)

# A datum type constant for HorizontalDatum.
# Lowest possible value for horizontal datum types.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#47
RGeo::CoordSys::CS::HD_MIN = T.let(T.unsafe(nil), Integer)

# A datum type constant for HorizontalDatum.
# Unspecified horizontal datum type. Horizontal datums with this
# type should never supply a conversion to WGS84 using Bursa Wolf
# parameters.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#53
RGeo::CoordSys::CS::HD_OTHER = T.let(T.unsafe(nil), Integer)

# == OGC spec description
#
# A 2D coordinate system suitable for positions on the Earth's surface.
#
# == Notes
#
# This is a non-instantiable abstract class. You must instantiate
# one of the subclasses GeographicCoordinateSystem or
# ProjectedCoordinateSystem.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1246
class RGeo::CoordSys::CS::HorizontalCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  # @return [HorizontalCoordinateSystem] a new instance of HorizontalCoordinateSystem
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1247
  def initialize(name, horizontal_datum, *optional); end

  # Returns the HorizontalDatum.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1253
  def horizontal_datum; end
end

# == OGC spec description
#
# Procedure used to measure positions on the surface of the Earth.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#791
class RGeo::CoordSys::CS::HorizontalDatum < ::RGeo::CoordSys::CS::Datum
  # @return [HorizontalDatum] a new instance of HorizontalDatum
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#792
  def initialize(name, datum_type, ellipsoid, wgs84_parameters, *optional); end

  # Returns the Ellipsoid.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#799
  def ellipsoid; end

  # Gets preferred parameters for a Bursa Wolf transformation into
  # WGS84. The 7 returned values correspond to (dx,dy,dz) in meters,
  # (ex,ey,ez) in arc-seconds, and scaling in parts-per-million.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#804
  def wgs84_parameters; end

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#806
  def wkt_typename; end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#823
  def wkt_content(standard_brackets); end

  class << self
    # Create a HorizontalDatum given a name, datum type code,
    # Ellipsoid, and WGS84ConversionInfo. The WGS84ConversionInfo
    # is optional and may be set to nil. You may also provide the
    # optional parameters specified by the Info interface.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#816
    def create(name, datum_type, ellipsoid, wgs84_parameters, *optional); end
  end
end

# == OGC spec description
#
# A base interface for metadata applicable to coordinate system
# objects.
#
# The metadata items "Abbreviation", "Alias", "Authority",
# "AuthorityCode", "Name" and "Remarks" were specified in the Simple
# Features interfaces, so they have been kept here.
#
# This specification does not dictate what the contents of these
# items should be. However, the following guidelines are suggested:
#
# When CS_CoordinateSystemAuthorityFactory is used to create an
# object, the "Authority" and "AuthorityCode" values should be set
# to the authority name of the factory object, and the authority
# code supplied by the client, respectively. The other values may or
# may not be set. (If the authority is EPSG, the implementer may
# consider using the corresponding metadata values in the EPSG
# tables.)
#
# When CS_CoordinateSystemFactory creates an object, the "Name"
# should be set to the value supplied by the client. All of the
# other metadata items should be left empty.
#
# == Notes
#
# This is a non-instantiable abstract class.
#
# Most subclasses will have a set of optional parameters in their
# "create" method to set the metadata fields. These parameters are,
# in order:
#
# * <b>authority</b>: authority name
# * <b>authority_code</b>: authority-specific identification code
# * <b>abbreviation</b>: an abbreviation
# * <b>alias</b>: an alias
# * <b>remarks</b>: provider-supplied remarks.
# * <b>extensions</b>: a hash of extension keys and values
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#430
class RGeo::CoordSys::CS::Info < ::RGeo::CoordSys::CS::Base
  # @return [Info] a new instance of Info
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#431
  def initialize(name, authority = T.unsafe(nil), authority_code = T.unsafe(nil), abbreviation = T.unsafe(nil), init_alias = T.unsafe(nil), remarks = T.unsafe(nil), extensions = T.unsafe(nil)); end

  # Gets the abbreviation.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#445
  def abbreviation; end

  # Gets the alias.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#448
  def alias; end

  # Gets the authority name.
  # An Authority is an organization that maintains definitions of
  # Authority Codes. For example the European Petroleum Survey Group
  # (EPSG) maintains a database of coordinate systems, and other
  # spatial referencing objects, where each object has a code number
  # ID. For example, the EPSG code for a WGS84 Lat/Lon coordinate
  # system is "4326".
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#457
  def authority; end

  # Gets the authority-specific identification code.
  # The AuthorityCode is a compact string defined by an Authority to
  # reference a particular spatial reference object. For example,
  # the European Survey Group (EPSG) authority uses 32 bit integers
  # to reference coordinate systems, so all their code strings will
  # consist of a few digits. The EPSG code for WGS84 Lat/Lon is
  # "4326".
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#466
  def authority_code; end

  # Gets the value of a keyed extension.
  # This is not part of the OGC spec, but it is supported because
  # some coordinate system databases (such as the spatial_ref_sys
  # table for PostGIS 2.0) include it.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#478
  def extension(key); end

  # Gets the name.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#469
  def name; end

  # Gets the provider-supplied remarks.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#472
  def remarks; end
end

# A datum type constant for LocalDatum.
# Highest possible value for local datum types.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#135
RGeo::CoordSys::CS::LD_MAX = T.let(T.unsafe(nil), Integer)

# A datum type constant for LocalDatum.
# Lowest possible value for local datum types.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#131
RGeo::CoordSys::CS::LD_MIN = T.let(T.unsafe(nil), Integer)

# == OGC spec description
#
# Definition of linear units.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#528
class RGeo::CoordSys::CS::LinearUnit < ::RGeo::CoordSys::CS::Unit
  # Returns the number of meters per LinearUnit.
  # Also available as Unit#conversion_factor.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#532
  def meters_per_unit; end

  class << self
    # Create a LinearUnit given a unit name and a conversion factor
    # in meters per unit. You may also provide the optional
    # parameters specified by the Info interface.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#541
    def create(name, meters_per_unit, *optional); end
  end
end

# == OGC spec description
#
# A local coordinate system, with uncertain relationship to the
# world. In general, a local coordinate system cannot be related to
# other coordinate systems. However, if two objects supporting this
# interface have the same dimension, axes, units and datum then
# client code is permitted to assume that the two coordinate systems
# are identical. This allows several datasets from a common source
# (e.g. a CAD system) to be overlaid. In addition, some
# implementations of the Coordinate Transformation (CT) package may
# have a mechanism for correlating local datums. (E.g. from a
# database of transformations, which is created and maintained from
# real-world measurements.)
#
# == Notes
#
# RGeo's implementation does not provide the Coordinate
# Transformation (CT) package.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1053
class RGeo::CoordSys::CS::LocalCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  # @return [LocalCoordinateSystem] a new instance of LocalCoordinateSystem
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1054
  def initialize(name, local_datum, unit, axes, *optional); end

  # Implements CoordinateSystem#get_axis
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1066
  def get_axis(index); end

  # Implements CoordinateSystem#get_units
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1072
  def get_units(_index); end

  # Gets the local datum.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1062
  def local_datum; end

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1076
  def wkt_typename; end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1093
  def wkt_content(standard_brackets); end

  class << self
    # Create a LocalCoordinateSystem given a name, a LocalDatum, a
    # Unit, and an array of at least one AxisInfo. You may also
    # provide the optional parameters specified by the Info
    # interface.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1086
    def create(name, local_datum, unit, axes, *optional); end
  end
end

# == OGC spec description
#
# Local datum. If two local datum objects have the same datum type
# and name, then they can be considered equal. This means that
# coordinates can be transformed between two different local
# coordinate systems, as long as they are based on the same local
# datum.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#766
class RGeo::CoordSys::CS::LocalDatum < ::RGeo::CoordSys::CS::Datum
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#767
  def wkt_typename; end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#783
  def wkt_content(_); end

  class << self
    # Create a LocalDatum given a name and a datum type code. You
    # may also provide the optional parameters specified by the
    # Info interface.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#776
    def create(name, datum_type, *optional); end
  end
end

# == OGC spec description
#
# A meridian used to take longitude measurements from.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#572
class RGeo::CoordSys::CS::PrimeMeridian < ::RGeo::CoordSys::CS::Info
  # @return [PrimeMeridian] a new instance of PrimeMeridian
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#573
  def initialize(name, angular_unit, longitude, *optional); end

  # Returns the AngularUnits.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#580
  def angular_unit; end

  # Returns the longitude value relative to the Greenwich Meridian.
  # The longitude is expressed in this objects angular units.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#584
  def longitude; end

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#586
  def wkt_typename; end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#603
  def wkt_content(_); end

  class << self
    # Create a PrimeMeridian given a name, AngularUnits, and the
    # longitude relative to the Greenwich Meridian, expressed in
    # the AngularUnits. You may also provide the optional parameters
    # specified by the Info interface.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#596
    def create(name, angular_unit, longitude, *optional); end
  end
end

# == OGC spec description
#
# A 2D cartographic coordinate system.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1344
class RGeo::CoordSys::CS::ProjectedCoordinateSystem < ::RGeo::CoordSys::CS::HorizontalCoordinateSystem
  # @return [ProjectedCoordinateSystem] a new instance of ProjectedCoordinateSystem
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1345
  def initialize(name, geographic_coordinate_system, projection, linear_unit, axis0, axis1, *optional); end

  # Returns the GeographicCoordinateSystem.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1355
  def geographic_coordinate_system; end

  # Implements CoordinateSystem#get_axis
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1372
  def get_axis(index); end

  # Implements CoordinateSystem#get_units
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1366
  def get_units(_index); end

  # Returns the LinearUnits. The linear unit must be the same as
  # the CS_CoordinateSystem units.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1362
  def linear_unit; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1376
  def projected?; end

  # Gets the projection.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1358
  def projection; end

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1380
  def wkt_typename; end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1398
  def wkt_content(standard_brackets); end

  class << self
    # Create a ProjectedCoordinateSystem given a name, a
    # GeographicCoordinateSystem, and Projection, a LinearUnit, and
    # two AxisInfo objects. The AxisInfo objects are optional and
    # may be set to nil. You may also provide the optional
    # parameters specified by the Info interface.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1391
    def create(name, geographic_coordinate_system, projection, linear_unit, axis0, axis1, *optional); end
  end
end

# == OGC spec description
#
# A projection from geographic coordinates to projected coordinates.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#833
class RGeo::CoordSys::CS::Projection < ::RGeo::CoordSys::CS::Info
  # @return [Projection] a new instance of Projection
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#834
  def initialize(name, class_name, parameters, *optional); end

  # Gets the projection classification name
  # (e.g. "Transverse_Mercator").
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#842
  def class_name; end

  # Iterates over the parameters of the projection.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#858
  def each_parameter(&block); end

  # Gets an inexed parameter of the projection.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#852
  def get_parameter(index); end

  # Gets number of parameters of the projection.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#846
  def num_parameters; end

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#862
  def wkt_typename; end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#878
  def wkt_content(_); end

  class << self
    # Create a Projection given a name, a projection class, and an
    # array of ProjectionParameter. You may also provide the
    # optional parameters specified by the Info interface.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#871
    def create(name, class_name, parameters, *optional); end
  end
end

# == OGC spec description
#
# A named projection parameter value. The linear units of
# parameters' values match the linear units of the containing
# projected coordinate system. The angular units of parameter
# values match the angular units of the geographic coordinate
# system that the projected coordinate system is based on.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#304
class RGeo::CoordSys::CS::ProjectionParameter < ::RGeo::CoordSys::CS::Base
  # @return [ProjectionParameter] a new instance of ProjectionParameter
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#305
  def initialize(name, value); end

  # The parameter name.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#312
  def name; end

  # The parameter value.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#315
  def value; end

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#317
  def wkt_typename; end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#331
  def wkt_content(_); end

  class << self
    # Create a parameter given the name and value.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#324
    def create(name, value); end
  end
end

# == OGC spec description
#
# Base interface for defining units.
#
# == Notes
#
# Normally, you will instantiate one of the subclasses LinearUnit or
# AngularUnit. However, it is possible to instantiate Unit if it is
# not clear whether the data refers to a LinearUnit or AngularUnit.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#492
class RGeo::CoordSys::CS::Unit < ::RGeo::CoordSys::CS::Info
  # @return [Unit] a new instance of Unit
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#493
  def initialize(name, conversion_factor, *optional); end

  # This field is not part of the OGC CT spec, but is part of the
  # SFS. It is an alias of the appropriate field in the subclass,
  # i.e. LinearUnit#meters_per_unit or AngularUnit#radians_per_unit.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#501
  def conversion_factor; end

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#503
  def wkt_typename; end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#520
  def wkt_content(_); end

  class << self
    # Create a bare Unit that does not specify whether it is a
    # LinearUnit or an AngularUnit, given a unit name and a
    # conversion factor. You may also provide the optional
    # parameters specified by the Info interface.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#513
    def create(name, conversion_factor, *optional); end
  end
end

# A datum type constant for VerticalDatum.
# The vertical datum of altitudes or heights in the atmosphere.
# These are approximations of orthometric heights obtained with the
# help of a barometer or a barometric altimeter. These values are
# usually expressed in one of the following units: meters, feet,
# millibars (used to measure pressure levels), or theta value (units
# used to measure geopotential height).
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#102
RGeo::CoordSys::CS::VD_ALTITUDE_BAROMETRIC = T.let(T.unsafe(nil), Integer)

# A datum type constant for VerticalDatum.
# This attribute is used to support the set of datums generated for
# hydrographic engineering projects where depth measurements below
# sea level are needed. It is often called a hydrographic or a
# marine datum. Depths are measured in the direction perpendicular
# (approximately) to the actual equipotential surfaces of the
# earth's gravity field, using such procedures as echo-sounding.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#123
RGeo::CoordSys::CS::VD_DEPTH = T.let(T.unsafe(nil), Integer)

# A datum type constant for VerticalDatum.
# A vertical datum for ellipsoidal heights that are measured along
# the normal to the ellipsoid used in the definition of horizontal
# datum.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#93
RGeo::CoordSys::CS::VD_ELLIPSOIDAL = T.let(T.unsafe(nil), Integer)

# A datum type constant for VerticalDatum.
# A vertical datum of geoid model derived heights, also called
# GPS-derived heights. These heights are approximations of
# orthometric heights (H), constructed from the ellipsoidal heights
# (h) by the use of the given geoid undulation model (N) through
# the equation: H=h-N.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#114
RGeo::CoordSys::CS::VD_GEOID_MODE_DERIVED = T.let(T.unsafe(nil), Integer)

# A datum type constant for VerticalDatum.
# Highest possible value for vertical datum types.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#127
RGeo::CoordSys::CS::VD_MAX = T.let(T.unsafe(nil), Integer)

# A datum type constant for VerticalDatum.
# Lowest possible value for vertical datum types.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#78
RGeo::CoordSys::CS::VD_MIN = T.let(T.unsafe(nil), Integer)

# A datum type constant for VerticalDatum.
# A normal height system.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#106
RGeo::CoordSys::CS::VD_NORMAL = T.let(T.unsafe(nil), Integer)

# A datum type constant for VerticalDatum.
# A vertical datum for orthometric heights that are measured along
# the plumb line.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#87
RGeo::CoordSys::CS::VD_ORTHOMETRIC = T.let(T.unsafe(nil), Integer)

# A datum type constant for VerticalDatum.
# Unspecified vertical datum type.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#82
RGeo::CoordSys::CS::VD_OTHER = T.let(T.unsafe(nil), Integer)

# == OGC spec description
#
# A one-dimensional coordinate system suitable for vertical
# measurements.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1183
class RGeo::CoordSys::CS::VerticalCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  # @return [VerticalCoordinateSystem] a new instance of VerticalCoordinateSystem
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1184
  def initialize(name, vertical_datum, vertical_unit, axis, *optional); end

  # Implements CoordinateSystem#get_axis
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1206
  def get_axis(_index); end

  # Implements CoordinateSystem#get_units
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1200
  def get_units(_index); end

  # Gets the vertical datum, which indicates the measurement method.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1192
  def vertical_datum; end

  # Gets the units used along the vertical axis. The vertical units
  # must be the same as the CS_CoordinateSystem units.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1196
  def vertical_unit; end

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1210
  def wkt_typename; end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1227
  def wkt_content(standard_brackets); end

  class << self
    # Create a VerticalCoordinateSystem given a name, a
    # VerticalDatum, a LinearUnit, and an AxisInfo. The AxisInfo is
    # optional and may be nil. You may also provide the optional
    # parameters specified by the Info interface.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#1220
    def create(name, vertical_datum, vertical_unit, axis, *optional); end
  end
end

# == OGC spec description
#
# Procedure used to measure vertical distances.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#737
class RGeo::CoordSys::CS::VerticalDatum < ::RGeo::CoordSys::CS::Datum
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#738
  def wkt_typename; end

  private

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#754
  def wkt_content(_); end

  class << self
    # Create a VerticalDatum given a name and a datum type code.
    # You may also provide the optional parameters specified by the
    # Info interface.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#747
    def create(name, datum_type, *optional); end
  end
end

# == OGC spec description
#
# Parameters for a geographic transformation into WGS84. The Bursa
# Wolf parameters should be applied to geocentric coordinates, where
# the X axis points towards the Greenwich Prime Meridian, the Y axis
# points East, and the Z axis points North.
#
# source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#342
class RGeo::CoordSys::CS::WGS84ConversionInfo < ::RGeo::CoordSys::CS::Base
  # @return [WGS84ConversionInfo] a new instance of WGS84ConversionInfo
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#343
  def initialize(dx_meters, dy_meters, dz_meters, ex_arc_seconds, ey_arc_seconds, ez_arc_seconds, ppm); end

  # Bursa Wolf shift in meters.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#355
  def dx; end

  # Bursa Wolf shift in meters.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#358
  def dy; end

  # Bursa Wolf shift in meters.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#361
  def dz; end

  # Bursa Wolf rotation in arc seconds.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#364
  def ex; end

  # Bursa Wolf rotation in arc seconds.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#367
  def ey; end

  # Bursa Wolf rotation in arc seconds.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#370
  def ez; end

  # Bursa Wolf scaling in in parts per million.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#373
  def ppm; end

  # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#375
  def to_wkt(standard_brackets: T.unsafe(nil)); end

  class << self
    # Create the horizontal datum shift transformation into WGS84,
    # given the seven Bursa Wolf parameters.
    # The Bursa Wolf shift should be in meters, the rotation in arc
    # seconds, and the scaling in parts per million.
    #
    # source://rgeo//lib/rgeo/coord_sys/cs/entities.rb#386
    def create(dx_meters, dy_meters, dz_meters, ex_arc_seconds, ey_arc_seconds, ez_arc_seconds, ppm); end
  end
end

# source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#12
class RGeo::CoordSys::CS::WKTParser
  # @return [WKTParser] a new instance of WKTParser
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#13
  def initialize(str); end

  # source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#189
  def consume_tokentype(type); end

  # Returns the value of attribute cur_token.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#235
  def cur_token; end

  # @raise [Error::ParseError]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#196
  def expect_tokentype(type); end

  # source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#202
  def next_token; end

  # source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#18
  def parse(containing_type = T.unsafe(nil)); end
end

# source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#263
class RGeo::CoordSys::CS::WKTParser::ArgumentList
  # @return [ArgumentList] a new instance of ArgumentList
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#264
  def initialize; end

  # source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#268
  def <<(value); end

  # @raise [Error::ParseError]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#272
  def assert_empty; end

  # source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#306
  def create_optionals; end

  # source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#292
  def find_all(klass); end

  # source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#282
  def find_first(klass); end

  # @raise [Error::ParseError]
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#312
  def shift(klass = T.unsafe(nil)); end
end

# source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#243
class RGeo::CoordSys::CS::WKTParser::AuthorityClause
  # @return [AuthorityClause] a new instance of AuthorityClause
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#244
  def initialize(name, code); end

  # source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#249
  def to_a; end
end

# source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#254
class RGeo::CoordSys::CS::WKTParser::ExtensionClause
  # @return [ExtensionClause] a new instance of ExtensionClause
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#257
  def initialize(key, value); end

  # Returns the value of attribute key.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#255
  def key; end

  # Returns the value of attribute value.
  #
  # source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#255
  def value; end
end

# source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#237
class RGeo::CoordSys::CS::WKTParser::QuotedString < ::String; end

# source://rgeo//lib/rgeo/coord_sys/cs/wkt_parser.rb#240
class RGeo::CoordSys::CS::WKTParser::TypeString < ::String; end

# All RGeo errors are members of this namespace.
#
# source://rgeo//lib/rgeo/error.rb#12
module RGeo::Error; end

# source://rgeo//lib/rgeo/error.rb#39
RGeo::Error::DISCONNECTED_INTERIOR = T.let(T.unsafe(nil), String)

# source://rgeo//lib/rgeo/error.rb#43
RGeo::Error::DUPLICATE_RINGS = T.let(T.unsafe(nil), String)

# RGeo error specific to the GEOS implementation.
#
# source://rgeo//lib/rgeo/error.rb#18
class RGeo::Error::GeosError < ::RGeo::Error::RGeoError; end

# source://rgeo//lib/rgeo/error.rb#37
RGeo::Error::HOLE_OUTSIDE_SHELL = T.let(T.unsafe(nil), String)

# source://rgeo//lib/rgeo/error.rb#45
RGeo::Error::INVALID_COORDINATE = T.let(T.unsafe(nil), String)

# The specified geometry is invalid
#
# source://rgeo//lib/rgeo/error.rb#22
class RGeo::Error::InvalidGeometry < ::RGeo::Error::RGeoError; end

# source://rgeo//lib/rgeo/error.rb#38
RGeo::Error::NESTED_HOLES = T.let(T.unsafe(nil), String)

# source://rgeo//lib/rgeo/error.rb#42
RGeo::Error::NESTED_SHELLS = T.let(T.unsafe(nil), String)

# Parsing failed
#
# source://rgeo//lib/rgeo/error.rb#30
class RGeo::Error::ParseError < ::RGeo::Error::RGeoError; end

# source://rgeo//lib/rgeo/error.rb#36
RGeo::Error::REPEATED_POINT = T.let(T.unsafe(nil), String)

# Base class for all RGeo-related exceptions
#
# source://rgeo//lib/rgeo/error.rb#14
class RGeo::Error::RGeoError < ::RuntimeError; end

# source://rgeo//lib/rgeo/error.rb#41
RGeo::Error::RING_SELF_INTERSECTION = T.let(T.unsafe(nil), String)

# source://rgeo//lib/rgeo/error.rb#40
RGeo::Error::SELF_INTERSECTION = T.let(T.unsafe(nil), String)

# source://rgeo//lib/rgeo/error.rb#44
RGeo::Error::TOO_FEW_POINTS = T.let(T.unsafe(nil), String)

# Standard error messages from
# https://github.com/locationtech/jts/blob/0afbfb1956ec24912a8b4dc4edff0f1200442857/modules/core/src/main/java/org/locationtech/jts/operation/valid/TopologyValidationError.java#L98-L110
#
# source://rgeo//lib/rgeo/error.rb#35
RGeo::Error::TOPOLOGY_VALIDATION_ERR = T.let(T.unsafe(nil), String)

# source://rgeo//lib/rgeo/error.rb#46
RGeo::Error::UNCLOSED_RING = T.let(T.unsafe(nil), String)

# The specified operation is not supported or not implemented
#
# source://rgeo//lib/rgeo/error.rb#26
class RGeo::Error::UnsupportedOperation < ::RGeo::Error::RGeoError; end

# source://rgeo//lib/rgeo/feature/factory.rb#10
module RGeo::Feature
  class << self
    # Cast the given object according to the given parameters, if
    # possible, and return the resulting object. If the requested cast
    # is not possible, nil is returned.
    #
    # Parameters may be provided as a hash, or as separate arguments.
    # Hash keys are as follows:
    #
    # [<tt>:factory</tt>]
    #   Set the factory to the given factory. If this argument is not
    #   given, the original object's factory is kept.
    # [<tt>:type</tt>]
    #   Cast to the given type, which must be a module in the
    #   RGeo::Feature namespace. If this argument is not given, the
    #   result keeps the same type as the original.
    # [<tt>:project</tt>]
    #   If this is set to true, and both the original and new factories
    #   support proj4 projections, then the cast will also cause the
    #   coordinates to be transformed between those two projections.
    #   If set to false, the coordinates are not modified. Default is
    #   false.
    # [<tt>:keep_subtype</tt>]
    #   Value must be a boolean indicating whether to keep the subtype
    #   of the original. If set to false, casting to a particular type
    #   always casts strictly to that type, even if the old type is a
    #   subtype of the new type. If set to true, the cast retains the
    #   subtype in that case. For example, casting a LinearRing to a
    #   LineString will normally yield a LineString, even though
    #   LinearRing is already a more specific subtype. If you set this
    #   value to true, the casted object will remain a LinearRing.
    #   Default is false.
    # [<tt>:force_new</tt>]
    #   Always return a newly-created object, even if neither the type
    #   nor factory is modified. Normally, if this is set to false, and
    #   a cast is not set to modify either the factory or type, the
    #   original object itself is returned. Setting this flag to true
    #   causes cast to return a clone in that case. Default is false.
    #
    # You may also pass the new factory, the new type, and the flags
    # as separate arguments. In this case, the flag names must be
    # passed as symbols, and their effect is the same as setting their
    # values to true. You can even combine separate arguments and hash
    # arguments. For example, the following three calls are equivalent:
    #
    #  RGeo::Feature.cast(geom, :type => RGeo::Feature::Point, :project => true)
    #  RGeo::Feature.cast(geom, RGeo::Feature::Point, :project => true)
    #  RGeo::Feature.cast(geom, RGeo::Feature::Point, :project)
    #
    # RGeo provides a default casting algorithm. Individual feature
    # implementation factories may override this and customize the
    # casting behavior by defining the override_cast method. See
    # RGeo::Feature::Factory#override_cast for more details.
    #
    # source://rgeo-geojson/2.2.0/lib/rgeo/geo_json/entities.rb#12
    def cast(obj, *params); end
  end
end

# == SFS 1.1 Description
#
# A Curve is a 1-dimensional geometric object usually stored as a
# sequence of Points, with the subtype of Curve specifying the form of
# the interpolation between Points. This part of ISO 19125 defines only
# one subclass of Curve, LineString, which uses linear interpolation
# between Points.
#
# A Curve is a 1-dimensional geometric object that is the homeomorphic
# image of a real, closed interval D=[a,b] under a mapping f:[a,b]->R2.
#
# A Curve is simple if it does not pass through the same Point twice.
#
# A Curve is closed if its start Point is equal to its end Point.
#
# The boundary of a closed Curve is empty.
#
# A Curve that is simple and closed is a Ring.
#
# The boundary of a non-closed Curve consists of its two end Points.
#
# A Curve is defined as topologically closed.
#
# == Notes
#
# Curve is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
#
# Some implementations may support higher dimensional points.
#
# source://rgeo//lib/rgeo/feature/curve.rb#43
module RGeo::Feature::Curve
  include ::RGeo::Feature::Geometry
  extend ::RGeo::Feature::Type

  # === SFS 1.1 Description
  #
  # Returns true if this Curve is closed [StartPoint() = EndPoint()].
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/curve.rb#92
  def closed?; end

  # === SFS 1.1 Description
  #
  # The end Point of this Curve.
  #
  # === Notes
  #
  # Returns an object that supports the Point interface.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/curve.rb#79
  def end_point; end

  # === SFS 1.1 Description
  #
  # The length of this Curve in its associated spatial reference.
  #
  # === Notes
  #
  # Returns a floating-point scalar value.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/curve.rb#55
  def length; end

  # === SFS 1.1 Description
  #
  # Returns true if this Curve is closed [StartPoint() = EndPoint()]
  # and this Curve is simple (does not pass through the same Point
  # more than once).
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/curve.rb#107
  def ring?; end

  # === SFS 1.1 Description
  #
  # The start Point of this Curve.
  #
  # === Notes
  #
  # Returns an object that supports the Point interface.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/curve.rb#67
  def start_point; end
end

# This is a standard interface for factories of features.
# Generally, each Feature implementation will implement these
# methods as a standard way to create features.
#
# If the implementation is unable to create the given feature,
# it should generally return nil. Implementations may also choose to
# raise an exception on failure.
#
# Some implementations may extend this interface to provide facilities
# for creating additional objects according to the capabilities
# provided by that implementation. Examples might include
# higher-dimensional coordinates or additional subclasses not
# explicitly required by the Simple Features Specification.
#
# Factory is defined as a module and is provided primarily for the
# sake of documentation. Implementations need not necessarily include
# this module itself. Therefore, you should not depend on the result
# of <tt>is_a?(Factory)</tt> to check type. However, to support
# testing for factory-ness, the <tt>Factory::Instance</tt> submodule
# is provided. All factory implementation classes MUST include
# <tt>Factory::Instance</tt>, and you may use it in <tt>is_a?</tt>,
# <tt>===</tt>, and case-when constructs.
#
# source://rgeo//lib/rgeo/feature/factory.rb#33
module RGeo::Feature::Factory
  # Create a feature of type GeometryCollection.
  # The elems should be an Enumerable of Geometry objects.
  #
  # Although implementations are free to attempt to handle input
  # objects that are not of this factory, strictly speaking, the
  # result of building geometries from objects of the wrong factory
  # is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/factory.rb#170
  def collection(_elems); end

  # Returns the coordinate system specification for the features
  # created by this factory, or nil if there is no such coordinate
  # system.
  #
  # NOTE: This is a required method of the factory interface, but the
  # coordinate system classes themselves are not yet available, so
  # implementations should just return nil for now.
  #
  # source://rgeo//lib/rgeo/feature/factory.rb#229
  def coord_sys; end

  # Create a feature of type Line.
  # The given point arguments should be Point objects, or objects
  # that can be cast to Point.
  #
  # Although implementations are free to attempt to handle input
  # objects that are not of this factory, strictly speaking, the
  # result of building geometries from objects of the wrong factory
  # is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/factory.rb#126
  def line(_start, _stop); end

  # Create a feature of type LineString.
  # The given points argument should be an Enumerable of Point
  # objects, or objects that can be cast to Point.
  #
  # Although implementations are free to attempt to handle input
  # objects that are not of this factory, strictly speaking, the
  # result of building geometries from objects of the wrong factory
  # is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/factory.rb#113
  def line_string(_points); end

  # Create a feature of type LinearRing.
  # The given points argument should be an Enumerable of Point
  # objects, or objects that can be cast to Point.
  # If the first and last points are not equal, the ring is
  # automatically closed by appending the first point to the end of the
  # string.
  #
  # Although implementations are free to attempt to handle input
  # objects that are not of this factory, strictly speaking, the
  # result of building geometries from objects of the wrong factory
  # is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/factory.rb#142
  def linear_ring(_points); end

  # Create a feature of type MultiLineString.
  # The elems should be an Enumerable of objects that are or can be
  # cast to LineString or any of its subclasses.
  # Returns nil if any of the contained geometries is not a
  # LineString, which would break the MultiLineString contract.
  #
  # Although implementations are free to attempt to handle input
  # objects that are not of this factory, strictly speaking, the
  # result of building geometries from objects of the wrong factory
  # is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/factory.rb#200
  def multi_line_string(_elems); end

  # Create a feature of type MultiPoint.
  # The elems should be an Enumerable of Point objects, or objects
  # that can be cast to Point.
  # Returns nil if any of the contained geometries is not a Point,
  # which would break the MultiPoint contract.
  #
  # Although implementations are free to attempt to handle input
  # objects that are not of this factory, strictly speaking, the
  # result of building geometries from objects of the wrong factory
  # is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/factory.rb#185
  def multi_point(_elems); end

  # Create a feature of type MultiPolygon.
  # The elems should be an Enumerable of objects that are or can be
  # cast to Polygon or any of its subclasses.
  # Returns nil if any of the contained geometries is not a Polygon,
  # which would break the MultiPolygon contract.
  # Also returns nil if any of the other assertions for MultiPolygon
  # are not met, e.g. if any of the polygons overlap.
  #
  # Although implementations are free to attempt to handle input
  # objects that are not of this factory, strictly speaking, the
  # result of building geometries from objects of the wrong factory
  # is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/factory.rb#217
  def multi_polygon(_elems); end

  # This is an optional method that may be implemented to customize
  # casting for this factory. Basically, RGeo defines standard ways
  # to cast certain types of objects from one factory to another and
  # one SFS type to another. However, a factory may choose to
  # override how things are casted TO its implementation using this
  # method. It can do this to optimize certain casting cases, or
  # implement special cases particular to this factory.
  #
  # This method will be called (if defined) on the destination
  # factory, and will be passed the original object (which may or may
  # not already be created by this factory), the SFS feature type
  # (which again may or may not already be the type of the original
  # object), and a hash of additional flags. These flags are:
  #
  # [<tt>:keep_subtype</tt>]
  #   indicates whether to keep the subtype if casting to a supertype
  #   of the current type
  # [<tt>:force_new</tt>]
  #   indicates whether to force the creation of a new object even if
  #   the original is already of the desired factory and type
  # [<tt>:project</tt>]
  #   indicates whether to project the coordinates from the source to
  #   the destination coordinate system, if available
  #
  # It should return either a casted result object, false, or nil.
  # A nil return value indicates that casting should be forced to
  # fail (and RGeo::Feature.cast will return nil).
  # A false return value indicates that this method declines to
  # override the casting algorithm, and RGeo should use its default
  # algorithm to cast the object. Therefore, by default, you should
  # return false.
  #
  # source://rgeo//lib/rgeo/feature/factory.rb#265
  def override_cast(_original, _type, _flags); end

  # Parse the given string in well-known-binary format and return the
  # resulting feature. Returns nil if the string couldn't be parsed.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/factory.rb#89
  def parse_wkb(_str); end

  # Parse the given string in well-known-text format and return the
  # resulting feature. Returns nil if the string couldn't be parsed.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/factory.rb#82
  def parse_wkt(_str); end

  # Create a feature of type Point.
  # The x and y parameters should be Float values.
  #
  # The extra parameters should be the Z and/or M coordinates, if
  # supported. If both Z and M coordinates are supported, Z should
  # be passed first.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/factory.rb#100
  def point(_x, _y, *_extra); end

  # Create a feature of type Polygon.
  # The outer_ring should be a LinearRing, or an object that can be
  # cast to LinearRing.
  # The inner_rings should be a possibly empty Enumerable of
  # LinearRing (or objects that can be casted to LinearRing).
  # You may also pass nil to indicate no inner rings.
  #
  # Although implementations are free to attempt to handle input
  # objects that are not of this factory, strictly speaking, the
  # result of building geometries from objects of the wrong factory
  # is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/factory.rb#158
  def polygon(_outer_ring, _inner_rings = T.unsafe(nil)); end

  # Returns meta-information about this factory, by key. This
  # information may involve support for optional functionality,
  # properties of the coordinate system, or other characteristics.
  #
  # Each property has a symbolic name. Names that have no periods are
  # considered well-known names and are reserved for use by RGeo. If
  # you want to define your own properties, use a name that is
  # namespaced with periods, such as <tt>:'mycompany.myprop'</tt>.
  #
  # Property values are dependent on the individual property.
  # Generally, properties that involve testing for functionality
  # should return true if the functionality is support, or false or
  # nil if not. A property value could also invlove different values
  # indicating different levels of support. In any case, the factory
  # should return nil for property names it does not recognize. This
  # value is considered the "default" or "no value" value.
  #
  # Currently defined well-known properties are:
  #
  # [<tt>:has_z_coordinate</tt>]
  #   Set to true if geometries created by this factory include a Z
  #   coordinate, and the Point#z method is available.
  # [<tt>:has_m_coordinate</tt>]
  #   Set to true if geometries created by this factory include a M
  #   coordinate, and the Point#m method is available.
  # [<tt>:is_cartesian</tt>]
  #   Set to true if this Factory guarantees that it operates in
  #   Cartesian geometry. If false or nil, no such guarantee is made,
  #   though it is possible the geometries may still be Cartesian.
  # [<tt>:is_geographic</tt>]
  #   Set to true if this Factory's coordinate system is meant to be
  #   interpreted as x=longitude and y=latitude. If false or nil, no
  #   information is present about whether the coordinate system is
  #   meant to be so interpreted.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/factory.rb#75
  def property(_name); end
end

# All factory implementations MUST include this submodule.
# This serves as a marker that may be used to test an object for
# factory-ness.
#
# source://rgeo//lib/rgeo/feature/factory.rb#37
module RGeo::Feature::Factory::Instance
  # source://rgeo-geojson/2.2.0/lib/rgeo/geo_json/conversion_methods.rb#45
  def parse_geojson(input); end
end

# A FactoryGenerator is a callable object (usually a Proc) that
# takes a configuration as a hash and returns a factory. These are
# often used, e.g., by parsers to determine what factory the parsed
# geometry should have.
#
# See the call method for a list of common configuration parameters.
# Different generators will support different parameters. There is
# no mechanism defined to reflect on the parameters understood by a
# factory generator.
#
# Many of the implementations provide a factory method for creating
# factories. For example, RGeo::Cartesian.preferred_factory can be
# called to create a factory using the preferred Cartesian
# implementation. Thus, to get a corresponding factory generator,
# you can use the <tt>method</tt> method. e.g.
#
#  factory_generator = RGeo::Cartesian.method(:preferred_factory)
#
# FactoryGenerator is defined as a module and is provided
# primarily for the sake of documentation. Implementations need not
# necessarily include this module itself. Therefore, you should not
# depend on the kind_of? method to determine if an object is a
# factory generator.
#
# source://rgeo//lib/rgeo/feature/factory_generator.rb#34
module RGeo::Feature::FactoryGenerator
  # Generate a factory given a configuration as a hash.
  #
  # If the generator does not recognize or does not support a given
  # configuration value, the behavior is usually determined by the
  # <tt>:strict</tt> configuration element. If <tt>strict</tt> is
  # set to true, the generator should fail fast by returning nil or
  # raising an exception. If it is set to false, the generator should
  # attempt to do the best it can, even if it means returning a
  # factory that does not match the requested configuration.
  #
  # Common parameters are as follows. These are intended as a
  # recommendation only. There is no hard requirement for any
  # particular factory generator to support them.
  #
  # [<tt>:strict</tt>]
  #   If true, return nil or raise an exception if any configuration
  #   was not recognized or not supportable. Otherwise, if false,
  #   the generator should attempt to do its best to return some
  #   viable factory, even if it does not strictly match the
  #   requested configuration. Default is usually false.
  # [<tt>:srid</tt>]
  #   The SRID for the factory and objects it creates.
  #   Default is usually 0.
  # [<tt>:coord_sys</tt>]
  #   The coordinate system in OGC form, either as a subclass of
  #   CoordSys::CS::CoordinateSystem, or as a string in WKT format.
  #   Optional. If no coord_sys is given, but an SRID is the factory
  #   will try to create one using the CoordSys::CONFIG.default_coord_sys_class
  #   or the given :coord_sys_class option. The option is usually nil.
  # [<tt>:has_z_coordinate</tt>]
  #   Support Z coordinates. Default is usually false.
  # [<tt>:has_m_coordinate</tt>]
  #   Support M coordinates. Default is usually false.
  #
  # source://rgeo//lib/rgeo/feature/factory_generator.rb#69
  def call(_config = T.unsafe(nil)); end

  class << self
    # Return a new FactoryGenerator that calls the given delegate, but
    # modifies the configuration passed to it. You can provide defaults
    # for configuration values not explicitly specified, and you can
    # force certain values to override the given configuration.
    #
    # source://rgeo//lib/rgeo/feature/factory_generator.rb#85
    def decorate(delegate, default_config = T.unsafe(nil), force_config = T.unsafe(nil)); end

    # Return a new FactoryGenerator that always returns the given
    # factory.
    #
    # source://rgeo//lib/rgeo/feature/factory_generator.rb#76
    def single(factory); end
  end
end

# == SFS 1.1 Description
#
# Geometry is the root class of the hierarchy. Geometry is an abstract
# (non-instantiable) class.
#
# The instantiable subclasses of Geometry defined in this International
# Standard are restricted to 0, 1 and 2-dimensional geometric objects
# that exist in 2-dimensional coordinate space (R2).
#
# All instantiable Geometry classes described in this part of ISO 19125
# are defined so that valid instances of a Geometry class are
# topologically closed, i.e. all defined geometries include their
# boundary.
#
# == Notes
#
# Geometry is defined as a module and is provided primarily for the
# sake of documentation. Implementations need not necessarily include
# this module itself. Therefore, you should not depend on the result
# of <tt>is_a?(Geometry)</tt> to check type. Instead, use the
# provided check_type class method (or === operator) defined in the
# Type module.
#
# Some implementations may support higher dimensional objects or
# coordinate systems, despite the limits of the SFS.
#
# == Forms of equivalence
#
# The Geometry model defines three forms of equivalence.
#
# * <b>Spatial equivalence</b> is the weakest form of equivalence,
#   indicating that the objects represent the same region of space,
#   but may be different representations of that region. For example,
#   POINT(0 0) and a MULTIPOINT(0 0) are spatially equivalent, as are
#   LINESTRING(0 0, 10 10) and
#   GEOMETRYCOLLECTION(POINT(0 0), LINESTRING(0 0, 10 10, 0 0)).
#   As a general rule, objects must have factories that are
#   Factory#eql? in order to be spatially equivalent.
#
# * <b>Representational equivalence</b> is a stronger form, indicating
#   that the objects have the same representation, but may be
#   different objects. All representationally equivalent objects are
#   spatially equivalent, but not all spatially equivalent objects are
#   representationally equivalent. For example, none of the examples
#   in the spatial equivalence section above are representationally
#   equivalent. However, two separate objects that both represent
#   POINT(1 2) are representationally equivalent as well as spatially
#   equivalent.
#
# * <b>Objective equivalence</b> is the strongest form, indicating
#   that the references refer to the same object. Of course, all
#   pairs of references with the same objective identity are also
#   both representationally and spatially equivalent.
#
# Different methods test for different types of equivalence:
#
# * <tt>equals?</tt> and <tt>==</tt> test for spatial equivalence.
# * <tt>rep_equals?</tt> and <tt>eql?</tt> test for representational
#   equivalence.
# * <tt>equal?</tt> tests for objective equivalence.
#
# All ruby objects must provide a suitable test for objective
# equivalence. Normally, this is simply provided by the Ruby Object
# base class. Geometry implementations should normally also provide
# tests for representational and spatial equivalence, if possible.
# The <tt>==</tt> operator and the <tt>eql?</tt> method are standard
# Ruby methods that are often expected to be usable for every object.
# Therefore, if an implementation cannot provide a suitable test for
# their equivalence types, they must degrade to use a stronger form
# of equivalence.
#
# source://rgeo//lib/rgeo/feature/geometry.rb#81
module RGeo::Feature::Geometry
  extend ::RGeo::Feature::Type

  # If the given rhs is a geometry object, this operator must behave
  # the same as the intersection method. The behavior for other rhs
  # types is not specified; an implementation may choose to provide
  # additional capabilities as appropriate.
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def *(other); end

  # If the given rhs is a geometry object, this operator must behave
  # the same as the union method. The behavior for other rhs types
  # is not specified; an implementation may choose to provide
  # additional capabilities as appropriate.
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def +(other); end

  # If the given rhs is a geometry object, this operator must behave
  # the same as the difference method. The behavior for other rhs
  # types is not specified; an implementation may choose to provide
  # additional capabilities as appropriate.
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def -(other); end

  # This operator should behave almost the same as the equals? method,
  # with two key differences.
  #
  # First, the == operator is required to handle rhs values that are
  # not geometry objects (returning false in such cases) in order to
  # fulfill the standard Ruby contract for the == operator, whereas
  # the equals? method may assume that any rhs is a geometry.
  #
  # Second, the == operator should always be defined. That is, it
  # should never raise Error::UnsupportedOperation. In cases where
  # the underlying implementation cannot provide a spatial equivalence
  # test, the == operator must fall back on representational or
  # objective equivalence.
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#675
  def ==(other); end

  # === SFS 1.1 Description
  #
  # Exports this geometric object to a specific Well-known Binary
  # Representation of Geometry.
  #
  # === Notes
  #
  # Returns a binary string.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#208
  def as_binary; end

  # === SFS 1.1 Description
  #
  # Exports this geometric object to a specific Well-known Text
  # Representation of Geometry.
  #
  # === Notes
  #
  # Returns an ASCII string.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#195
  def as_text; end

  # === SFS 1.1 Description
  #
  # Returns the closure of the combinatorial boundary of this geometric
  # object. Because the result of this function is a closure, and hence
  # topologically closed, the resulting boundary can be represented using
  # representational Geometry primitives.
  #
  # === Notes
  #
  # Returns an object that supports the Geometry interface.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#277
  def boundary; end

  # === SFS 1.1 Description
  #
  # Returns a geometric object that represents all Points whose distance
  # from this geometric object is less than or equal to distance.
  # Calculations are in the spatial reference system of this geometric
  # object.
  #
  # === Notes
  #
  # Returns an object that supports the Geometry interface.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#516
  def buffer(_distance_); end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object "spatially contains"
  # another_geometry.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#410
  def contains?(_another_geometry); end

  # === SFS 1.1 Description
  #
  # Returns a geometric object that represents the convex hull of this
  # geometric object.
  #
  # === Notes
  #
  # Returns an object that supports the Geometry interface.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#529
  def convex_hull; end

  # === SFS 1.2 Description
  #
  # The coordinate dimension is the dimension of direct positions (coordinate tuples) used in
  # the definition of this geometric object
  #
  # === Notes
  #
  # Difference between this and dimension is that this is the dimension of the coordinate
  # not the dimension of the geometry.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Integer]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#121
  def coordinate_dimension; end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object "spatially crosses"
  # another_geometry.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#372
  def crosses?(_another_geometry); end

  # === SFS 1.1 Description
  #
  # Returns a geometric object that represents the Point set
  # difference of this geometric object with another_geometry.
  #
  # === Notes
  #
  # Returns an object that supports the Geometry interface.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of performing
  # operations on objects from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def difference(_another_geometry); end

  # === SFS 1.1 Description
  #
  # The inherent dimension of this geometric object, which must be less
  # than or equal to the coordinate dimension. This specification is
  # restricted to geometries in 2-dimensional coordinate space.
  #
  # === Notes
  #
  # Returns an integer. This value is -1 for an empty geometry, 0 for
  # point geometries, 1 for curves, and 2 for surfaces.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#106
  def dimension; end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object is "spatially disjoint" from
  # another_geometry.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def disjoint?(_another_geometry); end

  # === SFS 1.1 Description
  #
  # Returns the shortest distance between any two Points in the two
  # geometric objects as calculated in the spatial reference system of
  # this geometric object.
  #
  # === Notes
  #
  # Returns a floating-point scalar value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of measuring the
  # distance between objects from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#501
  def distance(_another_geometry); end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object is the empty Geometry. If true,
  # then this geometric object represents the empty point set for the
  # coordinate space.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#223
  def empty?; end

  # === SFS 1.1 Description
  #
  # The minimum bounding box for this Geometry, returned as a Geometry.
  # The polygon is defined by the corner points of the bounding box
  # [(MINX, MINY), (MAXX, MINY), (MAXX, MAXY), (MINX, MAXY), (MINX, MINY)].
  #
  # === Notes
  #
  # Returns an object that supports the Geometry interface.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#182
  def envelope; end

  # This method should behave almost the same as the rep_equals?
  # method, with two key differences.
  #
  # First, the <tt>eql?</tt> method is required to handle rhs values
  # that are not geometry objects (returning false in such cases) in
  # order to fulfill the standard Ruby contract for the method,
  # whereas the rep_equals? method may assume that any rhs is a
  # geometry.
  #
  # Second, the <tt>eql?</tt> method should always be defined. That
  # is, it should never raise Error::UnsupportedOperation. In cases
  # where the underlying implementation cannot provide a
  # representational equivalence test, this method must fall back on
  # objective equivalence.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#649
  def eql?(other); end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object is "spatially equal" to
  # another_geometry.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#296
  def equals?(_another_geometry); end

  # Returns a factory for creating features related to this one.
  # This does not necessarily need to be the same factory that created
  # this object, but it should create objects that are "compatible"
  # with this one. (i.e. they should be in the same spatial reference
  # system by default, and it should be possible to perform relational
  # operations on them.)
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#91
  def factory; end

  # === SFS 1.1 Description
  #
  # Returns the instantiable subtype of Geometry of which this
  # geometric object is an instantiable member.
  #
  # === Notes
  #
  # Returns one of the type modules in RGeo::Feature. e.g. a point
  # object would return RGeo::Feature::Point. Note that this is
  # different from the SFS specification, which stipulates that the
  # string name of the type is returned. To obtain the name string,
  # call the +type_name+ method of the returned module.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#153
  def geometry_type; end

  # === SFS 1.1 Description
  #
  # Returns a geometric object that represents the Point set
  # intersection of this geometric object with another_geometry.
  #
  # === Notes
  #
  # Returns an object that supports the Geometry interface.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of performing
  # operations on objects from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def intersection(_another_geometry); end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object "spatially intersects"
  # another_geometry.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#334
  def intersects?(_another_geometry); end

  # === SFS 1.2 Description
  #
  # Returns 1 (TRUE) if this geometric object has z coordinate values.
  #
  # === Notes
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#251
  def is_3d?; end

  # === SFS 1.2 Description
  #
  # Returns a derived geometry collection value that matches the
  # specified m coordinate value.
  #
  # === Notes
  #
  # @param m_value [Float] value to find matches for
  # @raise [Error::UnsupportedOperation]
  # @return [RGeo::Feature::GeometryCollection]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#468
  def locate_along; end

  # === SFS 1.2 Description
  #
  # Returns a derived geometry collection value
  # that matches the specified range of m coordinate values inclusively
  #
  # === Notes
  #
  # @param m_start [Float] lower bound of value range
  # @param m_end [Float] upper bound of value range
  # @raise [Error::UnsupportedOperation]
  # @return [RGeo::Feature::GeometryCollection]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#482
  def locate_between; end

  # === SFS 1.2 Description
  #
  # Returns 1 (TRUE) if this geometric object has m coordinate values.
  #
  # === Notes
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#262
  def measured?; end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object "spatially overlaps"
  # another_geometry.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def overlaps?(_another_geometry); end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object is spatially related to
  # another_geometry by testing for intersections between the interior,
  # boundary and exterior of the two geometric objects as specified by
  # the values in the intersection_pattern_matrix.
  #
  # === Notes
  #
  # The intersection_pattern_matrix is provided as a nine-character
  # string in row-major order, representing the dimensionalities of
  # the different intersections in the DE-9IM. Supported characters
  # include T, F, *, 0, 1, and 2.
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def relate?(_another_geometry, _intersection_pattern_matrix_); end

  # Returns true if this geometric object is representationally
  # equivalent to the given object.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#613
  def rep_equals?(_another_geometry); end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object has no anomalous geometric
  # points, such as self intersection or self tangency. The description
  # of each instantiable geometric class will include the specific
  # conditions that cause an instance of that class to be classified as
  # not simple.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#240
  def simple?; end

  # === SFS 1.2 Description
  #
  # The spatial dimension is the dimension of the spatial portion of the direct positions
  # (coordinate tuples) used in the definition of this geometric object. If the direct positions
  # do not carry a measure coordinate, this will be equal to the coordinate dimension.
  #
  # === Notes
  #
  # Similar to coordinate_dimension except it will ignore the M component always.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Integer]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#136
  def spatial_dimension; end

  # === SFS 1.1 Description
  #
  # Returns the Spatial Reference System ID for this geometric object.
  #
  # === Notes
  #
  # Returns an integer.
  #
  # This will normally be a foreign key to an index of reference systems
  # stored in either the same or some other datastore.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#168
  def srid; end

  # === SFS 1.1 Description
  #
  # Returns a geometric object that represents the Point set symmetric
  # difference of this geometric object with another_geometry.
  #
  # === Notes
  #
  # Returns an object that supports the Geometry interface.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of performing
  # operations on objects from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def sym_difference(_another_geometry); end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object "spatially touches"
  # another_geometry.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def touches?(_another_geometry); end

  # Convenience method to transform/project a geometry
  # to a different coordinate system from the geometry itself
  # instead of the cast method.
  #
  # @note: Not an OGC SFS method
  #
  # @param other_factory [RGeo::Feature::Factory]
  # @return [RGeo::Feature::Geometry]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def transform(other_factory); end

  # Unions a collection of Geometry or a single Geometry
  # (which may be a collection) together. By using this
  # special-purpose operation over a collection of geometries
  # it is possible to take advantage of various optimizations
  # to improve performance. Heterogeneous GeometryCollections
  # are fully supported.
  #
  # This is not a standard SFS method, but when it is available
  # in GEOS, it is a very performant way to union all the
  # geometries in a collection. GEOS version 3.3 or greater
  # is required. If the feature is not available, unary_union
  # returns nil.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unary_union; end

  # === SFS 1.1 Description
  #
  # Returns a geometric object that represents the Point set
  # union of this geometric object with another_geometry.
  #
  # === Notes
  #
  # Returns an object that supports the Geometry interface.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of performing
  # operations on objects from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def union(_another_geometry); end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object is "spatially within"
  # another_geometry.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def within?(_another_geometry); end
end

# == SFS 1.1 Description
#
# A GeometryCollection is a geometric object that is a collection of 1
# or more geometric objects.
#
# All the elements in a GeometryCollection shall be in the same Spatial
# Reference. This is also the Spatial Reference for the GeometryCollection.
#
# GeometryCollection places no other constraints on its elements.
# Subclasses of GeometryCollection may restrict membership based on
# dimension and may also place other constraints on the degree of spatial
# overlap between elements.
#
# == Notes
#
# GeometryCollection is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
#
# source://rgeo//lib/rgeo/feature/geometry_collection.rb#31
module RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  extend ::RGeo::Feature::Type

  # Returns the Nth geometry in this GeometryCollection, or nil if the
  # given N is out of range. N is zero-based.
  #
  # This behaves slightly different from GeometryCollection#geometry_n.
  # GeometryCollection#geometry_n accepts only nonnegative indexes,
  # as specified by the SFS. However, GeometryCollection#[] also accepts
  # negative indexes counting backwards from the end of the collection,
  # the same way Ruby's array indexing works. Hence, geometry_n(-1)
  # returns nil, where [-1] returns the last element of the collection.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#80
  def [](_idx); end

  # Iterates over the geometries of this GeometryCollection.
  #
  # This is not a standard SFS method, but is provided so that a
  # GeometryCollection can behave as a Ruby enumerable.
  # Note that all GeometryCollection implementations must also
  # include the Enumerable mixin.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#97
  def each(&_block); end

  # === SFS 1.1 Description
  #
  # Returns the Nth geometry in this GeometryCollection.
  #
  # === Notes
  #
  # Returns an object that supports the Geometry interface, or nil
  # if the given N is out of range. N is zero-based.
  # Also note that this method is different from GeometryCollection#[]
  # in that it does not support negative indexes.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#60
  def geometry_n(_idx); end

  # Nodes the linework in a list of Geometries
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#86
  def node; end

  # === SFS 1.1 Description
  #
  # Returns the number of geometries in this GeometryCollection.
  #
  # === Notes
  #
  # Returns an integer.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#45
  def num_geometries; end

  # Gives a point that is guaranteed to be within the geometry.
  #
  # Extends OGC SFS 1.1 and follows PostGIS standards.
  #
  # @raise [Error::UnsupportedOperation]
  # @see https://postgis.net/docs/ST_PointOnSurface.html
  #
  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#105
  def point_on_surface; end

  # Alias of the num_geometries method.
  #
  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#66
  def size; end
end

# All geometry implementations MUST include this submodule.
# This serves as a marker that may be used to test an object for
# feature-ness.
#
# source://rgeo//lib/rgeo/feature/types.rb#14
module RGeo::Feature::Instance
  # source://rgeo-geojson/2.2.0/lib/rgeo/geo_json/conversion_methods.rb#29
  def as_geojson; end

  # source://rgeo-geojson/2.2.0/lib/rgeo/geo_json/conversion_methods.rb#29
  def as_json; end

  # source://rgeo-geojson/2.2.0/lib/rgeo/geo_json/conversion_methods.rb#35
  def to_geojson; end

  # source://rgeo-geojson/2.2.0/lib/rgeo/geo_json/conversion_methods.rb#35
  def to_json; end
end

# == SFS 1.1 Description
#
# A Line is a LineString with exactly 2 Points.
#
# == Notes
#
# Line is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
#
# source://rgeo//lib/rgeo/feature/line.rb#23
module RGeo::Feature::Line
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  extend ::RGeo::Feature::Type
end

# == SFS 1.1 Description
#
# A LineString is a Curve with linear interpolation between Points.
# Each consecutive pair of Points defines a Line segment.
#
# == Notes
#
# LineString is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
#
# source://rgeo//lib/rgeo/feature/line_string.rb#23
module RGeo::Feature::LineString
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  extend ::RGeo::Feature::Type

  # === SFS 1.1 Description
  #
  # The number of Points in this LineString.
  #
  # === Notes
  #
  # Returns an integer.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/line_string.rb#35
  def num_points; end

  # === SFS 1.1 Description
  #
  # Returns the specified Point N in this LineString.
  #
  # === Notes
  #
  # Returns an object that supports the Point interface, or nil
  # if the given N is out of range. N is zero-based.
  # Does not support negative indexes.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/line_string.rb#49
  def point_n(_idx); end

  # Returns the constituent points as an array of objects that
  # support the Point interface.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/line_string.rb#56
  def points; end
end

# == SFS 1.1 Description
#
# A LinearRing is a LineString that is both closed and simple.
#
# == Notes
#
# LinearRing is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
#
# source://rgeo//lib/rgeo/feature/linear_ring.rb#22
module RGeo::Feature::LinearRing
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  extend ::RGeo::Feature::Type

  # Returns +true+ if the ring is oriented in a counter clockwise direction
  # otherwise returns +false+.
  #
  # == Notes
  #
  # Not a standard SFS method for linear rings, but added for convenience.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/linear_ring.rb#32
  def ccw?; end
end

# == SFS 1.1 Description
#
# A MultiCurve is a 1-dimensional GeometryCollection whose elements are
# Curves.
#
# MultiCurve is a non-instantiable class in this specification; it
# defines a set of methods for its subclasses and is included for
# reasons of extensibility.
#
# A MultiCurve is simple if and only if all of its elements are simple
# and the only intersections between any two elements occur at Points
# that are on the boundaries of both elements.
#
# The boundary of a MultiCurve is obtained by applying the "mod 2"
# union rule: A Point is in the boundary of a MultiCurve if it is in
# the boundaries of an odd number of elements of the MultiCurve.
#
# A MultiCurve is closed if all of its elements are closed. The
# boundary of a closed MultiCurve is always empty.
#
# A MultiCurve is defined as topologically closed.
#
# == Notes
#
# MultiCurve is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
#
# source://rgeo//lib/rgeo/feature/multi_curve.rb#40
module RGeo::Feature::MultiCurve
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::RGeo::Feature::GeometryCollection
  extend ::RGeo::Feature::Type

  # === SFS 1.1 Description
  #
  # Returns true if this MultiCurve is closed [StartPoint() = EndPoint()
  # for each Curve in this MultiCurve].
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/multi_curve.rb#67
  def closed?; end

  # === SFS 1.1 Description
  #
  # The Length of this MultiCurve which is equal to the sum of the
  # lengths of the element Curves.
  #
  # === Notes
  #
  # Returns a floating-point scalar value.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/multi_curve.rb#53
  def length; end
end

# == SFS 1.1 Description
#
# A MultiLineString is a MultiCurve whose elements are LineStrings.
#
# == Notes
#
# MultiLineString is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
#
# source://rgeo//lib/rgeo/feature/multi_line_string.rb#23
module RGeo::Feature::MultiLineString
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiCurve
  extend ::RGeo::Feature::Type
end

# == SFS 1.1 Description
#
# A MultiPoint is a 0-dimensional GeometryCollection. The elements of
# a MultiPoint are restricted to Points. The Points are not connected
# or ordered.
#
# A MultiPoint is simple if no two Points in the MultiPoint are equal
# (have identical coordinate values).
#
# The boundary of a MultiPoint is the empty set.
#
# == Notes
#
# MultiPoint is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
#
# source://rgeo//lib/rgeo/feature/multi_point.rb#30
module RGeo::Feature::MultiPoint
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::RGeo::Feature::GeometryCollection
  extend ::RGeo::Feature::Type
end

# == SFS 1.1 Description
#
# A MultiPolygon is a MultiSurface whose elements are Polygons.
#
# The assertions for MultiPolygons are as follows.
#
# a) The interiors of 2 Polygons that are elements of a MultiPolygon
# may not intersect.
#
# b) The boundaries of any 2 Polygons that are elements of a
# MultiPolygon may not "cross" and may touch at only a finite number
# of Points. NOTE: Crossing is prevented by assertion (a) above.
#
# c) A MultiPolygon is defined as topologically closed.
#
# d) A MultiPolygon may not have cut lines, spikes or punctures, a
# MultiPolygon is a regular closed Point set:
#
# e) The interior of a MultiPolygon with more than 1 Polygon is not
# connected, the number of connected components of the interior of a
# MultiPolygon is equal to the number of Polygons in the MultiPolygon.
#
# The boundary of a MultiPolygon is a set of closed Curves
# (LineStrings) corresponding to the boundaries of its element
# Polygons. Each Curve in the boundary of the MultiPolygon is in the
# boundary of exactly 1 element Polygon, and every Curve in the
# boundary of an element Polygon is in the boundary of the
# MultiPolygon.
#
# NOTE: The subclass of Surface named Polyhedral Surface is a faceted
# Surface whose facets are Polygons. A Polyhedral Surface is not a
# MultiPolygon because it violates the rule for MultiPolygons that the
# boundaries of the element Polygons intersect only at a finite number
# of Points.
#
# == Notes
#
# MultiPolygon is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
#
# source://rgeo//lib/rgeo/feature/multi_polygon.rb#54
module RGeo::Feature::MultiPolygon
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiSurface
  extend ::RGeo::Feature::Type
end

# == SFS 1.1 Description
#
# A MultiSurface is a 2-dimensional GeometryCollection whose elements
# are Surfaces. The interiors of any two Surfaces in a MultiSurface may
# not intersect. The boundaries of any two elements in a MultiSurface
# may intersect, at most, at a finite number of Points.
#
# MultiSurface is a non-instantiable class in this International
# Standard. It defines a set of methods for its subclasses and is
# included for reasons of extensibility. The instantiable subclass of
# MultiSurface is MultiPolygon, corresponding to a collection of
# Polygons.
#
# == Notes
#
# MultiSurface is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
#
# source://rgeo//lib/rgeo/feature/multi_surface.rb#31
module RGeo::Feature::MultiSurface
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::RGeo::Feature::GeometryCollection
  extend ::RGeo::Feature::Type

  # === SFS 1.1 Description
  #
  # The area of this MultiSurface, as measured in the spatial reference
  # system of this MultiSurface.
  #
  # === Notes
  #
  # Returns a floating-point scalar value.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/multi_surface.rb#44
  def area; end

  # === SFS 1.1 Description
  #
  # The mathematical centroid for this MultiSurface as a Point. The
  # result is not guaranteed to be on this MultiSurface.
  #
  # === Notes
  #
  # Returns an object that supports the Point interface.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/multi_surface.rb#57
  def centroid; end

  # === SFS 1.1 Description
  #
  # A Point guaranteed to be on this MultiSurface.
  #
  # === Notes
  #
  # Returns an object that supports the Point interface.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/multi_surface.rb#69
  def point_on_surface; end
end

# == SFS 1.1 Description
#
# A Point is a 0-dimensional geometric object and represents a single
# location in coordinate space. A Point has an x-coordinate value and
# a y-coordinate value.
#
# The boundary of a Point is the empty set.
#
# == Notes
#
# Point is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
#
# Some implementations may support higher dimensional points.
#
# Some libraries, such as GEOS, support "empty" points. Such objects
# might be returned as, for example, the centroid of an empty
# MultiPolygon. The SFS does not clearly define or even acknowledge
# the existence of such a type, so RGeo will currently generally
# replace them with empty GeometryCollection objects. Therefore,
# currently, every RGeo Point object represents an actual location
# with real coordinates.
#
# source://rgeo//lib/rgeo/feature/point.rb#36
module RGeo::Feature::Point
  include ::RGeo::Feature::Geometry
  extend ::RGeo::Feature::Type

  # Returns the m-coordinate for this Point as a floating-point
  # scalar value.
  #
  # This method may not be available if the point's factory does
  # not support M coordinates.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/point.rb#80
  def m; end

  # === SFS 1.1 Description
  #
  # The x-coordinate value for this Point.
  #
  # === Notes
  #
  # Returns a floating-point scalar value.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/point.rb#48
  def x; end

  # === SFS 1.1 Description
  #
  # The y-coordinate value for this Point.
  #
  # === Notes
  #
  # Returns a floating-point scalar value.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/point.rb#60
  def y; end

  # Returns the z-coordinate for this Point as a floating-point
  # scalar value.
  #
  # This method may not be available if the point's factory does
  # not support Z coordinates.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/point.rb#70
  def z; end
end

# == SFS 1.1 Description
#
# A Polygon is a planar Surface defined by 1 exterior boundary and 0 or
# more interior boundaries. Each interior boundary defines a hole in
# the Polygon.
#
# The assertions for Polygons (the rules that define valid Polygons)
# are as follows:
#
# (a) Polygons are topologically closed;
#
# (b) The boundary of a Polygon consists of a set of LinearRings that
# make up its exterior and interior boundaries;
#
# (c) No two Rings in the boundary cross and the Rings in the boundary
# of a Polygon may intersect at a Point but only as a tangent;
#
# (d) A Polygon may not have cut lines, spikes or punctures;
#
# (e) The interior of every Polygon is a connected point set;
#
# (f) The exterior of a Polygon with 1 or more holes is not connected.
# Each hole defines a connected component of the exterior.
#
# In the above assertions, interior, closure and exterior have the
# standard topological definitions. The combination of (a) and (c) make
# a Polygon a regular closed Point set.
#
# Polygons are simple geometric objects.
#
# == Notes
#
# Polygon is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
#
# source://rgeo//lib/rgeo/feature/polygon.rb#48
module RGeo::Feature::Polygon
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Surface
  extend ::RGeo::Feature::Type

  # === SFS 1.1 Description
  #
  # Returns the exterior ring of this Polygon.
  #
  # === Notes
  #
  # Returns an object that supports the LinearRing interface.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/polygon.rb#60
  def exterior_ring; end

  # === SFS 1.1 Description
  #
  # Returns the Nth interiorRing for this Polygon as a LineString.
  #
  # === Notes
  #
  # Returns an object that supports the LinearRing interface, or nil
  # if the given N is out of range. N is zero-based.
  # Does not support negative indexes.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/polygon.rb#86
  def interior_ring_n(_idx); end

  # Returns the interior rings as a (possibly empty) array of objects
  # that support the LinearRing interface.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/polygon.rb#93
  def interior_rings; end

  # === SFS 1.1 Description
  #
  # Returns the number of interiorRings in this Polygon.
  #
  # === Notes
  #
  # Returns an integer.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/polygon.rb#72
  def num_interior_rings; end
end

# == SFS 1.1 Description
#
# A Surface is a 2-dimensional geometric object.
#
# A simple Surface consists of a single "patch" that is associated with
# one "exterior boundary" and 0 or more "interior" boundaries. Simple
# Surfaces in 3-dimensional space are isomorphic to planar Surfaces.
# Polyhedral Surfaces are formed by "stitching" together simple
# Surfaces along their boundaries, polyhedral Surfaces in 3-dimensional
# space may not be planar as a whole.
#
# The boundary of a simple Surface is the set of closed Curves
# corresponding to its "exterior" and "interior" boundaries.
#
# The only instantiable subclass of Surface defined in this
# specification, Polygon, is a simple Surface that is planar.
#
# == Notes
#
# Surface is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
#
# Some implementations may support higher dimensional points.
#
# source://rgeo//lib/rgeo/feature/surface.rb#37
module RGeo::Feature::Surface
  include ::RGeo::Feature::Geometry
  extend ::RGeo::Feature::Type

  # === SFS 1.1 Description
  #
  # The area of this Surface, as measured in the spatial reference
  # system of this Surface.
  #
  # === Notes
  #
  # Returns a floating-point scalar value.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/surface.rb#50
  def area; end

  # === SFS 1.1 Description
  #
  # The mathematical centroid for this Surface as a Point. The result
  # is not guaranteed to be on this Surface.
  #
  # === Notes
  #
  # Returns an object that supports the Point interface.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/surface.rb#63
  def centroid; end

  # === SFS 1.1 Description
  #
  # A Point guaranteed to be on this Surface.
  #
  # === Notes
  #
  # Returns an object that supports the Point interface.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/feature/surface.rb#75
  def point_on_surface; end
end

# This module provides the API for geometry type objects. Technically
# these objects are modules (such as RGeo::Feature::Point), but as
# objects they respond to the methods documented here.
#
# For example, you may determine whether a feature object is a
# point by calling:
#
#   RGeo::Feature::Point.check_type(object)
#
# A corresponding === operator is provided so you can use the type
# modules in a case-when clause:
#
#   case object
#   when RGeo::Feature::Point
#     # do stuff here...
#
# However, a feature object may not actually include the point module
# itself; hence, the following will *not* work:
#
#   object.is_a?(RGeo::Feature::Point)  # DON'T DO THIS-- DOES NOT WORK
#
# You may obtain the type of a feature object by calling its
# geometry_type method. You may then use the methods in this module to
# interrogate that type.
#
#   # supppose object is a Point
#   type = object.geometry_type  # RGeo::Feature::Point
#   type.type_name               # "Point"
#   type.supertype               # RGeo::Feature::Geometry
#
# You may also use the presence of this module to determine whether
# a particular object is a feature type:
#
#   RGeo::Feature::Type === object.geometry_type  # true
#
# source://rgeo//lib/rgeo/feature/types.rb#51
module RGeo::Feature::Type
  # Returns true if the given object is this type or a subtype
  # thereof, or if it is a feature object whose geometry_type is
  # this type or a subtype thereof.
  #
  # Note that feature objects need not actually include this module.
  # Therefore, the is_a? method will generally not work.
  #
  # source://rgeo//lib/rgeo/feature/types.rb#59
  def ===(rhs); end

  # source://rgeo//lib/rgeo/feature/types.rb#94
  def add_subtype(type); end

  # Returns true if the given object is this type or a subtype
  # thereof, or if it is a feature object whose geometry_type is
  # this type or a subtype thereof.
  #
  # Note that feature objects need not actually include this module.
  # Therefore, the is_a? method will generally not work.
  #
  # source://rgeo//lib/rgeo/feature/types.rb#59
  def check_type(rhs); end

  # Iterates over the known immediate subtypes of this type.
  #
  # source://rgeo//lib/rgeo/feature/types.rb#81
  def each_immediate_subtype(&block); end

  # Returns true if this type is the same type or a subtype of the
  # given type.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/feature/types.rb#68
  def subtype_of?(type); end

  # Returns the supertype of this type. The supertype of Geometry
  # is nil.
  #
  # source://rgeo//lib/rgeo/feature/types.rb#75
  def supertype; end

  # Returns the OpenGIS type name of this type. For example:
  #
  #   RGeo::Feature::Point.type_name  # "Point"
  #
  # source://rgeo//lib/rgeo/feature/types.rb#89
  def to_s; end

  # Returns the OpenGIS type name of this type. For example:
  #
  #   RGeo::Feature::Point.type_name  # "Point"
  #
  # source://rgeo//lib/rgeo/feature/types.rb#89
  def type_name; end

  class << self
    # source://rgeo//lib/rgeo/feature/types.rb#98
    def extended(type); end
  end
end

# source://rgeo//lib/rgeo/geographic/factory.rb#10
module RGeo::Geographic
  class << self
    # Creates and returns a geographic factory that includes a
    # projection specified by a coordinate system. Like all
    # geographic factories, this one creates features using latitude-
    # longitude values. However, calculations such as intersections are
    # done in the projected coordinate system, and size and distance
    # calculations report results in the projected units. Thus, this
    # factory actually includes two factories representing different
    # coordinate systems: the main factory representing the geographic
    # lat-long coordinate system, and an auxiliary "projection factory"
    # representing the projected coordinate system.
    #
    # This implementation is intended for advanced GIS applications
    # requiring greater control over the projection being used.
    #
    # === Options
    #
    # When creating a projected implementation, you must provide enough
    # information to construct a CoordinateSystem specification for the projection.
    # Generally, this means you will provide either the projection's
    # factory itself (via the <tt>:projection_factory</tt> option), in
    # which case the factory must include a coord_sys;
    # or, alternatively, you should provide the coordinate system
    # and let this method construct a projection factory for you (which
    # it will do using the preferred Cartesian factory generator).
    # If you choose this second method, you may provide the coord_sys
    # via the <tt>:projection_coord_sys</tt> or <option or <tt>:projection_srid</tt>.
    #
    # Following are detailed descriptions of the various options you can
    # pass to this method.
    #
    # [<tt>:projection_factory</tt>]
    #   Specify an existing Cartesian factory to use for the projection.
    #   This factory must have a non-nil coord_sys. If this is provided, any
    #   <tt>:projection_coord_sys</tt> and
    #   <tt>:projection_srid</tt> are ignored.
    # [<tt>:projection_coord_sys</tt>]
    #   Specify a OGC coordinate system for the projection. This may be
    #   specified as an RGeo::CoordSys::CS::GeographicCoordinateSystem
    #   object, or as a String in OGC WKT format. Optional.
    # [<tt>:projection_srid</tt>]
    #   The SRID value to use for the projection factory. Defaults to
    #   the given projection coordinate system's authority code, or to
    #   0 if no projection coordinate system is known. If this is provided
    #   without a projection_coord_sys, one will be instansiated from
    #   the default_coord_sys_class or projection_coord_sys_class if given.
    # [<tt>:projection_coord_sys_class</tt>]
    #   Class to create the projection_coord_sys from if only a projection_srid
    #   is provided.
    # [<tt>:coord_sys</tt>]
    #   An OGC coordinate system for the geographic (lat-lon) factory,
    #   which may be an RGeo::CoordSys::CS::GeographicCoordinateSystem
    #   object or a string in OGC WKT format. It defaults to the
    #   geographic system embedded in the projection coordinate system.
    #   Generally, you should leave it at the default unless you want
    #   the geographic coordinate system to be based on a different
    #   horizontal datum than the projection.
    # [<tt>:srid</tt>]
    #   The SRID value to use for the main geographic factory. Defaults
    #   to the given geographic coordinate system's authority code, or
    #   to 0 if no geographic coordinate system is known.
    # [<tt>:has_z_coordinate</tt>]
    #   Support a Z coordinate. Default is false.
    #   Note: this is ignored if a <tt>:projection_factory</tt> is
    #   provided; in that case, the geographic factory's z-coordinate
    #   availability will match the projection factory's setting.
    # [<tt>:has_m_coordinate</tt>]
    #   Support an M coordinate. Default is false.
    #   Note: this is ignored if a <tt>:projection_factory</tt> is
    #   provided; in that case, the geographic factory's m-coordinate
    #   availability will match the projection factory's setting.
    # [<tt>:wkt_parser</tt>]
    #   Configure the parser for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTParser.new. Default is
    #   the empty hash, indicating the default configuration for
    #   WKRep::WKTParser.
    # [<tt>:wkb_parser</tt>]
    #   Configure the parser for WKB. The value is a hash of
    #   configuration parameters for WKRep::WKBParser.new. Default is
    #   the empty hash, indicating the default configuration for
    #   WKRep::WKBParser.
    # [<tt>:wkt_generator</tt>]
    #   Configure the generator for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTGenerator.new.
    #   Default is <tt>{:convert_case => :upper}</tt>.
    # [<tt>:wkb_generator</tt>]
    #   Configure the generator for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTGenerator.new.
    #   Default is the empty hash, indicating the default configuration
    #   for WKRep::WKBGenerator.
    #
    # If a <tt>:projection_factory</tt> is _not_ provided, you may also
    # provide options for configuring the projected Cartesian factory.
    # For example, if GEOS is used for the projected factory, you may
    # also set the <tt>:buffer_resolution</tt> option. See RGeo::Geos.factory
    # for more details.
    #
    # source://rgeo//lib/rgeo/geographic/interface.rb#307
    def projected_factory(opts = T.unsafe(nil)); end

    # Creates and returns a geographic factory that is designed for
    # visualization applications that use Google or Bing maps, or any
    # other visualization systems that use the same projection. It
    # includes a projection factory that matches the projection used
    # by those mapping systems.
    #
    # Like all geographic factories, this one creates features using
    # latitude-longitude values. However, calculations such as
    # intersections are done in the projected coordinate system, and
    # size and distance calculations report results in the projected
    # units.
    #
    # The behavior of the simple_mercator factory could also be obtained
    # using a projected_factory with appropriate Proj4 specifications.
    # However, the simple_mercator implementation is done without
    # actually requiring the Proj4 library. The projections are simple
    # enough to be implemented in pure ruby.
    #
    # === About the coordinate system
    #
    # Many popular visualization technologies, such as Google and Bing
    # maps, actually use two coordinate systems. The first is the
    # standard WSG84 lat-long system used by the GPS and represented
    # by EPSG 4326. Most API calls and input-output in these mapping
    # technologies utilize this coordinate system. The second is a
    # Mercator projection based on a "sphericalization" of the WGS84
    # lat-long system. This projection is the basis of the map's screen
    # and tiling coordinates, and has been assigned EPSG 3857.
    #
    # This factory represents both coordinate systems. The main factory
    # produces data in the lat-long system and reports SRID 4326, and
    # the projected factory produces data in the projection and reports
    # SRID 3857. Latitudes are restricted to the range
    # (-85.05112877980659, 85.05112877980659), which conveniently
    # results in a square projected domain.
    #
    # === Options
    #
    # You may use the following options when creating a simple_mercator
    # factory:
    #
    # [<tt>:has_z_coordinate</tt>]
    #   Support a Z coordinate. Default is false.
    # [<tt>:has_m_coordinate</tt>]
    #   Support an M coordinate. Default is false.
    # [<tt>:wkt_parser</tt>]
    #   Configure the parser for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTParser.new. Default is
    #   the empty hash, indicating the default configuration for
    #   WKRep::WKTParser.
    # [<tt>:wkb_parser</tt>]
    #   Configure the parser for WKB. The value is a hash of
    #   configuration parameters for WKRep::WKBParser.new. Default is
    #   the empty hash, indicating the default configuration for
    #   WKRep::WKBParser.
    # [<tt>:wkt_generator</tt>]
    #   Configure the generator for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTGenerator.new.
    #   Default is <tt>{:convert_case => :upper}</tt>.
    # [<tt>:wkb_generator</tt>]
    #   Configure the generator for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTGenerator.new.
    #   Default is the empty hash, indicating the default configuration
    #   for WKRep::WKBGenerator.
    #
    # You may also provide options understood by the underlying
    # projected Cartesian factory. For example, if GEOS is used for the
    # projected factory, you may also set the <tt>:buffer_resolution</tt>
    # options. See RGeo::Geos.factory for more details.
    #
    # source://rgeo//lib/rgeo/geographic/interface.rb#189
    def simple_mercator_factory(opts = T.unsafe(nil)); end

    # Creates and returns a geographic factory that does not include a
    # a projection, and which performs calculations assuming a
    # spherical earth. In other words, geodesics are treated as great
    # circle arcs, and geometric calculations are handled accordingly.
    # Size and distance calculations report results in meters.
    # This implementation is thus ideal for everyday calculations on
    # the globe in which good accuracy is desired, but in which it is
    # not deemed necessary to perform the complex ellipsoidal
    # calculations needed for greater precision.
    #
    # The maximum error is about 0.5 percent, for objects and
    # calculations that span a significant percentage of the globe, due
    # to distortion caused by rotational flattening of the earth. For
    # calculations that span a much smaller area, the error can drop to
    # a few meters or less.
    #
    # === Limitations
    #
    # This implementation does not implement some of the more advanced
    # geometric operations. In particular:
    #
    # * Relational operators such as Feature::Geometry#intersects? are
    #   not implemented for most types.
    # * Relational constructors such as Feature::Geometry#union are
    #   not implemented for most types.
    # * Buffer, convex hull, and envelope calculations are not
    #   implemented for most types. Boundaries are available except for
    #   GeometryCollection.
    # * Length calculations are available, but areas are not. Distances
    #   are available only between points.
    # * Equality and simplicity evaluation are implemented for some but
    #   not all types.
    # * Assertions for polygons and multipolygons are not implemented.
    #
    # Unimplemented operations will return nil if invoked.
    #
    # === Options
    #
    # You may use the following options when creating a spherical
    # factory:
    #
    # [<tt>:has_z_coordinate</tt>]
    #   Support a Z coordinate. Default is false.
    # [<tt>:has_m_coordinate</tt>]
    #   Support an M coordinate. Default is false.
    # [<tt>:buffer_resolution</tt>]
    #   The resolution of buffers around geometries created by this
    #   factory. This controls the number of line segments used to
    #   approximate curves. The default is 1, which causes, for
    #   example, the buffer around a point to be approximated by a
    #   4-sided polygon. A resolution of 2 would cause that buffer
    #   to be approximated by an 8-sided polygon. The exact behavior
    #   for different kinds of buffers is not specified precisely,
    #   but in general the value is taken as the number of segments
    #   per 90-degree curve.
    # [<tt>:coord_sys</tt>]
    #   Provide a coordinate system in OGC format, either as an object
    #   (one of the CoordSys::CS classes) or as a string in WKT format.
    #   This coordinate system must be a GeographicCoordinateSystem.
    #   The default is the "popular visualization CRS" (EPSG 4055).
    # [<tt>:coord_sys_class</tt>]
    #   CoordSys::CS::CoordinateSystem implementation used to instansiate
    #   a coord_sys based on the :srid given.
    # [<tt>:srid</tt>]
    #   The SRID that should be returned by features from this factory.
    #   Default is 4055, indicating EPSG 4055, the "popular
    #   visualization crs". You may alternatively wish to set the srid
    #   to 4326, indicating the WGS84 crs, but note that that value
    #   implies an ellipsoidal datum, not a spherical datum.
    # [<tt>:wkt_parser</tt>]
    #   Configure the parser for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTParser.new. Default is
    #   the empty hash, indicating the default configuration for
    #   WKRep::WKTParser.
    # [<tt>:wkb_parser</tt>]
    #   Configure the parser for WKB. The value is a hash of
    #   configuration parameters for WKRep::WKBParser.new. Default is
    #   the empty hash, indicating the default configuration for
    #   WKRep::WKBParser.
    # [<tt>:wkt_generator</tt>]
    #   Configure the generator for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTGenerator.new.
    #   Default is <tt>{:convert_case => :upper}</tt>.
    # [<tt>:wkb_generator</tt>]
    #   Configure the generator for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTGenerator.new.
    #   Default is the empty hash, indicating the default configuration
    #   for WKRep::WKBGenerator.
    #
    # source://rgeo//lib/rgeo/geographic/interface.rb#101
    def spherical_factory(opts = T.unsafe(nil)); end

    private

    # source://rgeo//lib/rgeo/geographic/interface.rb#382
    def coord_sys4055; end

    # source://rgeo//lib/rgeo/geographic/interface.rb#388
    def coord_sys4326; end
  end
end

# This class implements the various factories for geography features.
# See methods of the RGeo::Geographic module for the API for creating
# geography factories.
#
# source://rgeo//lib/rgeo/geographic/factory.rb#14
class RGeo::Geographic::Factory
  include ::RGeo::Feature::Factory::Instance
  include ::RGeo::ImplHelper::Utils

  # @return [Factory] a new instance of Factory
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#28
  def initialize(impl_prefix, opts = T.unsafe(nil)); end

  # Equivalence test.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#91
  def ==(other); end

  # See RGeo::Feature::Factory#collection
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#330
  def collection(elems); end

  # See RGeo::Feature::Factory#coord_sys
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#26
  def coord_sys; end

  # Returns the value of attribute coordinate_dimension.
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#20
  def coordinate_dimension; end

  # Psych support
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#160
  def encode_with(coder); end

  # Equivalence test.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#91
  def eql?(other); end

  # source://rgeo//lib/rgeo/geographic/factory.rb#356
  def generate_wkb(obj); end

  # source://rgeo//lib/rgeo/geographic/factory.rb#352
  def generate_wkt(obj); end

  # Returns true if this factory supports a projection.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#210
  def has_projection?; end

  # Standard hash code
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#102
  def hash; end

  # source://rgeo//lib/rgeo/geographic/factory.rb#178
  def init_with(coder); end

  # See RGeo::Feature::Factory#line
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#312
  def line(start, stop); end

  # See RGeo::Feature::Factory#line_string
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#306
  def line_string(points); end

  # See RGeo::Feature::Factory#linear_ring
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#318
  def linear_ring(points); end

  # Marshal support
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#108
  def marshal_dump; end

  # source://rgeo//lib/rgeo/geographic/factory.rb#128
  def marshal_load(data_); end

  # source://rgeo//lib/rgeo/geographic/factory.rb#360
  def marshal_wkb_generator; end

  # source://rgeo//lib/rgeo/geographic/factory.rb#364
  def marshal_wkb_parser; end

  # See RGeo::Feature::Factory#multi_line_string
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#342
  def multi_line_string(elems); end

  # See RGeo::Feature::Factory#multi_point
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#336
  def multi_point(elems); end

  # See RGeo::Feature::Factory#multi_polygon
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#348
  def multi_polygon(elems); end

  # See RGeo::Feature::Factory#parse_wkb
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#294
  def parse_wkb(str); end

  # See RGeo::Feature::Factory#parse_wkt
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#288
  def parse_wkt(str); end

  # See RGeo::Feature::Factory#point
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#300
  def point(x, y, *extra); end

  # See RGeo::Feature::Factory#polygon
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#324
  def polygon(outer_ring, inner_rings = T.unsafe(nil)); end

  # Projects the given geometry into the projected coordinate space,
  # and returns the projected geometry.
  # Returns nil if this factory does not support a projection.
  # Raises Error::InvalidGeometry if the given geometry is not of
  # this factory.
  #
  # @raise [Error::InvalidGeometry]
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#227
  def project(geometry); end

  # Returns the factory for the projected coordinate space,
  # or nil if this factory does not support a projection.
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#217
  def projection_factory; end

  # Returns a ProjectedWindow specifying the limits of the domain of
  # the projection space.
  # Returns nil if this factory does not support a projection, or the
  # projection limits are not known.
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#264
  def projection_limits_window; end

  # Returns true if this factory supports a projection and the
  # projection wraps its x (easting) direction. For example, a
  # Mercator projection wraps, but a local projection that is valid
  # only for a small area does not wrap. Returns nil if this factory
  # does not support or a projection, or if it is not known whether
  # or not it wraps.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#255
  def projection_wraps?; end

  # Sets the attribute projector
  #
  # @param value the value to set the attribute projector to.
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#18
  def projector=(_arg0); end

  # See RGeo::Feature::Factory#property
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#273
  def property(name); end

  # source://rgeo//lib/rgeo/geographic/factory.rb#368
  def psych_wkt_generator; end

  # source://rgeo//lib/rgeo/geographic/factory.rb#372
  def psych_wkt_parser; end

  # Returns the value of attribute spatial_dimension.
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#20
  def spatial_dimension; end

  # Returns the srid reported by this factory.
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#23
  def srid; end

  # Reverse-projects the given geometry from the projected coordinate
  # space into lat-long space.
  # Raises Error::InvalidGeometry if the given geometry is not of
  # the projection defined by this factory.
  #
  # source://rgeo//lib/rgeo/geographic/factory.rb#238
  def unproject(geometry); end
end

# source://rgeo//lib/rgeo/geographic/projected_feature_classes.rb#63
class RGeo::Geographic::ProjectedGeometryCollectionImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def node(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def size(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#62
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#107
  def unsafe_buffer(distance); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#91
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#123
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#83
  def unsafe_crosses?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#135
  def unsafe_difference(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#71
  def unsafe_disjoint?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#103
  def unsafe_distance(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#21
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#127
  def unsafe_intersection(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#75
  def unsafe_intersects?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#86
  def unsafe_node; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#95
  def unsafe_overlaps?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#143
  def unsafe_point_on_surface; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#66
  def unsafe_size; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#139
  def unsafe_sym_difference(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#79
  def unsafe_touches?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#131
  def unsafe_union(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#87
  def unsafe_within?(rhs); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#11
module RGeo::Geographic::ProjectedGeometryMethods
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#62
  def boundary; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#107
  def buffer(distance); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#111
  def buffer_with_style(distance, end_cap_style, join_style, mitre_limit); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#91
  def contains?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#123
  def convex_hull; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#25
  def coordinate_dimension; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#83
  def crosses?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#135
  def difference(rhs); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#71
  def disjoint?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#103
  def distance(rhs); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#41
  def empty?; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#21
  def envelope; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#67
  def equals?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#127
  def intersection(rhs); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#75
  def intersects?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#53
  def invalid_reason; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#33
  def is_3d?; end

  # Try and make the geometry valid, this may change its shape.
  # Returns a valid copy of the geometry.
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#58
  def make_valid; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#37
  def measured?; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#95
  def overlaps?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#143
  def point_on_surface; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#16
  def projection; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#99
  def relate(rhs, pattern_); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#45
  def simple?; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#115
  def simplify(tolerance); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#119
  def simplify_preserve_topology(tolerance); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#29
  def spatial_dimension; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#12
  def srid; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#139
  def sym_difference(rhs); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#79
  def touches?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#131
  def union(rhs); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#49
  def valid?; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#87
  def within?(rhs); end
end

# source://rgeo//lib/rgeo/geographic/projected_feature_classes.rb#42
class RGeo::Geographic::ProjectedLineImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::Line
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::BasicLineMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedNCurveMethods
  include ::RGeo::Geographic::ProjectedLineStringMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def length(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def ring?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#62
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#107
  def unsafe_buffer(distance); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#91
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#123
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#83
  def unsafe_crosses?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#135
  def unsafe_difference(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#71
  def unsafe_disjoint?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#103
  def unsafe_distance(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#21
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#127
  def unsafe_intersection(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#75
  def unsafe_intersects?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#185
  def unsafe_length; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#95
  def unsafe_overlaps?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#70
  def unsafe_ring?; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#139
  def unsafe_sym_difference(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#79
  def unsafe_touches?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#131
  def unsafe_union(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#87
  def unsafe_within?(rhs); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geographic/projected_feature_classes.rb#20
class RGeo::Geographic::ProjectedLineStringImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedNCurveMethods
  include ::RGeo::Geographic::ProjectedLineStringMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def length(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def ring?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#62
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#107
  def unsafe_buffer(distance); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#91
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#123
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#83
  def unsafe_crosses?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#135
  def unsafe_difference(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#71
  def unsafe_disjoint?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#103
  def unsafe_distance(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#21
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#127
  def unsafe_intersection(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#75
  def unsafe_intersects?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#185
  def unsafe_length; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#95
  def unsafe_overlaps?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#70
  def unsafe_ring?; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#139
  def unsafe_sym_difference(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#79
  def unsafe_touches?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#131
  def unsafe_union(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#87
  def unsafe_within?(rhs); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#190
module RGeo::Geographic::ProjectedLineStringMethods
  private

  # Ensure coordinates fall within a valid range.
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#194
  def init_geometry; end
end

# source://rgeo//lib/rgeo/geographic/projected_feature_classes.rb#30
class RGeo::Geographic::ProjectedLinearRingImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::LinearRing
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::BasicLinearRingMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedNCurveMethods
  include ::RGeo::Geographic::ProjectedLineStringMethods
  include ::RGeo::Geographic::ProjectedLinearRingMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def ccw?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def length(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def ring?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#62
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#107
  def unsafe_buffer(distance); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#163
  def unsafe_ccw?; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#91
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#123
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#83
  def unsafe_crosses?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#135
  def unsafe_difference(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#71
  def unsafe_disjoint?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#103
  def unsafe_distance(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#21
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#127
  def unsafe_intersection(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#75
  def unsafe_intersects?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#185
  def unsafe_length; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#95
  def unsafe_overlaps?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#70
  def unsafe_ring?; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#139
  def unsafe_sym_difference(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#79
  def unsafe_touches?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#131
  def unsafe_union(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#87
  def unsafe_within?(rhs); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#200
module RGeo::Geographic::ProjectedLinearRingMethods
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#201
  def simple?; end
end

# source://rgeo//lib/rgeo/geographic/projected_feature_classes.rb#80
class RGeo::Geographic::ProjectedMultiLineStringImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiCurve
  include ::RGeo::Feature::MultiLineString
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiLineStringMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedNCurveMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def length(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def node(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def size(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#62
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#107
  def unsafe_buffer(distance); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#91
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#123
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#83
  def unsafe_crosses?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#135
  def unsafe_difference(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#71
  def unsafe_disjoint?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#103
  def unsafe_distance(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#21
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#127
  def unsafe_intersection(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#75
  def unsafe_intersects?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#185
  def unsafe_length; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#86
  def unsafe_node; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#95
  def unsafe_overlaps?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#143
  def unsafe_point_on_surface; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#66
  def unsafe_size; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#139
  def unsafe_sym_difference(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#79
  def unsafe_touches?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#131
  def unsafe_union(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#87
  def unsafe_within?(rhs); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geographic/projected_feature_classes.rb#71
class RGeo::Geographic::ProjectedMultiPointImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiPoint
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiPointMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def node(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def size(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#62
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#107
  def unsafe_buffer(distance); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#91
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#123
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#83
  def unsafe_crosses?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#135
  def unsafe_difference(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#71
  def unsafe_disjoint?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#103
  def unsafe_distance(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#21
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#127
  def unsafe_intersection(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#75
  def unsafe_intersects?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#86
  def unsafe_node; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#95
  def unsafe_overlaps?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#143
  def unsafe_point_on_surface; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#66
  def unsafe_size; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#139
  def unsafe_sym_difference(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#79
  def unsafe_touches?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#131
  def unsafe_union(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#87
  def unsafe_within?(rhs); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geographic/projected_feature_classes.rb#90
class RGeo::Geographic::ProjectedMultiPolygonImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiSurface
  include ::RGeo::Feature::MultiPolygon
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiPolygonMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedNSurfaceMethods
  include ::RGeo::Geographic::ProjectedMultiPolygonMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def area(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def centroid(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def node(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def size(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#207
  def unsafe_area; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#62
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#107
  def unsafe_buffer(distance); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#211
  def unsafe_centroid; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#91
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#123
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#83
  def unsafe_crosses?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#135
  def unsafe_difference(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#71
  def unsafe_disjoint?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#103
  def unsafe_distance(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#21
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#127
  def unsafe_intersection(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#75
  def unsafe_intersects?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#86
  def unsafe_node; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#95
  def unsafe_overlaps?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#143
  def unsafe_point_on_surface; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#66
  def unsafe_size; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#139
  def unsafe_sym_difference(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#79
  def unsafe_touches?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#131
  def unsafe_union(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#87
  def unsafe_within?(rhs); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#226
module RGeo::Geographic::ProjectedMultiPolygonMethods
  private

  # Ensure projection is available.
  #
  # @raise [Error::InvalidGeometry]
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#230
  def init_geometry; end
end

# source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#184
module RGeo::Geographic::ProjectedNCurveMethods
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#185
  def length; end
end

# source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#206
module RGeo::Geographic::ProjectedNSurfaceMethods
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#207
  def area; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#211
  def centroid; end
end

# source://rgeo//lib/rgeo/geographic/projected_feature_classes.rb#11
class RGeo::Geographic::ProjectedPointImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Point
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicPointMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedPointMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def lat(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def latitude(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def lon(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def longitude(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#62
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#107
  def unsafe_buffer(distance); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#91
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#123
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#83
  def unsafe_crosses?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#135
  def unsafe_difference(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#71
  def unsafe_disjoint?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#103
  def unsafe_distance(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#21
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#127
  def unsafe_intersection(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#75
  def unsafe_intersects?(rhs); end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#26
  def unsafe_lat; end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#26
  def unsafe_latitude; end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#22
  def unsafe_lon; end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#22
  def unsafe_longitude; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#95
  def unsafe_overlaps?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#139
  def unsafe_sym_difference(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#79
  def unsafe_touches?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#131
  def unsafe_union(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#87
  def unsafe_within?(rhs); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#148
module RGeo::Geographic::ProjectedPointMethods
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#149
  def canonical_lon; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#149
  def canonical_longitude; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#157
  def canonical_point; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#149
  def canonical_x; end

  private

  # Ensure coordinates fall within a valid range.
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#177
  def init_geometry; end

  class << self
    # @private
    #
    # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#165
    def included(klass); end
  end
end

# source://rgeo//lib/rgeo/geographic/projected_feature_classes.rb#53
class RGeo::Geographic::ProjectedPolygonImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Surface
  include ::RGeo::Feature::Polygon
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicPolygonMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedNSurfaceMethods
  include ::RGeo::Geographic::ProjectedPolygonMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def area(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def centroid(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def interior_ring_n(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#207
  def unsafe_area; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#62
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#107
  def unsafe_buffer(distance); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#211
  def unsafe_centroid; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#91
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#123
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#83
  def unsafe_crosses?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#135
  def unsafe_difference(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#71
  def unsafe_disjoint?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#103
  def unsafe_distance(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#21
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#32
  def unsafe_interior_ring_n(idx); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#127
  def unsafe_intersection(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#75
  def unsafe_intersects?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#95
  def unsafe_overlaps?(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#143
  def unsafe_point_on_surface; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#139
  def unsafe_sym_difference(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#79
  def unsafe_touches?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#131
  def unsafe_union(rhs); end

  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#87
  def unsafe_within?(rhs); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#216
module RGeo::Geographic::ProjectedPolygonMethods
  private

  # Ensure projection is available.
  #
  # @raise [Error::InvalidGeometry]
  #
  # source://rgeo//lib/rgeo/geographic/projected_feature_methods.rb#220
  def init_geometry; end
end

# This object represents an axis-aligned rectangle in a map projection
# coordinate system. It is commonly used to specify the viewport for a
# map visualization, an envelope in a projected coordinate system, or
# a spatial constraint. It must be attached to a Geographic::Factory
# that has a projection.
#
# source://rgeo//lib/rgeo/geographic/projected_window.rb#16
class RGeo::Geographic::ProjectedWindow
  # Create a new ProjectedWindow given the Geographic::Factory, and the
  # x and y extents of the rectangle.
  #
  # The window will be intelligently clamped to the limits imposed by
  # the factory. For example, the simple mercator factory limits
  # latitude to approximately +/-85 degrees.
  #
  # Generally, you will not need to call this low-level constructor
  # directly. Instead, use one of the provided class methods.
  #
  # @return [ProjectedWindow] a new instance of ProjectedWindow
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#27
  def initialize(factory_, x_min_, y_min_, x_max_, y_max_, opts_ = T.unsafe(nil)); end

  # Returns a new window resulting from scaling this window by the
  # given factors, which must be floating-point values.
  # If y_factor is not explicitly given, it defaults to the same as
  # the x_factor.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#238
  def *(x_factor_, y_factor_ = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#66
  def ==(other); end

  # Returns the center of the rectangle in _unprojected_
  # (lat/lng) space, as a Feature::Point object.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#178
  def center_point; end

  # Returns a two-element array containing the x and y coordinates
  # of the center of the rectangle.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#127
  def center_xy; end

  # Returns a new window resulting from clamping this window to the
  # given minimum and maximum widths and heights, in the projected
  # coordinate system. The center of the resulting window is the
  # same as the center of this window. Any of the arguments may be
  # given as nil, indicating no constraint.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#257
  def clamped_by(min_width_, min_height_, max_width_, max_height_); end

  # Returns true if the rectangle contains the given point, which
  # must be a Feature::Point in _unprojected_ (lat/lng) space.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#198
  def contains_point?(point_); end

  # Returns true if the given window is completely contained within
  # this window.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#220
  def contains_window?(window_); end

  # Returns true if the projection wraps along the x axis, and this
  # rectangle crosses that seam.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#98
  def crosses_seam?; end

  # Returns true if the rectangle has zero area.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#104
  def degenerate?; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#66
  def eql?(other); end

  # Returns the Geographic::Factory associated with this window.
  # Note that this factory is the overall geography factory, not the
  # projected factory (which can be obtained by calling
  # Geographic::Factory#projection_factory on this factory).
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#81
  def factory; end

  # source://rgeo//lib/rgeo/geographic/projected_window.rb#73
  def hash; end

  # Returns the height of the rectangle.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#119
  def height; end

  # source://rgeo//lib/rgeo/geographic/projected_window.rb#62
  def inspect; end

  # Returns the northeast corner of the rectangle in _unprojected_
  # (lat/lng) space, as a Feature::Point object.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#169
  def ne_point; end

  # Returns the northwest corner of the rectangle in _unprojected_
  # (lat/lng) space, as a Feature::Point object.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#160
  def nw_point; end

  # Returns a random point inside the rectangle in _unprojected_
  # (lat/lng) space, as a Feature::Point object.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#187
  def random_point; end

  # Returns a new window resulting from scaling this window by the
  # given factors, which must be floating-point values.
  # If y_factor is not explicitly given, it defaults to the same as
  # the x_factor.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#238
  def scaled_by(x_factor_, y_factor_ = T.unsafe(nil)); end

  # Returns the southeast corner of the rectangle in _unprojected_
  # (lat/lng) space, as a Feature::Point object.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#151
  def se_point; end

  # Returns the southwest corner of the rectangle in _unprojected_
  # (lat/lng) space, as a Feature::Point object.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#142
  def sw_point; end

  # source://rgeo//lib/rgeo/geographic/projected_window.rb#58
  def to_s; end

  # Returns the width of the rectangle.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#110
  def width; end

  # Returns a new window resulting from adding the given margin to
  # this window. If y_margin is not given, it defaults to the same
  # value as x_margin. Note that the margins may be negative to
  # indicate shrinking of the window.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#292
  def with_margin(x_margin_, y_margin_ = T.unsafe(nil)); end

  # Returns the upper limit in the x (easting) direction.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#87
  def x_max; end

  # Returns the lower limit in the x (easting) direction.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#84
  def x_min; end

  # Returns the width of the rectangle.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#110
  def x_span; end

  # Returns the upper limit in the y (northing) direction.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#93
  def y_max; end

  # Returns the lower limit in the y (northing) direction.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#90
  def y_min; end

  # Returns the height of the rectangle.
  #
  # source://rgeo//lib/rgeo/geographic/projected_window.rb#119
  def y_span; end

  class << self
    # Creates a new window that contains all of the given points.
    # which must be Feature::Point objects in unprojected (lat/lng)
    # space.
    #
    # source://rgeo//lib/rgeo/geographic/projected_window.rb#343
    def bounding_points(points_); end

    # Creates a new window whose coordinates are the given points,
    # which must be Feature::Point objects in unprojected (lat/lng)
    # space.
    #
    # source://rgeo//lib/rgeo/geographic/projected_window.rb#312
    def for_corners(sw_, ne_); end

    # Creates a new window that surrounds the given point with the
    # given margin. The point must be a Feature::Point object in
    # unprojected (lat/lng) space, while the margins are numbers in
    # projected space. The y_margin may be given as nil, in which
    # case it is set to the same as the x_margin.
    #
    # source://rgeo//lib/rgeo/geographic/projected_window.rb#325
    def surrounding_point(point_, x_margin_ = T.unsafe(nil), y_margin_ = T.unsafe(nil)); end
  end
end

# source://rgeo//lib/rgeo/geographic/projector.rb#11
class RGeo::Geographic::Projector
  # @return [Projector] a new instance of Projector
  #
  # source://rgeo//lib/rgeo/geographic/projector.rb#12
  def initialize(geography_factory, projection_factory); end

  # source://rgeo//lib/rgeo/geographic/projector.rb#36
  def limits_window; end

  # source://rgeo//lib/rgeo/geographic/projector.rb#22
  def project(geometry); end

  # Returns the value of attribute projection_factory.
  #
  # source://rgeo//lib/rgeo/geographic/projector.rb#30
  def projection_factory; end

  # source://rgeo//lib/rgeo/geographic/projector.rb#17
  def set_factories(geography_factory, projection_factory); end

  # source://rgeo//lib/rgeo/geographic/projector.rb#26
  def unproject(geometry); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/projector.rb#32
  def wraps?; end

  class << self
    # source://rgeo//lib/rgeo/geographic/projector.rb#41
    def create_from_existing_factory(geography_factory, projection_factory); end

    # source://rgeo//lib/rgeo/geographic/projector.rb#45
    def create_from_opts(geography_factory, opts = T.unsafe(nil)); end
  end
end

# source://rgeo//lib/rgeo/geographic/simple_mercator_projector.rb#11
class RGeo::Geographic::SimpleMercatorProjector
  # @return [SimpleMercatorProjector] a new instance of SimpleMercatorProjector
  #
  # source://rgeo//lib/rgeo/geographic/simple_mercator_projector.rb#14
  def initialize(geography_factory, opts = T.unsafe(nil)); end

  # source://rgeo//lib/rgeo/geographic/simple_mercator_projector.rb#94
  def limits_window; end

  # source://rgeo//lib/rgeo/geographic/simple_mercator_projector.rb#30
  def project(geometry); end

  # Returns the value of attribute projection_factory.
  #
  # source://rgeo//lib/rgeo/geographic/simple_mercator_projector.rb#28
  def projection_factory; end

  # source://rgeo//lib/rgeo/geographic/simple_mercator_projector.rb#23
  def set_factories(geography_factory, projection_factory); end

  # source://rgeo//lib/rgeo/geographic/simple_mercator_projector.rb#59
  def unproject(geometry); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/simple_mercator_projector.rb#90
  def wraps?; end

  class << self
    # source://rgeo//lib/rgeo/geographic/simple_mercator_projector.rb#107
    def _coordsys3857; end
  end
end

# source://rgeo//lib/rgeo/geographic/simple_mercator_projector.rb#12
RGeo::Geographic::SimpleMercatorProjector::EQUATORIAL_RADIUS = T.let(T.unsafe(nil), Float)

# source://rgeo//lib/rgeo/geographic/spherical_feature_classes.rb#63
class RGeo::Geographic::SphericalGeometryCollectionImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::ValidOp
  include ::RGeo::Geographic::SphericalGeometryMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def node(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def size(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#277
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#516
  def unsafe_buffer(_distance_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#410
  def unsafe_contains?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#529
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#372
  def unsafe_crosses?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def unsafe_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def unsafe_disjoint?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#501
  def unsafe_distance(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#182
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def unsafe_intersection(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#334
  def unsafe_intersects?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#86
  def unsafe_node; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def unsafe_overlaps?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#105
  def unsafe_point_on_surface; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#66
  def unsafe_size; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def unsafe_sym_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def unsafe_touches?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def unsafe_union(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def unsafe_within?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#11
module RGeo::Geographic::SphericalGeometryMethods
  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#16
  def coordinate_dimension; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#24
  def is_3d?; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#28
  def measured?; end

  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#20
  def spatial_dimension; end

  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#12
  def srid; end
end

# source://rgeo//lib/rgeo/geographic/spherical_feature_classes.rb#31
class RGeo::Geographic::SphericalLineImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::Line
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::BasicLineMethods
  include ::RGeo::ImplHelper::ValidOp
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::Geographic::SphericalLineStringMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def length(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def ring?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#50
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#516
  def unsafe_buffer(_distance_); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#90
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#529
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#154
  def unsafe_crosses?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def unsafe_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def unsafe_disjoint?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#501
  def unsafe_distance(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#182
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def unsafe_intersection(_another_geometry); end

  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#145
  def unsafe_intersects?(rhs); end

  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#141
  def unsafe_length; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def unsafe_overlaps?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#70
  def unsafe_ring?; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def unsafe_sym_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def unsafe_touches?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def unsafe_union(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def unsafe_within?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geographic/spherical_feature_classes.rb#21
class RGeo::Geographic::SphericalLineStringImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::ValidOp
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::Geographic::SphericalLineStringMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def length(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def ring?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#50
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#516
  def unsafe_buffer(_distance_); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#90
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#529
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#154
  def unsafe_crosses?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def unsafe_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def unsafe_disjoint?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#501
  def unsafe_distance(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#182
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def unsafe_intersection(_another_geometry); end

  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#145
  def unsafe_intersects?(rhs); end

  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#141
  def unsafe_length; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def unsafe_overlaps?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#70
  def unsafe_ring?; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def unsafe_sym_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def unsafe_touches?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def unsafe_union(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def unsafe_within?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#111
module RGeo::Geographic::SphericalLineStringMethods
  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#112
  def arcs; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#154
  def crosses?(rhs); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#145
  def intersects?(rhs); end

  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#141
  def length; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#118
  def simple?; end

  private

  # TODO: replace with better algorithm (https://github.com/rgeo/rgeo/issues/274)
  # Very simple algorithm to determine if 2 LineStrings cross.
  # Uses a nested for loop to look at each arc in the LineStrings and
  # check if each arc crosses.
  #
  # @param rhs [RGeo::Geographic::SphericalLineStringImpl]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#191
  def crosses_line_string?(rhs); end

  # TODO: replace with better algorithm (https://github.com/rgeo/rgeo/issues/274)
  # Very simple algorithm to determine if 2 LineStrings intersect.
  # Uses a nested for loop to look at each arc in the LineStrings and
  # check if each arc intersects.
  #
  # @param rhs [RGeo::Geographic::SphericalLineStringImpl]
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#173
  def intersects_line_string?(rhs); end
end

# source://rgeo//lib/rgeo/geographic/spherical_feature_classes.rb#42
class RGeo::Geographic::SphericalLinearRingImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::LinearRing
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::BasicLinearRingMethods
  include ::RGeo::ImplHelper::ValidOp
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::Geographic::SphericalLineStringMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def ccw?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def length(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def ring?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#50
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#516
  def unsafe_buffer(_distance_); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#163
  def unsafe_ccw?; end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#90
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#529
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#154
  def unsafe_crosses?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def unsafe_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def unsafe_disjoint?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#501
  def unsafe_distance(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#182
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def unsafe_intersection(_another_geometry); end

  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#145
  def unsafe_intersects?(rhs); end

  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#141
  def unsafe_length; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def unsafe_overlaps?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#70
  def unsafe_ring?; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def unsafe_sym_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def unsafe_touches?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def unsafe_union(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def unsafe_within?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geographic/spherical_math.rb#11
module RGeo::Geographic::SphericalMath; end

# Represents a finite arc on the sphere.
#
# source://rgeo//lib/rgeo/geographic/spherical_math.rb#124
class RGeo::Geographic::SphericalMath::ArcXYZ
  # @return [ArcXYZ] a new instance of ArcXYZ
  #
  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#127
  def initialize(start, stop); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#137
  def ==(other); end

  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#147
  def axis; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#152
  def contains_point?(obj); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#142
  def degenerate?; end

  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#125
  def e; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#137
  def eql?(other); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#159
  def intersects_arc?(obj); end

  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#173
  def length; end

  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#125
  def s; end

  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#133
  def to_s; end
end

# Represents a point on the unit sphere in (x,y,z) coordinates
# instead of lat-lon. This form is often faster, more convenient,
# and more numerically stable for certain computations.
#
# The coordinate system is a right-handed system where the z-axis
# goes through the north pole, the x-axis goes through the prime
# meridian, and the y-axis goes through +90 degrees longitude.
#
# This object is also used to represent a great circle, as its axis
# of rotation.
#
# source://rgeo//lib/rgeo/geographic/spherical_math.rb#25
class RGeo::Geographic::SphericalMath::PointXYZ
  # @return [PointXYZ] a new instance of PointXYZ
  #
  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#28
  def initialize(x, y, z); end

  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#66
  def %(other); end

  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#59
  def *(other); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#40
  def ==(other); end

  # Creates some point that is perpendicular to this point
  #
  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#95
  def create_perpendicular; end

  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#77
  def dist_to_point(rhs); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#40
  def eql?(other); end

  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#45
  def latlon; end

  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#52
  def lonlat; end

  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#36
  def to_s; end

  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#26
  def x; end

  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#26
  def y; end

  # source://rgeo//lib/rgeo/geographic/spherical_math.rb#26
  def z; end

  class << self
    # source://rgeo//lib/rgeo/geographic/spherical_math.rb#103
    def from_latlon(lat, lon); end

    # source://rgeo//lib/rgeo/geographic/spherical_math.rb#114
    def weighted_combination(pt1, wt1, pt2, wt2); end
  end
end

# source://rgeo//lib/rgeo/geographic/spherical_math.rb#118
RGeo::Geographic::SphericalMath::PointXYZ::P1 = T.let(T.unsafe(nil), RGeo::Geographic::SphericalMath::PointXYZ)

# source://rgeo//lib/rgeo/geographic/spherical_math.rb#119
RGeo::Geographic::SphericalMath::PointXYZ::P2 = T.let(T.unsafe(nil), RGeo::Geographic::SphericalMath::PointXYZ)

# source://rgeo//lib/rgeo/geographic/spherical_math.rb#12
RGeo::Geographic::SphericalMath::RADIUS = T.let(T.unsafe(nil), Float)

# source://rgeo//lib/rgeo/geographic/spherical_feature_classes.rb#82
class RGeo::Geographic::SphericalMultiLineStringImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiCurve
  include ::RGeo::Feature::MultiLineString
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiLineStringMethods
  include ::RGeo::ImplHelper::ValidOp
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::Geographic::SphericalMultiLineStringMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def length(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def node(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def size(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#101
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#516
  def unsafe_buffer(_distance_); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#120
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#529
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#372
  def unsafe_crosses?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def unsafe_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def unsafe_disjoint?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#501
  def unsafe_distance(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#182
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def unsafe_intersection(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#334
  def unsafe_intersects?(_another_geometry); end

  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#211
  def unsafe_length; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#86
  def unsafe_node; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def unsafe_overlaps?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#105
  def unsafe_point_on_surface; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#66
  def unsafe_size; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def unsafe_sym_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def unsafe_touches?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def unsafe_union(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def unsafe_within?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#210
module RGeo::Geographic::SphericalMultiLineStringMethods
  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#211
  def length; end
end

# source://rgeo//lib/rgeo/geographic/spherical_feature_classes.rb#72
class RGeo::Geographic::SphericalMultiPointImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiPoint
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiPointMethods
  include ::RGeo::ImplHelper::ValidOp
  include ::RGeo::Geographic::SphericalGeometryMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def node(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def size(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#149
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#516
  def unsafe_buffer(_distance_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#410
  def unsafe_contains?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#529
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#372
  def unsafe_crosses?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def unsafe_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def unsafe_disjoint?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#501
  def unsafe_distance(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#182
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def unsafe_intersection(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#334
  def unsafe_intersects?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#86
  def unsafe_node; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def unsafe_overlaps?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#105
  def unsafe_point_on_surface; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#66
  def unsafe_size; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def unsafe_sym_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def unsafe_touches?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def unsafe_union(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def unsafe_within?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geographic/spherical_feature_classes.rb#93
class RGeo::Geographic::SphericalMultiPolygonImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiSurface
  include ::RGeo::Feature::MultiPolygon
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiPolygonMethods
  include ::RGeo::ImplHelper::ValidOp
  include ::RGeo::Geographic::SphericalGeometryMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def area(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def centroid(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def node(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def size(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#173
  def unsafe_area; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#177
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#516
  def unsafe_buffer(_distance_); end

  # source://rgeo//lib/rgeo/feature/multi_surface.rb#57
  def unsafe_centroid; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#190
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#529
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#372
  def unsafe_crosses?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def unsafe_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def unsafe_disjoint?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#501
  def unsafe_distance(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#182
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def unsafe_intersection(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#334
  def unsafe_intersects?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#86
  def unsafe_node; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def unsafe_overlaps?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/multi_surface.rb#69
  def unsafe_point_on_surface; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/feature/geometry_collection.rb#66
  def unsafe_size; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def unsafe_sym_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def unsafe_touches?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def unsafe_union(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def unsafe_within?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geographic/spherical_feature_classes.rb#11
class RGeo::Geographic::SphericalPointImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Point
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicPointMethods
  include ::RGeo::ImplHelper::ValidOp
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::Geographic::SphericalPointMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def lat(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def latitude(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def lon(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def longitude(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#58
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#69
  def unsafe_buffer(distance); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#410
  def unsafe_contains?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#62
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#372
  def unsafe_crosses?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def unsafe_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def unsafe_disjoint?(_another_geometry); end

  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#38
  def unsafe_distance(rhs); end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#54
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def unsafe_intersection(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#334
  def unsafe_intersects?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#26
  def unsafe_lat; end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#26
  def unsafe_latitude; end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#22
  def unsafe_lon; end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#22
  def unsafe_longitude; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def unsafe_overlaps?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def unsafe_sym_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def unsafe_touches?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def unsafe_union(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def unsafe_within?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#33
module RGeo::Geographic::SphericalPointMethods
  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#69
  def buffer(distance); end

  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#38
  def distance(rhs); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#48
  def equals?(rhs); end

  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#34
  def xyz; end

  private

  # Ensure coordinates fall within a valid range.
  #
  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#100
  def init_geometry; end

  class << self
    # @private
    #
    # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#88
    def included(klass); end
  end
end

# source://rgeo//lib/rgeo/geographic/spherical_feature_classes.rb#53
class RGeo::Geographic::SphericalPolygonImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Surface
  include ::RGeo::Feature::Polygon
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicPolygonMethods
  include ::RGeo::ImplHelper::ValidOp
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::Geographic::SphericalPolygonMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def area(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def centroid(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def interior_ring_n(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#701
  def unsafe_add(other); end

  # source://rgeo//lib/rgeo/feature/surface.rb#50
  def unsafe_area; end

  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#52
  def unsafe_boundary; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#516
  def unsafe_buffer(_distance_); end

  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#217
  def unsafe_centroid; end

  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#78
  def unsafe_contains?(rhs); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#529
  def unsafe_convex_hull; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#372
  def unsafe_crosses?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#583
  def unsafe_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#315
  def unsafe_disjoint?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#501
  def unsafe_distance(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#182
  def unsafe_envelope; end

  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#32
  def unsafe_interior_ring_n(idx); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#547
  def unsafe_intersection(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#334
  def unsafe_intersects?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#710
  def unsafe_multiply(other); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#429
  def unsafe_overlaps?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/surface.rb#75
  def unsafe_point_on_surface; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#455
  def unsafe_relate?(_another_geometry, _intersection_pattern_matrix_); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#692
  def unsafe_remove(other); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#601
  def unsafe_sym_difference(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#353
  def unsafe_touches?(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#630
  def unsafe_unary_union; end

  # source://rgeo//lib/rgeo/feature/geometry.rb#565
  def unsafe_union(_another_geometry); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#391
  def unsafe_within?(_another_geometry); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#216
module RGeo::Geographic::SphericalPolygonMethods
  # source://rgeo//lib/rgeo/geographic/spherical_feature_methods.rb#217
  def centroid; end
end

# source://rgeo//lib/rgeo/geos.rb#23
module RGeo::Geos
  class << self
    # Returns true if the given feature is a CAPI GEOS feature, or if
    # the given factory is a CAPI GEOS factory.
    #
    # @return [Boolean]
    #
    # source://rgeo//lib/rgeo/geos/interface.rb#34
    def capi_geos?(object); end

    # Returns true if the CAPI GEOS implementation is supported.
    #
    # @return [Boolean]
    #
    # source://rgeo//lib/rgeo/geos/interface.rb#14
    def capi_supported?; end

    # Returns a factory for the GEOS implementation.
    # Returns nil if the GEOS implementation is not supported.
    #
    # Note that GEOS does not natively support 4-dimensional data
    # (i.e. both z and m values). However, RGeo's GEOS wrapper does
    # provide a 4-dimensional factory that utilizes an extra native
    # GEOS object to handle the extra coordinate. Hence, a factory
    # configured with both Z and M support will work, but will be
    # slower than a 2-dimensional or 3-dimensional factory.
    #
    # Options include:
    #
    # [<tt>:native_interface</tt>]
    #   Specifies which native interface to use. Possible values are
    #   <tt>:capi</tt> and <tt>:ffi</tt>. The default is the value
    #   of the preferred_native_interface.
    # [<tt>:buffer_resolution</tt>]
    #   The resolution of buffers around geometries created by this
    #   factory. This controls the number of line segments used to
    #   approximate curves. The default is 1, which causes, for
    #   example, the buffer around a point to be approximated by a
    #   4-sided polygon. A resolution of 2 would cause that buffer
    #   to be approximated by an 8-sided polygon. The exact behavior
    #   for different kinds of buffers is defined by GEOS.
    # [<tt>:srid</tt>]
    #   Set the SRID returned by geometries created by this factory.
    #   Default is 0.
    # [<tt>:coord_sys</tt>]
    #   The coordinate system in OGC form, either as a subclass of
    #   CoordSys::CS::CoordinateSystem, or as a string in WKT format.
    #   Optional. If not provided, but <tt>:srid</tt> is, a coord_sys
    #   will be created using the CS::CONFIG.default_coord_sys_class.
    #  [<tt>:coord_sys_class</tt>]
    #    The coordinate system implementation to use if you do not want to
    #    use the CS::CONFIG.default_coord_sys_class. Optional.
    # [<tt>:has_z_coordinate</tt>]
    #   Support <tt>z_coordinate</tt>. Default is false.
    # [<tt>:has_m_coordinate</tt>]
    #   Support <tt>m_coordinate</tt>. Default is false.
    # [<tt>:wkt_parser</tt>]
    #   Configure the parser for WKT. You may either pass a hash of
    #   configuration parameters for WKRep::WKTParser.new, or the
    #   special value <tt>:geos</tt>, indicating to use the native
    #   GEOS parser. Default is the empty hash, indicating the default
    #   configuration for WKRep::WKTParser.
    #   Note that the special <tt>:geos</tt> value is not supported for
    #   ZM factories, since GEOS currently can't handle ZM natively.
    # [<tt>:wkb_parser</tt>]
    #   Configure the parser for WKB. You may either pass a hash of
    #   configuration parameters for WKRep::WKBParser.new, or the
    #   special value <tt>:geos</tt>, indicating to use the native
    #   GEOS parser. Default is the empty hash, indicating the default
    #   configuration for WKRep::WKBParser.
    #   Note that the special <tt>:geos</tt> value is not supported for
    #   ZM factories, since GEOS currently can't handle ZM natively.
    # [<tt>:wkt_generator</tt>]
    #   Configure the generator for WKT. You may either pass a hash of
    #   configuration parameters for WKRep::WKTGenerator.new, or the
    #   special value <tt>:geos</tt>, indicating to use the native
    #   GEOS generator. Default is <tt>{:convert_case => :upper}</tt>.
    #   Note that the special <tt>:geos</tt> value is not supported for
    #   ZM factories, since GEOS currently can't handle ZM natively.
    # [<tt>:wkb_generator</tt>]
    #   Configure the generator for WKB. You may either pass a hash of
    #   configuration parameters for WKRep::WKBGenerator.new, or the
    #   special value <tt>:geos</tt>, indicating to use the native
    #   GEOS generator. Default is the empty hash, indicating the
    #   default configuration for WKRep::WKBGenerator.
    #   Note that the special <tt>:geos</tt> value is not supported for
    #   ZM factories, since GEOS currently can't handle ZM natively.
    # [<tt>:auto_prepare</tt>]
    #   Request an auto-prepare strategy. Supported values are
    #   <tt>:simple</tt> and <tt>:disabled</tt>. The former (which is
    #   the default) generates a prepared geometry the second time an
    #   operation that would benefit from it is called. The latter
    #   never automatically generates a prepared geometry (unless you
    #   generate one explicitly using the <tt>prepare!</tt> method).
    #
    # source://rgeo//lib/rgeo/geos/interface.rb#164
    def factory(opts = T.unsafe(nil)); end

    # Returns true if the given feature is an FFI GEOS feature, or if
    # the given factory is an FFI GEOS factory.
    #
    # @return [Boolean]
    #
    # source://rgeo//lib/rgeo/geos/interface.rb#44
    def ffi_geos?(object); end

    # Returns true if the FFI GEOS implementation is supported.
    #
    # @return [Boolean]
    #
    # source://rgeo//lib/rgeo/geos/interface.rb#20
    def ffi_supported?; end

    # Returns true if the given feature is a GEOS feature, or if the given
    # factory is a GEOS factory. Does not distinguish between CAPI and FFI.
    #
    # @return [Boolean]
    #
    # source://rgeo//lib/rgeo/geos/interface.rb#54
    def geos?(object); end

    # The preferred native interface. This is the native interface
    # used by default when a factory is created.
    # Supported values are <tt>:capi</tt> and <tt>:ffi</tt>.
    #
    # This is set automatically when RGeo loads, to <tt>:capi</tt>
    # if the CAPI interface is available, otheriwse to <tt>:ffi</tt>
    # if FFI is available, otherwise to nil if no GEOS interface is
    # available. You can override this setting if you want to prefer
    # FFI over CAPI.
    #
    # source://rgeo//lib/rgeo/geos/interface.rb#85
    def preferred_native_interface; end

    # The preferred native interface. This is the native interface
    # used by default when a factory is created.
    # Supported values are <tt>:capi</tt> and <tt>:ffi</tt>.
    #
    # This is set automatically when RGeo loads, to <tt>:capi</tt>
    # if the CAPI interface is available, otheriwse to <tt>:ffi</tt>
    # if FFI is available, otherwise to nil if no GEOS interface is
    # available. You can override this setting if you want to prefer
    # FFI over CAPI.
    #
    # source://rgeo//lib/rgeo/geos/interface.rb#85
    def preferred_native_interface=(_arg0); end

    # Returns true if any GEOS implementation is supported.
    # If this returns false, GEOS features are not available at all.
    #
    # @return [Boolean]
    #
    # source://rgeo//lib/rgeo/geos/interface.rb#27
    def supported?; end

    # Returns the GEOS library version as a string of the format "x.y.z".
    # Returns nil if GEOS is not available.
    #
    # source://rgeo//lib/rgeo/geos/interface.rb#63
    def version; end
  end
end

module RGeo::Geos::Analysis
  class << self
    def ccw?(_arg0); end
    def ccw_supported?; end
  end
end

# This the GEOS CAPI implementation of RGeo::Feature::Factory.
#
# source://rgeo//lib/rgeo/geos/capi_factory.rb#12
class RGeo::Geos::CAPIFactory
  include ::RGeo::Feature::Factory::Instance
  include ::RGeo::ImplHelper::Utils

  # Factory equivalence test.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#99
  def ==(other); end

  def _buffer_resolution; end
  def _coord_sys; end
  def _flags; end
  def _parse_wkb_impl(_arg0); end
  def _parse_wkt_impl(_arg0); end
  def _set_wkrep_parsers(_arg0, _arg1); end
  def _srid; end
  def _wkb_generator; end
  def _wkb_parser; end
  def _wkt_generator; end
  def _wkt_parser; end

  # source://rgeo//lib/rgeo/geos/capi_factory.rb#351
  def auto_prepare; end

  # Returns the resolution used by buffer calculations on geometries
  # created by this factory
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#199
  def buffer_resolution; end

  # See RGeo::Feature::Factory#collection
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#277
  def collection(elems_); end

  # See RGeo::Feature::Factory#coord_sys
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#306
  def coord_sys; end

  # Psych support
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#154
  def encode_with(coder_); end

  # Factory equivalence test.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#99
  def eql?(other); end

  # Standard hash code
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#108
  def hash; end

  # source://rgeo//lib/rgeo/geos/capi_factory.rb#170
  def init_with(coder_); end

  # Standard object inspection output
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#93
  def inspect; end

  # See RGeo::Feature::Factory#line
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#257
  def line(start_, end_); end

  # See RGeo::Feature::Factory#line_string
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#249
  def line_string(points_); end

  # See RGeo::Feature::Factory#linear_ring
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#263
  def linear_ring(points_); end

  # Marshal support
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#114
  def marshal_dump; end

  # source://rgeo//lib/rgeo/geos/capi_factory.rb#132
  def marshal_load(data_); end

  # See RGeo::Feature::Factory#multi_line_string
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#291
  def multi_line_string(elems_); end

  # See RGeo::Feature::Factory#multi_point
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#284
  def multi_point(elems_); end

  # See RGeo::Feature::Factory#multi_polygon
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#298
  def multi_polygon(elems_); end

  # See RGeo::Feature::Factory#override_cast
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#312
  def override_cast(original, ntype, flags); end

  # See RGeo::Feature::Factory#parse_wkb
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#231
  def parse_wkb(str_); end

  # See RGeo::Feature::Factory#parse_wkt
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#221
  def parse_wkt(str_); end

  # See RGeo::Feature::Factory#point
  #
  # @raise [RGeo::Error::InvalidGeometry]
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#241
  def point(x, y, *extra); end

  # See RGeo::Feature::Factory#polygon
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#270
  def polygon(outer_ring_, inner_rings_ = T.unsafe(nil)); end

  def prepare_heuristic?; end

  # See RGeo::Feature::Factory#property
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#204
  def property(name_); end

  def read_for_marshal(_arg0); end
  def read_for_psych(_arg0); end

  # Returns the SRID of geometries created by this factory.
  #
  # source://rgeo//lib/rgeo/geos/capi_factory.rb#192
  def srid; end

  def supports_m?; end
  def supports_z?; end
  def supports_z_or_m?; end
  def write_for_marshal(_arg0); end
  def write_for_psych(_arg0); end

  private

  def _create(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5); end
  def _geos_version; end
  def _supports_unary_union?; end
  def initialize_copy(_arg0); end

  class << self
    def _create(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5); end
    def _geos_version; end
    def _supports_unary_union?; end

    # Create a new factory. Returns nil if the GEOS CAPI implementation
    # is not supported.
    #
    # See RGeo::Geos.factory for a list of supported options.
    #
    # source://rgeo//lib/rgeo/geos/capi_factory.rb#22
    def create(opts = T.unsafe(nil)); end

    # Create a new factory. Returns nil if the GEOS CAPI implementation
    # is not supported.
    #
    # See RGeo::Geos.factory for a list of supported options.
    #
    # source://rgeo//lib/rgeo/geos/capi_factory.rb#22
    def new(opts = T.unsafe(nil)); end
  end
end

RGeo::Geos::CAPIFactory::FLAG_PREPARE_HEURISTIC = T.let(T.unsafe(nil), Integer)
RGeo::Geos::CAPIFactory::FLAG_SUPPORTS_M = T.let(T.unsafe(nil), Integer)
RGeo::Geos::CAPIFactory::FLAG_SUPPORTS_Z = T.let(T.unsafe(nil), Integer)
RGeo::Geos::CAPIFactory::FLAG_SUPPORTS_Z_OR_M = T.let(T.unsafe(nil), Integer)

# :stopdoc:
#
# source://rgeo//lib/rgeo/geos/capi_factory.rb#357
RGeo::Geos::CAPIFactory::IMPL_CLASSES = T.let(T.unsafe(nil), Hash)

# source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#125
class RGeo::Geos::CAPIGeometryCollectionImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::CAPIGeometryMethods
  include ::RGeo::Geos::CAPIGeometryCollectionMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def node(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def size(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  def unsafe_add(_arg0); end
  def unsafe_boundary; end
  def unsafe_buffer(_arg0); end
  def unsafe_contains?(_arg0); end
  def unsafe_convex_hull; end
  def unsafe_crosses?(_arg0); end
  def unsafe_difference(_arg0); end
  def unsafe_disjoint?(_arg0); end
  def unsafe_distance(_arg0); end
  def unsafe_envelope; end
  def unsafe_intersection(_arg0); end
  def unsafe_intersects?(_arg0); end
  def unsafe_multiply(_arg0); end
  def unsafe_node; end
  def unsafe_overlaps?(_arg0); end
  def unsafe_point_on_surface; end
  def unsafe_relate?(_arg0, _arg1); end
  def unsafe_remove(_arg0); end
  def unsafe_size; end
  def unsafe_sym_difference(_arg0); end
  def unsafe_touches?(_arg0); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  def unsafe_unary_union; end
  def unsafe_union(_arg0); end
  def unsafe_within?(_arg0); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end

  private

  def create(_arg0, _arg1); end

  class << self
    def create(_arg0, _arg1); end
  end
end

# source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#74
module RGeo::Geos::CAPIGeometryCollectionMethods
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder

  def [](_arg0); end
  def each; end
  def eql?(_arg0); end
  def geometry_n(_arg0); end
  def geometry_type; end
  def hash; end
  def node; end
  def num_geometries; end
  def rep_equals?(_arg0); end
  def size; end
end

# source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#78
class RGeo::Geos::CAPIGeometryImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::CAPIGeometryMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  def unsafe_add(_arg0); end
  def unsafe_boundary; end
  def unsafe_buffer(_arg0); end
  def unsafe_contains?(_arg0); end
  def unsafe_convex_hull; end
  def unsafe_crosses?(_arg0); end
  def unsafe_difference(_arg0); end
  def unsafe_disjoint?(_arg0); end
  def unsafe_distance(_arg0); end
  def unsafe_envelope; end
  def unsafe_intersection(_arg0); end
  def unsafe_intersects?(_arg0); end
  def unsafe_multiply(_arg0); end
  def unsafe_overlaps?(_arg0); end
  def unsafe_relate?(_arg0, _arg1); end
  def unsafe_remove(_arg0); end
  def unsafe_sym_difference(_arg0); end
  def unsafe_touches?(_arg0); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  def unsafe_unary_union; end
  def unsafe_union(_arg0); end
  def unsafe_within?(_arg0); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end
end

# source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#13
module RGeo::Geos::CAPIGeometryMethods
  include ::RGeo::Feature::Instance

  def *(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def ==(_arg0); end
  def _as_text; end
  def _steal(_arg0); end
  def as_binary; end

  # source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#66
  def as_text; end

  def boundary; end
  def buffer(_arg0); end
  def buffer_with_style(_arg0, _arg1, _arg2, _arg3); end
  def contains?(_arg0); end
  def convex_hull; end

  # source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#16
  def coordinate_dimension; end

  def crosses?(_arg0); end
  def difference(_arg0); end
  def dimension; end
  def disjoint?(_arg0); end
  def distance(_arg0); end
  def empty?; end

  # Psych support
  #
  # source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#53
  def encode_with(coder); end

  def envelope; end
  def eql?(_arg0); end
  def equals?(_arg0); end
  def factory; end
  def factory=(_arg0); end
  def geometry_type; end

  # source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#61
  def init_with(coder); end

  def initialized?; end

  # source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#35
  def inspect; end

  def intersection(_arg0); end
  def intersects?(_arg0); end
  def invalid_reason; end
  def invalid_reason_location; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#27
  def is_3d?; end

  def make_valid; end

  # Marshal support
  #
  # source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#41
  def marshal_dump; end

  # source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#46
  def marshal_load(data_); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#31
  def measured?; end

  def overlaps?(_arg0); end
  def point_on_surface; end
  def polygonize; end
  def prepare!; end
  def prepared?; end
  def relate?(_arg0, _arg1); end
  def rep_equals?(_arg0); end
  def segmentize(_arg0); end
  def simple?; end
  def simplify(_arg0); end
  def simplify_preserve_topology(_arg0); end

  # source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#23
  def spatial_dimension; end

  def srid; end
  def sym_difference(_arg0); end

  # source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#66
  def to_s; end

  def touches?(_arg0); end
  def unary_union; end
  def union(_arg0); end
  def valid?; end
  def within?(_arg0); end

  private

  def initialize_copy(_arg0); end
end

# source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#110
class RGeo::Geos::CAPILineImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::Line
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::CAPIGeometryMethods
  include ::RGeo::Geos::CAPILineStringMethods
  include ::RGeo::Geos::CAPILineMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def length(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def ring?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  def unsafe_add(_arg0); end
  def unsafe_boundary; end
  def unsafe_buffer(_arg0); end
  def unsafe_contains?(_arg0); end
  def unsafe_convex_hull; end
  def unsafe_crosses?(_arg0); end
  def unsafe_difference(_arg0); end
  def unsafe_disjoint?(_arg0); end
  def unsafe_distance(_arg0); end
  def unsafe_envelope; end
  def unsafe_intersection(_arg0); end
  def unsafe_intersects?(_arg0); end
  def unsafe_length; end
  def unsafe_multiply(_arg0); end
  def unsafe_overlaps?(_arg0); end
  def unsafe_relate?(_arg0, _arg1); end
  def unsafe_remove(_arg0); end
  def unsafe_ring?; end
  def unsafe_sym_difference(_arg0); end
  def unsafe_touches?(_arg0); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  def unsafe_unary_union; end
  def unsafe_union(_arg0); end
  def unsafe_within?(_arg0); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end

  private

  def _copy_from(_arg0, _arg1); end
  def create(_arg0, _arg1, _arg2); end

  class << self
    def _copy_from(_arg0, _arg1); end
    def create(_arg0, _arg1, _arg2); end
  end
end

module RGeo::Geos::CAPILineMethods
  def geometry_type; end
  def hash; end
end

# source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#91
class RGeo::Geos::CAPILineStringImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::CAPIGeometryMethods
  include ::RGeo::Geos::CAPILineStringMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def length(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def ring?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  def unsafe_add(_arg0); end
  def unsafe_boundary; end
  def unsafe_buffer(_arg0); end
  def unsafe_contains?(_arg0); end
  def unsafe_convex_hull; end
  def unsafe_crosses?(_arg0); end
  def unsafe_difference(_arg0); end
  def unsafe_disjoint?(_arg0); end
  def unsafe_distance(_arg0); end
  def unsafe_envelope; end
  def unsafe_intersection(_arg0); end
  def unsafe_intersects?(_arg0); end
  def unsafe_length; end
  def unsafe_multiply(_arg0); end
  def unsafe_overlaps?(_arg0); end
  def unsafe_relate?(_arg0, _arg1); end
  def unsafe_remove(_arg0); end
  def unsafe_ring?; end
  def unsafe_sym_difference(_arg0); end
  def unsafe_touches?(_arg0); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  def unsafe_unary_union; end
  def unsafe_union(_arg0); end
  def unsafe_within?(_arg0); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end

  private

  def _copy_from(_arg0, _arg1); end
  def create(_arg0, _arg1); end

  class << self
    def _copy_from(_arg0, _arg1); end
    def create(_arg0, _arg1); end
  end
end

module RGeo::Geos::CAPILineStringMethods
  def closed?; end
  def coordinates; end
  def end_point; end
  def eql?(_arg0); end
  def geometry_type; end
  def hash; end
  def interpolate_point(_arg0); end
  def length; end
  def num_points; end
  def point_n(_arg0); end
  def points; end
  def project_point(_arg0); end
  def rep_equals?(_arg0); end
  def ring?; end
  def start_point; end
end

# source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#98
class RGeo::Geos::CAPILinearRingImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::LinearRing
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::CAPIGeometryMethods
  include ::RGeo::Geos::CAPILineStringMethods
  include ::RGeo::Geos::CAPILinearRingMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def ccw?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def length(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def ring?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  def unsafe_add(_arg0); end
  def unsafe_boundary; end
  def unsafe_buffer(_arg0); end

  # source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#105
  def unsafe_ccw?; end

  def unsafe_contains?(_arg0); end
  def unsafe_convex_hull; end
  def unsafe_crosses?(_arg0); end
  def unsafe_difference(_arg0); end
  def unsafe_disjoint?(_arg0); end
  def unsafe_distance(_arg0); end
  def unsafe_envelope; end
  def unsafe_intersection(_arg0); end
  def unsafe_intersects?(_arg0); end
  def unsafe_length; end
  def unsafe_multiply(_arg0); end
  def unsafe_overlaps?(_arg0); end
  def unsafe_relate?(_arg0, _arg1); end
  def unsafe_remove(_arg0); end
  def unsafe_ring?; end
  def unsafe_sym_difference(_arg0); end
  def unsafe_touches?(_arg0); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  def unsafe_unary_union; end
  def unsafe_union(_arg0); end
  def unsafe_within?(_arg0); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end

  private

  def _copy_from(_arg0, _arg1); end
  def create(_arg0, _arg1); end

  class << self
    def _copy_from(_arg0, _arg1); end
    def create(_arg0, _arg1); end
  end
end

module RGeo::Geos::CAPILinearRingMethods
  def geometry_type; end
  def hash; end
end

# source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#140
class RGeo::Geos::CAPIMultiLineStringImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiCurve
  include ::RGeo::Feature::MultiLineString
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::CAPIGeometryMethods
  include ::RGeo::Geos::CAPIGeometryCollectionMethods
  include ::RGeo::Geos::CAPIMultiLineStringMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def length(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def node(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def size(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  def unsafe_add(_arg0); end
  def unsafe_boundary; end
  def unsafe_buffer(_arg0); end
  def unsafe_contains?(_arg0); end
  def unsafe_convex_hull; end
  def unsafe_crosses?(_arg0); end
  def unsafe_difference(_arg0); end
  def unsafe_disjoint?(_arg0); end
  def unsafe_distance(_arg0); end
  def unsafe_envelope; end
  def unsafe_intersection(_arg0); end
  def unsafe_intersects?(_arg0); end
  def unsafe_length; end
  def unsafe_multiply(_arg0); end
  def unsafe_node; end
  def unsafe_overlaps?(_arg0); end
  def unsafe_point_on_surface; end
  def unsafe_relate?(_arg0, _arg1); end
  def unsafe_remove(_arg0); end
  def unsafe_size; end
  def unsafe_sym_difference(_arg0); end
  def unsafe_touches?(_arg0); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  def unsafe_unary_union; end
  def unsafe_union(_arg0); end
  def unsafe_within?(_arg0); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end

  private

  def create(_arg0, _arg1); end

  class << self
    def create(_arg0, _arg1); end
  end
end

module RGeo::Geos::CAPIMultiLineStringMethods
  def closed?; end
  def coordinates; end
  def geometry_type; end
  def hash; end
  def length; end
end

# source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#132
class RGeo::Geos::CAPIMultiPointImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiPoint
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::CAPIGeometryMethods
  include ::RGeo::Geos::CAPIGeometryCollectionMethods
  include ::RGeo::Geos::CAPIMultiPointMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def node(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def size(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  def unsafe_add(_arg0); end
  def unsafe_boundary; end
  def unsafe_buffer(_arg0); end
  def unsafe_contains?(_arg0); end
  def unsafe_convex_hull; end
  def unsafe_crosses?(_arg0); end
  def unsafe_difference(_arg0); end
  def unsafe_disjoint?(_arg0); end
  def unsafe_distance(_arg0); end
  def unsafe_envelope; end
  def unsafe_intersection(_arg0); end
  def unsafe_intersects?(_arg0); end
  def unsafe_multiply(_arg0); end
  def unsafe_node; end
  def unsafe_overlaps?(_arg0); end
  def unsafe_point_on_surface; end
  def unsafe_relate?(_arg0, _arg1); end
  def unsafe_remove(_arg0); end
  def unsafe_size; end
  def unsafe_sym_difference(_arg0); end
  def unsafe_touches?(_arg0); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  def unsafe_unary_union; end
  def unsafe_union(_arg0); end
  def unsafe_within?(_arg0); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end

  private

  def create(_arg0, _arg1); end

  class << self
    def create(_arg0, _arg1); end
  end
end

module RGeo::Geos::CAPIMultiPointMethods
  def coordinates; end
  def geometry_type; end
  def hash; end
end

# source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#148
class RGeo::Geos::CAPIMultiPolygonImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiSurface
  include ::RGeo::Feature::MultiPolygon
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::CAPIGeometryMethods
  include ::RGeo::Geos::CAPIGeometryCollectionMethods
  include ::RGeo::Geos::CAPIMultiPolygonMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def area(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def centroid(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def node(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def size(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  def unsafe_add(_arg0); end
  def unsafe_area; end
  def unsafe_boundary; end
  def unsafe_buffer(_arg0); end
  def unsafe_centroid; end
  def unsafe_contains?(_arg0); end
  def unsafe_convex_hull; end
  def unsafe_crosses?(_arg0); end
  def unsafe_difference(_arg0); end
  def unsafe_disjoint?(_arg0); end
  def unsafe_distance(_arg0); end
  def unsafe_envelope; end
  def unsafe_intersection(_arg0); end
  def unsafe_intersects?(_arg0); end
  def unsafe_multiply(_arg0); end
  def unsafe_node; end
  def unsafe_overlaps?(_arg0); end
  def unsafe_point_on_surface; end
  def unsafe_relate?(_arg0, _arg1); end
  def unsafe_remove(_arg0); end
  def unsafe_size; end
  def unsafe_sym_difference(_arg0); end
  def unsafe_touches?(_arg0); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  def unsafe_unary_union; end
  def unsafe_union(_arg0); end
  def unsafe_within?(_arg0); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end

  private

  def create(_arg0, _arg1); end

  class << self
    def create(_arg0, _arg1); end
  end
end

module RGeo::Geos::CAPIMultiPolygonMethods
  def area; end
  def centroid; end
  def coordinates; end
  def geometry_type; end
  def hash; end
end

# source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#84
class RGeo::Geos::CAPIPointImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Point
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::CAPIGeometryMethods
  include ::RGeo::Geos::CAPIPointMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  def unsafe_add(_arg0); end
  def unsafe_boundary; end
  def unsafe_buffer(_arg0); end
  def unsafe_contains?(_arg0); end
  def unsafe_convex_hull; end
  def unsafe_crosses?(_arg0); end
  def unsafe_difference(_arg0); end
  def unsafe_disjoint?(_arg0); end
  def unsafe_distance(_arg0); end
  def unsafe_envelope; end
  def unsafe_intersection(_arg0); end
  def unsafe_intersects?(_arg0); end
  def unsafe_multiply(_arg0); end
  def unsafe_overlaps?(_arg0); end
  def unsafe_relate?(_arg0, _arg1); end
  def unsafe_remove(_arg0); end
  def unsafe_sym_difference(_arg0); end
  def unsafe_touches?(_arg0); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  def unsafe_unary_union; end
  def unsafe_union(_arg0); end
  def unsafe_within?(_arg0); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end

  private

  def create(_arg0, _arg1, _arg2, _arg3); end

  class << self
    def create(_arg0, _arg1, _arg2, _arg3); end
  end
end

module RGeo::Geos::CAPIPointMethods
  def coordinates; end
  def eql?(_arg0); end
  def geometry_type; end
  def hash; end
  def m; end
  def rep_equals?(_arg0); end
  def x; end
  def y; end
  def z; end
end

# source://rgeo//lib/rgeo/geos/capi_feature_classes.rb#118
class RGeo::Geos::CAPIPolygonImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Surface
  include ::RGeo::Feature::Polygon
  include ::RGeo::ImplHelper::ValidityCheck
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::CAPIGeometryMethods
  include ::RGeo::Geos::CAPIPolygonMethods

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def *(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def +(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def -(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def area(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def boundary(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def buffer(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def centroid(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def contains?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def convex_hull(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def crosses?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def disjoint?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def distance(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def envelope(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def interior_ring_n(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersection(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def intersects?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def overlaps?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def point_on_surface(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def relate?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def sym_difference(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def touches?(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def transform(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def unary_union(*args); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def union(*args); end

  def unsafe_add(_arg0); end
  def unsafe_area; end
  def unsafe_boundary; end
  def unsafe_buffer(_arg0); end
  def unsafe_centroid; end
  def unsafe_contains?(_arg0); end
  def unsafe_convex_hull; end
  def unsafe_crosses?(_arg0); end
  def unsafe_difference(_arg0); end
  def unsafe_disjoint?(_arg0); end
  def unsafe_distance(_arg0); end
  def unsafe_envelope; end
  def unsafe_interior_ring_n(_arg0); end
  def unsafe_intersection(_arg0); end
  def unsafe_intersects?(_arg0); end
  def unsafe_multiply(_arg0); end
  def unsafe_overlaps?(_arg0); end
  def unsafe_point_on_surface; end
  def unsafe_relate?(_arg0, _arg1); end
  def unsafe_remove(_arg0); end
  def unsafe_sym_difference(_arg0); end
  def unsafe_touches?(_arg0); end

  # source://rgeo//lib/rgeo/feature/geometry.rb#722
  def unsafe_transform(other_factory); end

  def unsafe_unary_union; end
  def unsafe_union(_arg0); end
  def unsafe_within?(_arg0); end

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#77
  def within?(*args); end

  private

  def create(_arg0, _arg1, _arg2); end

  class << self
    def create(_arg0, _arg1, _arg2); end
  end
end

module RGeo::Geos::CAPIPolygonMethods
  def area; end
  def centroid; end
  def coordinates; end
  def eql?(_arg0); end
  def exterior_ring; end
  def geometry_type; end
  def hash; end
  def interior_ring_n(_arg0); end
  def interior_rings; end
  def num_interior_rings; end
  def point_on_surface; end
  def rep_equals?(_arg0); end
end

# continue
#
# source://rgeo//lib/rgeo/geos.rb#31
RGeo::Geos::CAPI_SUPPORTED = T.let(T.unsafe(nil), TrueClass)

# source://rgeo//lib/rgeo/geos.rb#67
RGeo::Geos::CAP_FLAT = T.let(T.unsafe(nil), Integer)

# source://rgeo//lib/rgeo/geos.rb#66
RGeo::Geos::CAP_ROUND = T.let(T.unsafe(nil), Integer)

# source://rgeo//lib/rgeo/geos.rb#68
RGeo::Geos::CAP_SQUARE = T.let(T.unsafe(nil), Integer)

# source://rgeo//lib/rgeo/geos.rb#49
RGeo::Geos::FFI_SUPPORTED = T.let(T.unsafe(nil), FalseClass)

# source://rgeo//lib/rgeo/geos.rb#50
RGeo::Geos::FFI_SUPPORT_EXCEPTION = T.let(T.unsafe(nil), LoadError)

# source://rgeo//lib/rgeo/geos.rb#72
RGeo::Geos::JOIN_BEVEL = T.let(T.unsafe(nil), Integer)

# source://rgeo//lib/rgeo/geos.rb#71
RGeo::Geos::JOIN_MITRE = T.let(T.unsafe(nil), Integer)

# source://rgeo//lib/rgeo/geos.rb#70
RGeo::Geos::JOIN_ROUND = T.let(T.unsafe(nil), Integer)

# source://rgeo//lib/rgeo/geos/utils.rb#11
module RGeo::Geos::Utils
  class << self
    # source://rgeo//lib/rgeo/geos/utils.rb#28
    def ffi_compute_dimension(geom); end

    # source://rgeo//lib/rgeo/geos/utils.rb#52
    def ffi_coord_seq_hash(coord_seq, init_hash = T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://rgeo//lib/rgeo/geos/utils.rb#13
    def ffi_coord_seqs_equal?(cs1, cs2, check_z); end

    # source://rgeo//lib/rgeo/geos/utils.rb#58
    def ffi_supports_prepared_level1; end

    # source://rgeo//lib/rgeo/geos/utils.rb#62
    def ffi_supports_prepared_level2; end

    # source://rgeo//lib/rgeo/geos/utils.rb#66
    def ffi_supports_set_output_dimension; end

    # source://rgeo//lib/rgeo/geos/utils.rb#70
    def ffi_supports_unary_union; end

    # source://rgeo//lib/rgeo/geos/utils.rb#78
    def marshal_wkb_generator; end

    # source://rgeo//lib/rgeo/geos/utils.rb#74
    def psych_wkt_generator; end
  end
end

# A factory for Geos that handles both Z and M.
#
# source://rgeo//lib/rgeo/geos/zm_factory.rb#12
class RGeo::Geos::ZMFactory
  include ::RGeo::Feature::Factory::Instance
  include ::RGeo::ImplHelper::Utils

  # @return [ZMFactory] a new instance of ZMFactory
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#42
  def initialize(opts = T.unsafe(nil)); end

  # Factory equivalence test.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#195
  def ==(other); end

  # Returns the resolution used by buffer calculations on geometries
  # created by this factory
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#177
  def buffer_resolution; end

  # See RGeo::Feature::Factory#collection
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#267
  def collection(elems); end

  # See RGeo::Feature::Factory#coord_sys
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#291
  def coord_sys; end

  # source://rgeo//lib/rgeo/geos/zm_factory.rb#328
  def create_feature(klass, zgeometry, mgeometry); end

  # Psych support
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#134
  def encode_with(coder); end

  # Factory equivalence test.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#195
  def eql?(other); end

  # Standard hash code
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#202
  def hash; end

  # source://rgeo//lib/rgeo/geos/zm_factory.rb#149
  def init_with(coder); end

  # See RGeo::Feature::Factory#line
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#245
  def line(start, stop); end

  # See RGeo::Feature::Factory#line_string
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#239
  def line_string(points); end

  # See RGeo::Feature::Factory#linear_ring
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#251
  def linear_ring(points); end

  # Returns the m-only factory corresponding to this factory.
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#189
  def m_factory; end

  # Marshal support
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#97
  def marshal_dump; end

  # source://rgeo//lib/rgeo/geos/zm_factory.rb#113
  def marshal_load(data); end

  # source://rgeo//lib/rgeo/geos/zm_factory.rb#333
  def marshal_wkb_generator; end

  # source://rgeo//lib/rgeo/geos/zm_factory.rb#337
  def marshal_wkb_parser; end

  # See RGeo::Feature::Factory#multi_line_string
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#279
  def multi_line_string(elems); end

  # See RGeo::Feature::Factory#multi_point
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#273
  def multi_point(elems); end

  # See RGeo::Feature::Factory#multi_polygon
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#285
  def multi_polygon(elems); end

  # See RGeo::Feature::Factory#override_cast
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#297
  def override_cast(original, ntype, flags); end

  # See RGeo::Feature::Factory#parse_wkb
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#223
  def parse_wkb(str); end

  # See RGeo::Feature::Factory#parse_wkt
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#217
  def parse_wkt(str); end

  # See RGeo::Feature::Factory#point
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#229
  def point(x, y, z = T.unsafe(nil), m = T.unsafe(nil)); end

  # See RGeo::Feature::Factory#polygon
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#257
  def polygon(outer_ring, inner_rings = T.unsafe(nil)); end

  # See RGeo::Feature::Factory#property
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#208
  def property(name); end

  # source://rgeo//lib/rgeo/geos/zm_factory.rb#341
  def psych_wkt_generator; end

  # source://rgeo//lib/rgeo/geos/zm_factory.rb#345
  def psych_wkt_parser; end

  # Returns the SRID of geometries created by this factory.
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#170
  def srid; end

  # Returns the z-only factory corresponding to this factory.
  #
  # source://rgeo//lib/rgeo/geos/zm_factory.rb#183
  def z_factory; end

  class << self
    # Create a new factory. Returns nil if the GEOS implementation is
    # not supported.
    #
    # source://rgeo//lib/rgeo/geos/zm_factory.rb#36
    def create(opts = T.unsafe(nil)); end
  end
end

# :stopdoc:
#
# source://rgeo//lib/rgeo/geos/zm_factory.rb#18
RGeo::Geos::ZMFactory::TYPE_KLASSES = T.let(T.unsafe(nil), Hash)

# source://rgeo//lib/rgeo/geos/zm_feature_classes.rb#36
class RGeo::Geos::ZMGeometryCollectionImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::ZMGeometryCollectionMethods
end

# source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#318
module RGeo::Geos::ZMGeometryCollectionMethods
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#324
  def [](idx); end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#329
  def each; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#324
  def geometry_n(idx); end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#319
  def num_geometries; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#319
  def size; end
end

# source://rgeo//lib/rgeo/geos/zm_feature_classes.rb#58
class RGeo::Geos::ZMGeometryImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
end

# source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#11
module RGeo::Geos::ZMGeometryMethods
  include ::RGeo::Feature::Instance

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#14
  def initialize(factory, zgeometry, mgeometry); end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#144
  def *(rhs); end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#149
  def +(rhs); end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#154
  def -(rhs); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#96
  def ==(rhs); end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#72
  def as_binary; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#68
  def as_text; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#92
  def boundary; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#136
  def buffer(distance_); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#120
  def contains?(rhs); end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#140
  def convex_hull; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#48
  def coordinate_dimension; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#112
  def crosses?(rhs); end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#154
  def difference(rhs); end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#44
  def dimension; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#100
  def disjoint?(rhs); end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#132
  def distance(rhs); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#76
  def empty?; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#191
  def encode_with(coder); end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#64
  def envelope; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#168
  def eql?(rhs); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#96
  def equals?(rhs); end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#32
  def factory; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#56
  def geometry_type; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#28
  def hash; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#196
  def init_with(coder); end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#20
  def inspect; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#144
  def intersection(rhs); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#104
  def intersects?(rhs); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#84
  def is_3d?; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#40
  def m_geometry; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#183
  def marshal_dump; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#187
  def marshal_load(data); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#88
  def measured?; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#124
  def overlaps?(rhs); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#128
  def relate?(rhs, pattern); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#168
  def rep_equals?(rhs); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#80
  def simple?; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#52
  def spatial_dimension; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#60
  def srid; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#159
  def sym_difference(rhs); end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#24
  def to_s; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#108
  def touches?(rhs); end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#149
  def union(rhs); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#116
  def within?(rhs); end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#36
  def z_geometry; end

  private

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#202
  def copy_state_from(obj); end
end

# source://rgeo//lib/rgeo/geos/zm_feature_classes.rb#26
class RGeo::Geos::ZMLineImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::RGeo::Geos::ZMLineStringMethods
end

# source://rgeo//lib/rgeo/geos/zm_feature_classes.rb#16
class RGeo::Geos::ZMLineStringImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::RGeo::Geos::ZMLineStringMethods
end

# source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#234
module RGeo::Geos::ZMLineStringMethods
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#247
  def closed?; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#273
  def coordinates; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#243
  def end_point; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#235
  def length; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#255
  def num_points; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#259
  def point_n(idx); end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#263
  def points; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#251
  def ring?; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#239
  def start_point; end
end

# source://rgeo//lib/rgeo/geos/zm_feature_classes.rb#21
class RGeo::Geos::ZMLinearRingImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::RGeo::Geos::ZMLineStringMethods
end

# source://rgeo//lib/rgeo/geos/zm_feature_classes.rb#46
class RGeo::Geos::ZMMultiLineStringImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::ZMGeometryCollectionMethods
  include ::RGeo::Geos::ZMMultiLineStringMethods
end

# source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#343
module RGeo::Geos::ZMMultiLineStringMethods
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#348
  def closed?; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#352
  def coordinates; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#344
  def length; end
end

# source://rgeo//lib/rgeo/geos/zm_feature_classes.rb#41
class RGeo::Geos::ZMMultiPointImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::ZMGeometryCollectionMethods
end

# source://rgeo//lib/rgeo/geos/zm_feature_classes.rb#52
class RGeo::Geos::ZMMultiPolygonImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::ZMGeometryCollectionMethods
  include ::RGeo::Geos::ZMMultiPolygonMethods
end

# source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#357
module RGeo::Geos::ZMMultiPolygonMethods
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#358
  def area; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#362
  def centroid; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#370
  def coordinates; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#366
  def point_on_surface; end
end

# source://rgeo//lib/rgeo/geos/zm_feature_classes.rb#11
class RGeo::Geos::ZMPointImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::RGeo::Geos::ZMPointMethods
end

# source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#209
module RGeo::Geos::ZMPointMethods
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#226
  def coordinates; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#222
  def m; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#210
  def x; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#214
  def y; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#218
  def z; end
end

# source://rgeo//lib/rgeo/geos/zm_feature_classes.rb#31
class RGeo::Geos::ZMPolygonImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::RGeo::Geos::ZMPolygonMethods
end

# source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#278
module RGeo::Geos::ZMPolygonMethods
  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#279
  def area; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#283
  def centroid; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#313
  def coordinates; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#291
  def exterior_ring; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#299
  def interior_ring_n(idx); end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#303
  def interior_rings; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#295
  def num_interior_rings; end

  # source://rgeo//lib/rgeo/geos/zm_feature_methods.rb#287
  def point_on_surface; end
end

# source://rgeo//lib/rgeo/impl_helper/utils.rb#10
module RGeo::ImplHelper; end

# source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#11
module RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#16
  def initialize(factory, elements); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#34
  def [](idx); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#46
  def dimension; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#38
  def each(&block); end

  # Returns the value of attribute elements.
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#14
  def elements; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#54
  def empty?; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#42
  def geometries; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#30
  def geometry_n(idx); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#50
  def geometry_type; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#66
  def hash; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#26
  def num_geometries; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#58
  def rep_equals?(rhs); end

  private

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#72
  def copy_state_from(obj); end
end

# source://rgeo//lib/rgeo/impl_helper/basic_geometry_methods.rb#11
module RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::Feature::Instance

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_methods.rb#28
  def as_binary; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_methods.rb#24
  def as_text; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_methods.rb#40
  def encode_with(coder); end

  # Returns the value of attribute factory.
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_methods.rb#14
  def factory; end

  # Sets the attribute factory
  #
  # @param value the value to set the attribute factory to.
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_methods.rb#14
  def factory=(_arg0); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_methods.rb#45
  def init_with(coder); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_methods.rb#16
  def inspect; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_methods.rb#32
  def marshal_dump; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_methods.rb#36
  def marshal_load(data); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_methods.rb#20
  def to_s; end

  private

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_methods.rb#51
  def copy_state_from(obj); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_methods.rb#55
  def init_geometry; end
end

# source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#133
module RGeo::ImplHelper::BasicLineMethods
  # @raise [Error::InvalidGeometry]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#134
  def initialize(factory, start, stop); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#148
  def coordinates; end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#144
  def geometry_type; end
end

# source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#11
module RGeo::ImplHelper::BasicLineStringMethods
  # @raise [Error::InvalidGeometry]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#12
  def initialize(factory, points); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#50
  def boundary; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#64
  def closed?; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#90
  def contains?(rhs); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#86
  def coordinates; end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#38
  def dimension; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#46
  def empty?; end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#60
  def end_point; end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#42
  def geometry_type; end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#82
  def hash; end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#26
  def num_points; end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#30
  def point_n(idx); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#34
  def points; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#74
  def rep_equals?(rhs); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#70
  def ring?; end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#56
  def start_point; end

  private

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#122
  def between_coordinate?(coord, start_coord, end_coord); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#101
  def contains_point?(point); end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#127
  def copy_state_from(obj); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#118
  def point_collinear?(pt1, pt2, pt3); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#108
  def point_intersect_segment?(point, start_point, end_point); end
end

# source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#153
module RGeo::ImplHelper::BasicLinearRingMethods
  # @raise [Error::InvalidGeometry]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#154
  def initialize(factory, points); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#163
  def ccw?; end

  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#159
  def geometry_type; end

  private

  # Close ring if necessary.
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_line_string_methods.rb#170
  def init_geometry; end
end

# source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#78
module RGeo::ImplHelper::BasicMultiLineStringMethods
  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#79
  def initialize(factory, elements); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#101
  def boundary; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#93
  def closed?; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#120
  def contains?(rhs); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#116
  def coordinates; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#89
  def geometry_type; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#97
  def length; end

  private

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#128
  def add_boundary(hash, point); end
end

# source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#134
module RGeo::ImplHelper::BasicMultiPointMethods
  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#135
  def initialize(factory, elements); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#149
  def boundary; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#153
  def coordinates; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#145
  def geometry_type; end
end

# source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#158
module RGeo::ImplHelper::BasicMultiPolygonMethods
  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#159
  def initialize(factory, elements); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#173
  def area; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#177
  def boundary; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#190
  def contains?(rhs); end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#186
  def coordinates; end

  # source://rgeo//lib/rgeo/impl_helper/basic_geometry_collection_methods.rb#169
  def geometry_type; end
end

# source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#11
module RGeo::ImplHelper::BasicPointMethods
  # @raise [ArgumentError]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#12
  def initialize(factory, x, y, *extra); end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#58
  def boundary; end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#62
  def convex_hull; end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#88
  def coordinates; end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#38
  def dimension; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#46
  def empty?; end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#54
  def envelope; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#66
  def equals?(rhs); end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#42
  def geometry_type; end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#84
  def hash; end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#34
  def m; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#80
  def rep_equals?(rhs); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#50
  def simple?; end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#22
  def x; end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#26
  def y; end

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#30
  def z; end

  private

  # source://rgeo//lib/rgeo/impl_helper/basic_point_methods.rb#97
  def copy_state_from(obj); end
end

# source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#11
module RGeo::ImplHelper::BasicPolygonMethods
  # @raise [Error::InvalidGeometry]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#12
  def initialize(factory, exterior_ring, interior_rings); end

  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#52
  def boundary; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#78
  def contains?(rhs); end

  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#74
  def coordinates; end

  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#40
  def dimension; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#48
  def empty?; end

  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#24
  def exterior_ring; end

  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#44
  def geometry_type; end

  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#70
  def hash; end

  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#32
  def interior_ring_n(idx); end

  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#36
  def interior_rings; end

  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#28
  def num_interior_rings; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#59
  def rep_equals?(rhs); end

  private

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#91
  def contains_point?(point); end

  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#117
  def copy_state_from(obj); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/impl_helper/basic_polygon_methods.rb#98
  def ring_encloses_point?(ring, point, on_border_return: T.unsafe(nil)); end
end

# source://rgeo//lib/rgeo/impl_helper/math.rb#11
module RGeo::ImplHelper::Math; end

# source://rgeo//lib/rgeo/impl_helper/math.rb#13
RGeo::ImplHelper::Math::DEGREES_PER_RADIAN = T.let(T.unsafe(nil), Float)

# source://rgeo//lib/rgeo/impl_helper/math.rb#12
RGeo::ImplHelper::Math::RADIANS_PER_DEGREE = T.let(T.unsafe(nil), Float)

# source://rgeo//lib/rgeo/impl_helper/utils.rb#11
module RGeo::ImplHelper::Utils
  private

  # source://rgeo//lib/rgeo/impl_helper/utils.rb#35
  def symbolize_hash(hash); end

  class << self
    # Helper function to create coord_sys from
    # common options in most factories. Returns
    # a hash with finalized coord sys info after processing.
    #
    # The reason we return the data as a hash instead of assigning
    # instance variables is because some classes need to do this
    # multiple times with different values and others pass the data
    # to a CAPI or FFI.
    #
    # source://rgeo//lib/rgeo/impl_helper/utils.rb#20
    def setup_coord_sys(srid, coord_sys, coord_sys_class); end
  end
end

# Mixin based off of the JTS/GEOS IsValidOp class.
# Implements #valid? and #invalid_reason on Features that include this.
#
# @see https://github.com/locationtech/jts/blob/master/modules/core/src/main/java/org/locationtech/jts/operation/valid/IsValidOp.java
#
# source://rgeo//lib/rgeo/impl_helper/valid_op.rb#11
module RGeo::ImplHelper::ValidOp
  # Reason for invalidity or nil if valid
  #
  # @return String
  #
  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#22
  def invalid_reason; end

  # Validity of geometry
  #
  # @return [Boolean] Boolean
  #
  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#15
  def valid?; end

  private

  # Method that performs validity checking. Just checks the type of geometry
  # and delegates to the proper validity checker.
  #
  # Returns a string describing the error or nil if it's a valid geometry.
  # In some cases, "Unkown Validity" is returned if a dependent method has
  # not been implemented.
  #
  # @return String
  #
  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#41
  def check_valid; end

  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#167
  def check_valid_geometry_collection; end

  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#68
  def check_valid_line_string; end

  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#81
  def check_valid_linear_ring; end

  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#144
  def check_valid_multi_point; end

  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#152
  def check_valid_multi_polygon; end

  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#64
  def check_valid_point; end

  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#98
  def check_valid_polygon; end

  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#29
  def validity_helper; end
end

# Helper functions for specific validity checks
#
# source://rgeo//lib/rgeo/impl_helper/valid_op.rb#179
module RGeo::ImplHelper::ValidOpHelpers
  private

  # Checks that the interior of the polygon is connected.
  # A disconnected interior can be described by this polygon for example
  # POLYGON((0 0, 10 0, 10 10, 0 10, 0 0), (5 0, 10 5, 5 10, 0 5, 5 0))
  #
  # Which is a square with a diamond inside of it.
  #
  # @param poly [RGeo::Feature::Polygon]
  # @return [String] invalid_reason
  #
  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#304
  def check_connected_interiors(poly); end

  # Checks that the edges in the polygon form a consistent area.
  #
  # Specifically, checks that there are intersections no between the
  # holes and the shell.
  #
  # Also checks that there are no duplicate rings.
  #
  # @param poly [RGeo::Feature::Polygon]
  # @return [String] invalid_reason
  #
  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#205
  def check_consistent_area(poly); end

  # Checks that polygons do not intersect in a multipolygon.
  #
  # @param mpoly [RGeo::Feature::MultiPolygon]
  # @return [String] invalid_reason
  #
  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#326
  def check_consistent_area_mp(mpoly); end

  # Checks holes are contained inside the exterior of a polygon.
  # Assuming check_consistent_area has already passed on the polygon,
  # a simple point in polygon check can be done on one of the points
  # in each hole to verify (since we know none of them intersect).
  #
  # @param poly [RGeo::Feature::Polygon]
  # @return [String] invalid_reason
  #
  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#261
  def check_holes_in_shell(poly); end

  # Checks that holes are not nested within each other.
  #
  # @param poly [RGeo::Feature::Polygon]
  # @return [String] invalid_reason
  #
  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#279
  def check_holes_not_nested(poly); end

  # Checks that the given point has valid coordinates.
  #
  # @param point [RGeo::Feature::Point]
  # @return [String] invalid_reason
  #
  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#187
  def check_invalid_coordinate(point); end

  # Check that rings do not self intersect in a polygon
  #
  # @param poly [RGeo::Feature::Polygon]
  # @return [String] invalid_reason
  #
  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#239
  def check_no_self_intersecting_rings(poly); end

  # Checks that the ring does not self-intersect. This is just a simplicity
  # check on the ring.
  #
  # @param ring [RGeo::Feature::LinearRing]
  # @return [String] invalid_reason
  #
  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#230
  def check_no_self_intersections(ring); end

  # Checks that individual polygons within a multipolygon are not nested.
  #
  # @param mpoly [RGeo::Feature::MultiPolygon]
  # @return [String] invalid_reason
  #
  # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#338
  def check_shells_not_nested(mpoly); end

  class << self
    # Checks that the interior of the polygon is connected.
    # A disconnected interior can be described by this polygon for example
    # POLYGON((0 0, 10 0, 10 10, 0 10, 0 0), (5 0, 10 5, 5 10, 0 5, 5 0))
    #
    # Which is a square with a diamond inside of it.
    #
    # @param poly [RGeo::Feature::Polygon]
    # @return [String] invalid_reason
    #
    # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#304
    def check_connected_interiors(poly); end

    # Checks that the edges in the polygon form a consistent area.
    #
    # Specifically, checks that there are intersections no between the
    # holes and the shell.
    #
    # Also checks that there are no duplicate rings.
    #
    # @param poly [RGeo::Feature::Polygon]
    # @return [String] invalid_reason
    #
    # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#205
    def check_consistent_area(poly); end

    # Checks that polygons do not intersect in a multipolygon.
    #
    # @param mpoly [RGeo::Feature::MultiPolygon]
    # @return [String] invalid_reason
    #
    # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#326
    def check_consistent_area_mp(mpoly); end

    # Checks holes are contained inside the exterior of a polygon.
    # Assuming check_consistent_area has already passed on the polygon,
    # a simple point in polygon check can be done on one of the points
    # in each hole to verify (since we know none of them intersect).
    #
    # @param poly [RGeo::Feature::Polygon]
    # @return [String] invalid_reason
    #
    # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#261
    def check_holes_in_shell(poly); end

    # Checks that holes are not nested within each other.
    #
    # @param poly [RGeo::Feature::Polygon]
    # @return [String] invalid_reason
    #
    # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#279
    def check_holes_not_nested(poly); end

    # Checks that the given point has valid coordinates.
    #
    # @param point [RGeo::Feature::Point]
    # @return [String] invalid_reason
    #
    # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#187
    def check_invalid_coordinate(point); end

    # Check that rings do not self intersect in a polygon
    #
    # @param poly [RGeo::Feature::Polygon]
    # @return [String] invalid_reason
    #
    # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#239
    def check_no_self_intersecting_rings(poly); end

    # Checks that the ring does not self-intersect. This is just a simplicity
    # check on the ring.
    #
    # @param ring [RGeo::Feature::LinearRing]
    # @return [String] invalid_reason
    #
    # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#230
    def check_no_self_intersections(ring); end

    # Checks that individual polygons within a multipolygon are not nested.
    #
    # @param mpoly [RGeo::Feature::MultiPolygon]
    # @return [String] invalid_reason
    #
    # source://rgeo//lib/rgeo/impl_helper/valid_op.rb#338
    def check_shells_not_nested(mpoly); end
  end
end

# This helper enforces valid geometry computation, avoiding results such
# as a 0 area for a bowtie shaped polygon. Implementations that are part
# of RGeo core should all include this.
#
# You can play around validity checks if needed:
#
# - {check_validity!} is the method that will raise if your geometry is
#   not valid. Its message will be the same as {invalid_reason}.
# - {make_valid} is the method you can call to get a valid copy of the
#   current geometry.
# - finally, you can bypass any checked method by prepending `unsafe_` to
#   it. At your own risk.
#
# source://rgeo//lib/rgeo/impl_helper/validity_check.rb#17
module RGeo::ImplHelper::ValidityCheck
  # Raises {invalid_reason} if the polygon is not valid, does nothing
  # otherwise.
  #
  # @raise [Error::InvalidGeometry]
  #
  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#100
  def check_validity!; end

  # Tell why the geometry is not valid, `nil` means it is valid.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#109
  def invalid_reason; end

  # Try and make the geometry valid, this may change its shape.
  # Returns a valid copy of the geometry.
  #
  # @raise [Error::UnsupportedOperation]
  #
  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#120
  def make_valid; end

  private

  # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#131
  def invalid_reason_memo; end

  class << self
    # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#59
    def included(klass); end

    # Note for contributors: this should be called after all methods
    # are loaded for a given feature classe. No worries though, this
    # is tested.
    #
    # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#52
    def override_classes; end

    private

    # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#65
    def classes; end

    # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#88
    def feature_methods(klass); end

    # source://rgeo//lib/rgeo/impl_helper/validity_check.rb#69
    def override(klass); end
  end
end

# Since methods have their unsafe_ counter part, it means that the `+`
# method would lead to having an `unsafe_+` method that is not simply
# callable. Here's a simple fallback:
#
# source://rgeo//lib/rgeo/impl_helper/validity_check.rb#41
RGeo::ImplHelper::ValidityCheck::SYMBOL2NAME = T.let(T.unsafe(nil), Hash)

# Every method that should not be overriden by the validity check.
# Those methods are either accessors or very basic methods not related
# to validity checks, or are used to check validity, in which case the
# `true/false` gives a correct information, no need to raise).
#
# source://rgeo//lib/rgeo/impl_helper/validity_check.rb#22
RGeo::ImplHelper::ValidityCheck::UNCHECKED_METHODS = T.let(T.unsafe(nil), Array)

# source://rgeo//lib/rgeo/version.rb#4
RGeo::VERSION = T.let(T.unsafe(nil), String)

# source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#12
module RGeo::WKRep; end

# This class provides the functionality of serializing a geometry as
# WKB (well-known binary) format. You may also customize the
# serializer to generate PostGIS EWKB extensions to the output, or to
# follow the Simple Features Specification 1.2 extensions for Z and M
# coordinates.
#
# To use this class, create an instance with the desired settings and
# customizations, and call the generate method.
#
# === Configuration options
#
# The following options are recognized. These can be passed to the
# constructor, or set on the object afterwards.
#
# [<tt>:type_format</tt>]
#   The format for type codes. Possible values are <tt>:wkb11</tt>,
#   indicating SFS 1.1 WKB (i.e. no Z or M values); <tt>:ewkb</tt>,
#   indicating the PostGIS EWKB extensions (i.e. Z and M presence
#   flagged by the two high bits of the type code, and support for
#   embedded SRID); or <tt>:wkb12</tt> (indicating SFS 1.2 WKB
#   (i.e. Z and M presence flagged by adding 1000 and/or 2000 to
#   the type code.) Default is <tt>:wkb11</tt>.
# [<tt>:emit_ewkb_srid</tt>]
#   If true, embed the SRID in the toplevel geometry. Available only
#   if <tt>:type_format</tt> is <tt>:ewkb</tt>. Default is false.
# [<tt>:hex_format</tt>]
#   If true, output a hex string instead of a byte string.
#   Default is false.
# [<tt>:little_endian</tt>]
#   If true, output little endian (NDR) byte order. If false, output
#   big endian (XDR), or network byte order. Default is false.
#
# source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#42
class RGeo::WKRep::WKBGenerator
  # Create and configure a WKB generator. See the WKBGenerator
  # documentation for the options that can be passed.
  #
  # @return [WKBGenerator] a new instance of WKBGenerator
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#60
  def initialize(opts = T.unsafe(nil)); end

  # Returns whether SRID is embedded. See WKBGenerator for details.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#71
  def emit_ewkb_srid?; end

  # Generate and return the WKB format for the given geometry object,
  # according to the current settings.
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#99
  def generate(obj); end

  # Returns whether output is converted to hex.
  # See WKBGenerator for details.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#77
  def hex_format?; end

  # Returns whether output is little-endian (NDR).
  # See WKBGenerator for details.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#83
  def little_endian?; end

  # source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#87
  def properties; end

  # Returns the format for type codes. See WKBGenerator for details.
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#68
  def type_format; end

  private

  # source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#141
  def emit_byte(value, rval); end

  # source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#149
  def emit_doubles(array, rval); end

  # source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#145
  def emit_integer(value, rval); end

  # source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#153
  def emit_line_string_coords(obj, rval); end

  # @raise [Error::ParseError]
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#168
  def generate_feature(obj, rval, toplevel: T.unsafe(nil)); end

  # source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#160
  def point_coords(obj, rval, array = T.unsafe(nil)); end
end

# source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#115
class RGeo::WKRep::WKBGenerator::Result
  # @return [Result] a new instance of Result
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#116
  def initialize(has_z, has_m); end

  # source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#122
  def <<(data); end

  # source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#126
  def emit(hex_format); end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#135
  def m?; end

  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#131
  def z?; end
end

# :stopdoc:
#
# source://rgeo//lib/rgeo/wkrep/wkb_generator.rb#44
RGeo::WKRep::WKBGenerator::TYPE_CODES = T.let(T.unsafe(nil), Hash)

# This class provides the functionality of parsing a geometry from
# WKB (well-known binary) format. You may also customize the parser
# to recognize PostGIS EWKB extensions to the input, or Simple
# Features Specification 1.2 extensions for Z and M coordinates.
#
# To use this class, create an instance with the desired settings and
# customizations, and call the parse method.
#
# === Configuration options
#
# You must provide each parser with an RGeo::Feature::FactoryGenerator.
# It should understand the configuration options <tt>:srid</tt>,
# <tt>:has_z_coordinate</tt>, and <tt>:has_m_coordinate</tt>.
# You may also pass a specific RGeo::Feature::Factory, or nil to
# specify the default Cartesian FactoryGenerator.
#
# The following additional options are recognized. These can be passed
# to the constructor, or set on the object afterwards.
#
# [<tt>:support_ewkb</tt>]
#   Activate support for PostGIS EWKB type codes, which use high
#   order bits in the type code to signal the presence of Z, M, and
#   SRID values in the data. Default is false.
# [<tt>:support_wkb12</tt>]
#   Activate support for SFS 1.2 extensions to the type codes, which
#   use values greater than 1000 to signal the presence of Z and M
#   values in the data. SFS 1.2 types such as triangle, tin, and
#   polyhedralsurface are NOT yet supported. Default is false.
# [<tt>:ignore_extra_bytes</tt>]
#   If true, extra bytes at the end of the data are ignored. If
#   false (the default), extra bytes will trigger a parse error.
# [<tt>:default_srid</tt>]
#   A SRID to pass to the factory generator if no SRID is present in
#   the input. Defaults to nil (i.e. don't specify a SRID).
#
# source://rgeo//lib/rgeo/wkrep/wkb_parser.rb#45
class RGeo::WKRep::WKBParser
  # Create and configure a WKB parser. See the WKBParser
  # documentation for the options that can be passed.
  #
  # @return [WKBParser] a new instance of WKBParser
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_parser.rb#49
  def initialize(factory_generator = T.unsafe(nil), opts = T.unsafe(nil)); end

  # If this parser was given an exact factory, returns it; otherwise
  # returns nil.
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_parser.rb#72
  def exact_factory; end

  # Returns the factory generator. See WKBParser for details.
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_parser.rb#68
  def factory_generator; end

  # Returns true if this parser ignores extra bytes.
  # See WKBParser for details.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_parser.rb#88
  def ignore_extra_bytes?; end

  # Parse the given binary data or hexadecimal string, and return a
  # geometry object.
  #
  # The #parse_hex method is a synonym, present for historical
  # reasons but deprecated. Use #parse instead.
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_parser.rb#107
  def parse(data); end

  # Parse the given binary data or hexadecimal string, and return a
  # geometry object.
  #
  # The #parse_hex method is a synonym, present for historical
  # reasons but deprecated. Use #parse instead.
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_parser.rb#107
  def parse_hex(data); end

  # source://rgeo//lib/rgeo/wkrep/wkb_parser.rb#92
  def properties; end

  # Returns true if this parser supports EWKB.
  # See WKBParser for details.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_parser.rb#76
  def support_ewkb?; end

  # Returns true if this parser supports SFS 1.2 extensions.
  # See WKBParser for details.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_parser.rb#82
  def support_wkb12?; end

  private

  # @raise [Error::ParseError]
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_parser.rb#230
  def byte; end

  # source://rgeo//lib/rgeo/wkrep/wkb_parser.rb#226
  def bytes_remaining; end

  # @raise [Error::ParseError]
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_parser.rb#244
  def get_doubles(little_endian, count); end

  # @raise [Error::ParseError]
  #
  # source://rgeo//lib/rgeo/wkrep/wkb_parser.rb#237
  def get_integer(little_endian); end

  # source://rgeo//lib/rgeo/wkrep/wkb_parser.rb#214
  def parse_line_string(little_endian); end

  # source://rgeo//lib/rgeo/wkrep/wkb_parser.rb#132
  def parse_object(contained); end

  # source://rgeo//lib/rgeo/wkrep/wkb_parser.rb#220
  def start_scanner(data); end
end

# This class provides the functionality of serializing a geometry as
# WKT (well-known text) format. You may also customize the serializer
# to generate PostGIS EWKT extensions to the output, or to follow the
# Simple Features Specification 1.2 extensions for Z and M.
#
# To use this class, create an instance with the desired settings and
# customizations, and call the generate method.
#
# === Configuration options
#
# The following options are recognized. These can be passed to the
# constructor, or set on the object afterwards.
#
# [<tt>:tag_format</tt>]
#   The format for tags. Possible values are <tt>:wkt11</tt>,
#   indicating SFS 1.1 WKT (i.e. no Z or M markers in the tags) but
#   with Z and/or M values added in if they are present;
#   <tt>:wkt11_strict</tt>, indicating SFS 1.1 WKT with Z and M
#   dropped from the output (since WKT strictly does not support
#   the Z or M dimensions); <tt>:ewkt</tt>, indicating the PostGIS
#   EWKT extensions (i.e. "M" appended to tag names if M but not
#   Z is present); or <tt>:wkt12</tt>, indicating SFS 1.2 WKT
#   tags that indicate the presence of Z and M in a separate token.
#   Default is <tt>:wkt11</tt>.
#   This option can also be specified as <tt>:type_format</tt>.
# [<tt>:emit_ewkt_srid</tt>]
#   If true, embed the SRID of the toplevel geometry. Available only
#   if <tt>:tag_format</tt> is <tt>:ewkt</tt>. Default is false.
# [<tt>:square_brackets</tt>]
#   If true, uses square brackets rather than parentheses.
#   Default is false.
# [<tt>:convert_case</tt>]
#   Possible values are <tt>:upper</tt>, which changes all letters
#   in the output to ALL CAPS; <tt>:lower</tt>, which changes all
#   letters to lower case; or nil, indicating no case changes from
#   the default (which is not specified exactly, but is chosen by the
#   generator to emphasize readability.) Default is nil.
#
# source://rgeo//lib/rgeo/wkrep/wkt_generator.rb#48
class RGeo::WKRep::WKTGenerator
  # Create and configure a WKT generator. See the WKTGenerator
  # documentation for the options that can be passed.
  #
  # @return [WKTGenerator] a new instance of WKTGenerator
  #
  # source://rgeo//lib/rgeo/wkrep/wkt_generator.rb#52
  def initialize(opts = T.unsafe(nil)); end

  # Returns the case for output. See WKTGenerator for details.
  #
  # source://rgeo//lib/rgeo/wkrep/wkt_generator.rb#78
  def convert_case; end

  # Returns whether SRID is embedded. See WKTGenerator for details.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/wkrep/wkt_generator.rb#67
  def emit_ewkt_srid?; end

  # Generate and return the WKT format for the given geometry object,
  # according to the current settings.
  #
  # source://rgeo//lib/rgeo/wkrep/wkt_generator.rb#92
  def generate(obj); end

  # source://rgeo//lib/rgeo/wkrep/wkt_generator.rb#80
  def properties; end

  # Returns whether square brackets rather than parens are output.
  # See WKTGenerator for details.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/wkrep/wkt_generator.rb#73
  def square_brackets?; end

  # Returns the format for type tags. See WKTGenerator for details.
  #
  # source://rgeo//lib/rgeo/wkrep/wkt_generator.rb#63
  def tag_format; end

  # Returns the format for type tags. See WKTGenerator for details.
  #
  # source://rgeo//lib/rgeo/wkrep/wkt_generator.rb#63
  def type_format; end

  private

  # source://rgeo//lib/rgeo/wkrep/wkt_generator.rb#155
  def generate_coords(obj, support_z, support_m); end

  # source://rgeo//lib/rgeo/wkrep/wkt_generator.rb#116
  def generate_feature(obj, support_z, support_m, toplevel: T.unsafe(nil)); end

  # source://rgeo//lib/rgeo/wkrep/wkt_generator.rb#185
  def generate_geometry_collection(obj, support_z, support_m); end

  # source://rgeo//lib/rgeo/wkrep/wkt_generator.rb#166
  def generate_line_string(obj, support_z, support_m); end

  # source://rgeo//lib/rgeo/wkrep/wkt_generator.rb#201
  def generate_multi_line_string(obj, support_z, support_m); end

  # source://rgeo//lib/rgeo/wkrep/wkt_generator.rb#193
  def generate_multi_point(obj, support_z, support_m); end

  # source://rgeo//lib/rgeo/wkrep/wkt_generator.rb#209
  def generate_multi_polygon(obj, support_z, support_m); end

  # source://rgeo//lib/rgeo/wkrep/wkt_generator.rb#162
  def generate_point(obj, support_z, support_m); end

  # source://rgeo//lib/rgeo/wkrep/wkt_generator.rb#175
  def generate_polygon(obj, support_z, support_m); end
end

# This class provides the functionality of parsing a geometry from
# WKT (well-known text) format. You may also customize the parser
# to recognize PostGIS EWKT extensions to the input, or Simple
# Features Specification 1.2 extensions for Z and M coordinates.
#
# To use this class, create an instance with the desired settings and
# customizations, and call the parse method.
#
# === Configuration options
#
# You must provide each parser with an RGeo::Feature::FactoryGenerator.
# It should understand the configuration options <tt>:srid</tt>,
# <tt>:has_z_coordinate</tt>, and <tt>:has_m_coordinate</tt>.
# You may also pass a specific RGeo::Feature::Factory, or nil to
# specify the default Cartesian FactoryGenerator.
#
# The following additional options are recognized. These can be passed
# to the constructor, or set on the object afterwards.
#
# [<tt>:support_ewkt</tt>]
#   Activate support for PostGIS EWKT type tags, which appends an "M"
#   to tags to indicate the presence of M but not Z, and also
#   recognizes the SRID prefix. Default is false.
# [<tt>:support_wkt12</tt>]
#   Activate support for SFS 1.2 extensions to the type codes, which
#   use a "M", "Z", or "ZM" token to signal the presence of Z and M
#   values in the data. SFS 1.2 types such as triangle, tin, and
#   polyhedralsurface are NOT yet supported. Default is false.
# [<tt>:strict_wkt11</tt>]
#   If true, parsing will proceed in SFS 1.1 strict mode, which
#   disallows any values other than X or Y. This has no effect if
#   support_ewkt or support_wkt12 are active. Default is false.
# [<tt>:ignore_extra_tokens</tt>]
#   If true, extra tokens at the end of the data are ignored. If
#   false (the default), extra tokens will trigger a parse error.
# [<tt>:default_srid</tt>]
#   A SRID to pass to the factory generator if no SRID is present in
#   the input. Defaults to nil (i.e. don't specify a SRID).
#
# source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#51
class RGeo::WKRep::WKTParser
  # Create and configure a WKT parser. See the WKTParser
  # documentation for the options that can be passed.
  #
  # @return [WKTParser] a new instance of WKTParser
  #
  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#55
  def initialize(factory_generator = T.unsafe(nil), opts = T.unsafe(nil)); end

  # If this parser was given an exact factory, returns it; otherwise
  # returns nil.
  #
  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#84
  def exact_factory; end

  # Returns the factory generator. See WKTParser for details.
  #
  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#80
  def factory_generator; end

  # Returns true if this parser ignores extra tokens.
  # See WKTParser for details.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#106
  def ignore_extra_tokens?; end

  # Parse the given string, and return a geometry object.
  #
  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#122
  def parse(str); end

  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#110
  def properties; end

  # Returns true if this parser strictly adheres to WKT 1.1.
  # See WKTParser for details.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#100
  def strict_wkt11?; end

  # Returns true if this parser supports EWKT.
  # See WKTParser for details.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#88
  def support_ewkt?; end

  # Returns true if this parser supports SFS 1.2 extensions.
  # See WKTParser for details.
  #
  # @return [Boolean]
  #
  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#94
  def support_wkt12?; end

  private

  # @raise [Error::ParseError]
  #
  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#153
  def check_factory_support; end

  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#399
  def clean_scanner; end

  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#163
  def ensure_factory; end

  # @raise [Error::ParseError]
  #
  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#404
  def expect_token_type(type); end

  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#408
  def next_token; end

  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#233
  def parse_coords; end

  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#324
  def parse_geometry_collection; end

  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#289
  def parse_line_string; end

  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#362
  def parse_multi_line_string; end

  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#340
  def parse_multi_point; end

  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#378
  def parse_multi_polygon; end

  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#276
  def parse_point(convert_empty: T.unsafe(nil)); end

  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#305
  def parse_polygon; end

  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#177
  def parse_type_tag; end

  # source://rgeo//lib/rgeo/wkrep/wkt_parser.rb#394
  def start_scanner(str); end
end
