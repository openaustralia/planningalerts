# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mini_racer` gem.
# Please instead update this file by running `bin/tapioca gem mini_racer`.

# source://mini_racer//lib/mini_racer/version.rb#3
module MiniRacer; end

# eval is defined in the C class
#
# source://mini_racer//lib/mini_racer.rb#116
class MiniRacer::Context
  # @return [Context] a new instance of Context
  #
  # source://mini_racer//lib/mini_racer.rb#151
  def initialize(max_memory: T.unsafe(nil), timeout: T.unsafe(nil), isolate: T.unsafe(nil), ensure_gc_after_idle: T.unsafe(nil), snapshot: T.unsafe(nil), marshal_stack_depth: T.unsafe(nil)); end

  # @raise [ContextDisposedError]
  #
  # source://mini_racer//lib/mini_racer.rb#261
  def attach(name, callback); end

  # source://mini_racer//lib/mini_racer.rb#236
  def call(function_name, *arguments); end

  # source://mini_racer//lib/mini_racer.rb#250
  def dispose; end

  def dispose_unsafe; end

  # source://mini_racer//lib/mini_racer.rb#219
  def eval(str, options = T.unsafe(nil)); end

  def heap_stats; end

  # source://mini_racer//lib/mini_racer.rb#186
  def isolate; end

  # source://mini_racer//lib/mini_racer.rb#192
  def load(filename); end

  def stop; end

  # source://mini_racer//lib/mini_racer.rb#197
  def write_heap_snapshot(file_or_io); end

  def write_heap_snapshot_unsafe(_arg0); end

  private

  # source://mini_racer//lib/mini_racer.rb#402
  def assert_numeric_or_nil(option_name, object, min_value:, max_value: T.unsafe(nil)); end

  # source://mini_racer//lib/mini_racer.rb#416
  def assert_option_is_nil_or_a(option_name, object, klass); end

  def call_unsafe(*_arg0); end

  # source://mini_racer//lib/mini_racer.rb#388
  def check_init_options!(isolate:, snapshot:, max_memory:, marshal_stack_depth:, ensure_gc_after_idle:, timeout:); end

  def create_isolate_value; end

  # source://mini_racer//lib/mini_racer.rb#306
  def ensure_gc_thread; end

  def eval_unsafe(_arg0, _arg1); end
  def init_unsafe(_arg0, _arg1); end
  def isolate_mutex; end

  # source://mini_racer//lib/mini_racer.rb#338
  def stop_attached; end

  # source://mini_racer//lib/mini_racer.rb#347
  def timeout(&blk); end
end

# source://mini_racer//lib/mini_racer.rb#118
class MiniRacer::Context::ExternalFunction
  # @return [ExternalFunction] a new instance of ExternalFunction
  #
  # source://mini_racer//lib/mini_racer.rb#119
  def initialize(name, callback, parent); end

  private

  def notify_v8; end
end

# source://mini_racer//lib/mini_racer.rb#28
class MiniRacer::ContextDisposedError < ::MiniRacer::Error; end

# source://mini_racer//lib/mini_racer.rb#26
class MiniRacer::Error < ::StandardError; end

# source://mini_racer//lib/mini_racer.rb#32
class MiniRacer::EvalError < ::MiniRacer::Error; end

# source://mini_racer//lib/mini_racer.rb#37
class MiniRacer::FailedV8Conversion
  # @return [FailedV8Conversion] a new instance of FailedV8Conversion
  #
  # source://mini_racer//lib/mini_racer.rb#39
  def initialize(info); end

  # Returns the value of attribute info.
  #
  # source://mini_racer//lib/mini_racer.rb#38
  def info; end
end

# source://mini_racer//lib/mini_racer.rb#74
class MiniRacer::Isolate
  # @return [Isolate] a new instance of Isolate
  #
  # source://mini_racer//lib/mini_racer.rb#75
  def initialize(snapshot = T.unsafe(nil)); end

  def idle_notification(_arg0); end
  def low_memory_notification; end
  def pump_message_loop; end

  private

  def init_with_snapshot(_arg0); end
end

# helper class returned when we have a JavaScript function
#
# source://mini_racer//lib/mini_racer.rb#68
class MiniRacer::JavaScriptFunction
  # source://mini_racer//lib/mini_racer.rb#69
  def to_s; end
end

# source://mini_racer//lib/mini_racer/version.rb#5
MiniRacer::LIBV8_NODE_VERSION = T.let(T.unsafe(nil), String)

module MiniRacer::Loader
  class << self
    def load(_arg0); end
  end
end

# source://mini_racer//lib/mini_racer.rb#23
MiniRacer::MARSHAL_STACKDEPTH_DEFAULT = T.let(T.unsafe(nil), Integer)

# source://mini_racer//lib/mini_racer.rb#24
MiniRacer::MARSHAL_STACKDEPTH_MAX_VALUE = T.let(T.unsafe(nil), Integer)

# source://mini_racer//lib/mini_racer.rb#33
class MiniRacer::ParseError < ::MiniRacer::EvalError; end

# source://mini_racer//lib/mini_racer.rb#85
class MiniRacer::Platform
  class << self
    # @raise [TypeError]
    def set_flag_as_str!(_arg0); end

    # source://mini_racer//lib/mini_racer.rb#87
    def set_flags!(*args, **kwargs); end

    private

    # normalize flags to strings, and adds leading dashes if needed
    #
    # source://mini_racer//lib/mini_racer.rb#101
    def flag_to_string(flag); end

    # source://mini_racer//lib/mini_racer.rb#96
    def flags_to_strings(flags); end
  end
end

# source://mini_racer//lib/mini_racer.rb#30
class MiniRacer::PlatformAlreadyInitialized < ::MiniRacer::Error; end

# source://mini_racer//lib/mini_racer.rb#44
class MiniRacer::RuntimeError < ::MiniRacer::EvalError
  # @return [RuntimeError] a new instance of RuntimeError
  #
  # source://mini_racer//lib/mini_racer.rb#45
  def initialize(message); end

  # source://mini_racer//lib/mini_racer.rb#56
  def backtrace; end
end

# source://mini_racer//lib/mini_racer.rb#34
class MiniRacer::ScriptTerminatedError < ::MiniRacer::EvalError; end

# `size` and `warmup!` public methods are defined in the C class
#
# source://mini_racer//lib/mini_racer.rb#424
class MiniRacer::Snapshot
  # @return [Snapshot] a new instance of Snapshot
  #
  # source://mini_racer//lib/mini_racer.rb#425
  def initialize(str = T.unsafe(nil)); end

  def dump; end
  def size; end

  # source://mini_racer//lib/mini_racer.rb#440
  def warmup!(src); end

  # @raise [TypeError]
  def warmup_unsafe!(_arg0); end

  private

  # @raise [TypeError]
  def load(_arg0); end
end

# source://mini_racer//lib/mini_racer.rb#29
class MiniRacer::SnapshotError < ::MiniRacer::Error; end

# source://mini_racer//lib/mini_racer.rb#35
class MiniRacer::V8OutOfMemoryError < ::MiniRacer::EvalError; end

# source://mini_racer//lib/mini_racer/version.rb#4
MiniRacer::VERSION = T.let(T.unsafe(nil), String)
