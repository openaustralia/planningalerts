# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `pg` gem.
# Please instead update this file by running `bin/tapioca gem pg`.

# The top-level PG namespace.
#
# source://pg//lib/pg.rb#35
module PG
  include ::PG::Constants

  class << self
    # Convenience alias for PG::Connection.new.
    #
    # source://pg//lib/pg.rb#55
    def connect(*args); end

    def init_openssl(_arg0, _arg1); end
    def init_ssl(_arg0); end
    def is_threadsafe?; end
    def isthreadsafe; end
    def library_version; end
    def threadsafe?; end

    # Get the PG library version. If +include_buildnum+ is +true+, include the build ID.
    #
    # source://pg//lib/pg.rb#47
    def version_string(include_buildnum = T.unsafe(nil)); end
  end
end

class PG::ActiveSqlTransaction < ::PG::InvalidTransactionState; end
class PG::AdminShutdown < ::PG::OperatorIntervention; end
class PG::AmbiguousAlias < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::AmbiguousColumn < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::AmbiguousFunction < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::AmbiguousParameter < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::ArraySubscriptError < ::PG::DataException; end
class PG::AssertFailure < ::PG::PlpgsqlError; end
class PG::BadCopyFileFormat < ::PG::DataException; end

# Simple set of rules for type casting common PostgreSQL types from Ruby
# to PostgreSQL.
#
# OIDs of supported type casts are not hard-coded in the sources, but are retrieved from the
# PostgreSQL's pg_type table in PG::BasicTypeMapBasedOnResult.new .
#
# This class works equal to PG::BasicTypeMapForResults, but does not define decoders for
# the given result OIDs, but encoders. So it can be used to type cast field values based on
# the type OID retrieved by a separate SQL query.
#
# PG::TypeMapByOid#build_column_map(result) can be used to generate a result independent
# PG::TypeMapByColumn type map, which can subsequently be used to cast query bind parameters
# or #put_copy_data fields.
#
# Example:
#   conn.exec( "CREATE TEMP TABLE copytable (t TEXT, i INT, ai INT[])" )
#
#   # Retrieve table OIDs per empty result set.
#   res = conn.exec( "SELECT * FROM copytable LIMIT 0" )
#   # Build a type map for common ruby to database type encoders.
#   btm = PG::BasicTypeMapBasedOnResult.new(conn)
#   # Build a PG::TypeMapByColumn with encoders suitable for copytable.
#   tm = btm.build_column_map( res )
#   row_encoder = PG::TextEncoder::CopyRow.new type_map: tm
#
#   conn.copy_data( "COPY copytable FROM STDIN", row_encoder ) do |res|
#     conn.put_copy_data ['a', 123, [5,4,3]]
#   end
# This inserts a single row into copytable with type casts from ruby to
# database types.
#
# source://pg//lib/pg/basic_type_mapping.rb#325
class PG::BasicTypeMapBasedOnResult < ::PG::TypeMapByOid
  include ::PG::BasicTypeRegistry

  # @return [BasicTypeMapBasedOnResult] a new instance of BasicTypeMapBasedOnResult
  #
  # source://pg//lib/pg/basic_type_mapping.rb#328
  def initialize(connection); end
end

# Simple set of rules for type casting common Ruby types to PostgreSQL.
#
# OIDs of supported type casts are not hard-coded in the sources, but are retrieved from the
# PostgreSQL's pg_type table in PG::BasicTypeMapForQueries.new .
#
# Query params are type casted based on the class of the given value.
#
# Higher level libraries will most likely not make use of this class, but use their
# own derivation of PG::TypeMapByClass or another set of rules to choose suitable
# encoders and decoders for the values to be sent.
#
# Example:
#   conn = PG::Connection.new
#   # Assign a default ruleset for type casts of input and output values.
#   conn.type_map_for_queries = PG::BasicTypeMapForQueries.new(conn)
#   # Execute a query. The Integer param value is typecasted internally by PG::BinaryEncoder::Int8.
#   # The format of the parameter is set to 1 (binary) and the OID of this parameter is set to 20 (int8).
#   res = conn.exec_params( "SELECT $1", [5] )
#
# source://pg//lib/pg/basic_type_mapping.rb#356
class PG::BasicTypeMapForQueries < ::PG::TypeMapByClass
  include ::PG::BasicTypeRegistry

  # @return [BasicTypeMapForQueries] a new instance of BasicTypeMapForQueries
  #
  # source://pg//lib/pg/basic_type_mapping.rb#359
  def initialize(connection); end

  private

  # source://pg//lib/pg/basic_type_mapping.rb#391
  def array_encoders_by_klass; end

  # source://pg//lib/pg/basic_type_mapping.rb#369
  def coder_by_name(format, direction, name); end

  # source://pg//lib/pg/basic_type_mapping.rb#398
  def get_array_type(value); end

  # source://pg//lib/pg/basic_type_mapping.rb#374
  def populate_encoder_list; end
end

# source://pg//lib/pg/basic_type_mapping.rb#418
PG::BasicTypeMapForQueries::DEFAULT_ARRAY_TYPE_MAP = T.let(T.unsafe(nil), Hash)

# source://pg//lib/pg/basic_type_mapping.rb#408
PG::BasicTypeMapForQueries::DEFAULT_TYPE_MAP = T.let(T.unsafe(nil), Hash)

# Simple set of rules for type casting common PostgreSQL types to Ruby.
#
# OIDs of supported type casts are not hard-coded in the sources, but are retrieved from the
# PostgreSQL's pg_type table in PG::BasicTypeMapForResults.new .
#
# Result values are type casted based on the type OID of the given result column.
#
# Higher level libraries will most likely not make use of this class, but use their
# own set of rules to choose suitable encoders and decoders.
#
# Example:
#   conn = PG::Connection.new
#   # Assign a default ruleset for type casts of output values.
#   conn.type_map_for_results = PG::BasicTypeMapForResults.new(conn)
#   # Execute a query.
#   res = conn.exec_params( "SELECT $1::INT", ['5'] )
#   # Retrieve and cast the result value. Value format is 0 (text) and OID is 20. Therefore typecasting
#   # is done by PG::TextDecoder::Integer internally for all value retrieval methods.
#   res.values  # => [[5]]
#
# PG::TypeMapByOid#fit_to_result(result, false) can be used to generate
# a result independent PG::TypeMapByColumn type map, which can subsequently be used
# to cast #get_copy_data fields:
#
# For the following table:
#   conn.exec( "CREATE TABLE copytable AS VALUES('a', 123, '{5,4,3}'::INT[])" )
#
#   # Retrieve table OIDs per empty result set.
#   res = conn.exec( "SELECT * FROM copytable LIMIT 0" )
#   # Build a type map for common database to ruby type decoders.
#   btm = PG::BasicTypeMapForResults.new(conn)
#   # Build a PG::TypeMapByColumn with decoders suitable for copytable.
#   tm = btm.build_column_map( res )
#   row_decoder = PG::TextDecoder::CopyRow.new type_map: tm
#
#   conn.copy_data( "COPY copytable TO STDOUT", row_decoder ) do |res|
#     while row=conn.get_copy_data
#       p row
#     end
#   end
# This prints the rows with type casted columns:
#   ["a", 123, [5, 4, 3]]
#
# See also PG::BasicTypeMapBasedOnResult for the encoder direction.
#
# source://pg//lib/pg/basic_type_mapping.rb#262
class PG::BasicTypeMapForResults < ::PG::TypeMapByOid
  include ::PG::BasicTypeRegistry

  # @return [BasicTypeMapForResults] a new instance of BasicTypeMapForResults
  #
  # source://pg//lib/pg/basic_type_mapping.rb#282
  def initialize(connection); end
end

# source://pg//lib/pg/basic_type_mapping.rb#265
class PG::BasicTypeMapForResults::WarningTypeMap < ::PG::TypeMapInRuby
  # @return [WarningTypeMap] a new instance of WarningTypeMap
  #
  # source://pg//lib/pg/basic_type_mapping.rb#266
  def initialize(typenames); end

  # source://pg//lib/pg/basic_type_mapping.rb#271
  def typecast_result_value(result, _tuple, field); end
end

# source://pg//lib/pg/basic_type_mapping.rb#5
module PG::BasicTypeRegistry
  protected

  # @raise [ArgumentError]
  #
  # source://pg//lib/pg/basic_type_mapping.rb#126
  def check_format_and_direction(format, direction); end

  private

  # source://pg//lib/pg/basic_type_mapping.rb#97
  def build_coder_maps(connection); end

  # @return [Boolean]
  #
  # source://pg//lib/pg/basic_type_mapping.rb#93
  def supports_ranges?(connection); end

  class << self
    # Alias the +old+ type to the +new+ type.
    #
    # source://pg//lib/pg/basic_type_mapping.rb#147
    def alias_type(format, new, old); end

    # Register an OID type named +name+ with a typecasting encoder and decoder object in
    # +type+.  +name+ should correspond to the `typname` column in
    # the `pg_type` table.
    #
    # source://pg//lib/pg/basic_type_mapping.rb#140
    def register_type(format, name, encoder_class, decoder_class); end
  end
end

# The key of this hash maps to the `typname` column from the table.
# encoder_map is then dynamically built with oids as the key and Type
# objects as values.
#
# source://pg//lib/pg/basic_type_mapping.rb#135
PG::BasicTypeRegistry::CODERS_BY_NAME = T.let(T.unsafe(nil), Array)

# An instance of this class stores the coders that should be used for a given wire format (text or binary)
# and type cast direction (encoder or decoder).
#
# source://pg//lib/pg/basic_type_mapping.rb#8
class PG::BasicTypeRegistry::CoderMap
  # @return [CoderMap] a new instance of CoderMap
  #
  # source://pg//lib/pg/basic_type_mapping.rb#19
  def initialize(result, coders_by_name, format, arraycoder); end

  # source://pg//lib/pg/basic_type_mapping.rb#82
  def coder_by_name(name); end

  # source://pg//lib/pg/basic_type_mapping.rb#86
  def coder_by_oid(oid); end

  # Returns the value of attribute coders.
  #
  # source://pg//lib/pg/basic_type_mapping.rb#77
  def coders; end

  # Returns the value of attribute coders_by_name.
  #
  # source://pg//lib/pg/basic_type_mapping.rb#79
  def coders_by_name; end

  # Returns the value of attribute coders_by_oid.
  #
  # source://pg//lib/pg/basic_type_mapping.rb#78
  def coders_by_oid; end

  # Returns the value of attribute typenames_by_oid.
  #
  # source://pg//lib/pg/basic_type_mapping.rb#80
  def typenames_by_oid; end
end

# Hash of text types that don't require quotation, when used within composite types.
#   type.name => true
#
# source://pg//lib/pg/basic_type_mapping.rb#11
PG::BasicTypeRegistry::CoderMap::DONT_QUOTE_TYPES = T.let(T.unsafe(nil), Hash)

# source://pg//lib/pg/basic_type_mapping.rb#124
PG::BasicTypeRegistry::ValidDirections = T.let(T.unsafe(nil), Hash)

# source://pg//lib/pg/basic_type_mapping.rb#123
PG::BasicTypeRegistry::ValidFormats = T.let(T.unsafe(nil), Hash)

module PG::BinaryDecoder; end

class PG::BinaryDecoder::Boolean < ::PG::SimpleDecoder
  include ::PG::Coder::BinaryFormatting
end

PG::BinaryDecoder::Boolean::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryDecoder::Bytea < ::PG::SimpleDecoder
  include ::PG::Coder::BinaryFormatting
end

PG::BinaryDecoder::Bytea::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryDecoder::Float < ::PG::SimpleDecoder
  include ::PG::Coder::BinaryFormatting
end

PG::BinaryDecoder::Float::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryDecoder::Integer < ::PG::SimpleDecoder
  include ::PG::Coder::BinaryFormatting
end

PG::BinaryDecoder::Integer::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryDecoder::String < ::PG::SimpleDecoder
  include ::PG::Coder::BinaryFormatting
end

PG::BinaryDecoder::String::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryDecoder::ToBase64 < ::PG::CompositeDecoder
  include ::PG::Coder::BinaryFormatting
end

PG::BinaryDecoder::ToBase64::CFUNC = T.let(T.unsafe(nil), Object)
module PG::BinaryEncoder; end

class PG::BinaryEncoder::Boolean < ::PG::SimpleEncoder
  include ::PG::Coder::BinaryFormatting
end

PG::BinaryEncoder::Boolean::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryEncoder::Bytea < ::PG::SimpleEncoder
  include ::PG::Coder::BinaryFormatting
end

PG::BinaryEncoder::Bytea::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryEncoder::FromBase64 < ::PG::CompositeEncoder
  include ::PG::Coder::BinaryFormatting
end

PG::BinaryEncoder::FromBase64::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryEncoder::Int2 < ::PG::SimpleEncoder
  include ::PG::Coder::BinaryFormatting
end

PG::BinaryEncoder::Int2::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryEncoder::Int4 < ::PG::SimpleEncoder
  include ::PG::Coder::BinaryFormatting
end

PG::BinaryEncoder::Int4::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryEncoder::Int8 < ::PG::SimpleEncoder
  include ::PG::Coder::BinaryFormatting
end

PG::BinaryEncoder::Int8::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryEncoder::String < ::PG::SimpleEncoder
  include ::PG::Coder::BinaryFormatting
end

PG::BinaryEncoder::String::CFUNC = T.let(T.unsafe(nil), Object)
class PG::BranchTransactionAlreadyActive < ::PG::InvalidTransactionState; end
class PG::CannotCoerce < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::CannotConnectNow < ::PG::OperatorIntervention; end
class PG::CantChangeRuntimeParam < ::PG::ObjectNotInPrerequisiteState; end
class PG::CardinalityViolation < ::PG::ServerError; end
class PG::CaseNotFound < ::PG::ServerError; end
class PG::CharacterNotInRepertoire < ::PG::DataException; end
class PG::CheckViolation < ::PG::IntegrityConstraintViolation; end

# source://pg//lib/pg/coder.rb#5
class PG::Coder
  # Create a new coder object based on the attribute Hash.
  #
  # @return [Coder] a new instance of Coder
  #
  # source://pg//lib/pg/coder.rb#16
  def initialize(params = T.unsafe(nil)); end

  # source://pg//lib/pg/coder.rb#35
  def ==(v); end

  def decode(*_arg0); end

  # source://pg//lib/pg/coder.rb#22
  def dup; end

  def encode(*_arg0); end
  def format; end
  def format=(_arg0); end

  # source://pg//lib/pg/coder.rb#47
  def inspect; end

  # source://pg//lib/pg/coder.rb#39
  def marshal_dump; end

  # source://pg//lib/pg/coder.rb#43
  def marshal_load(str); end

  def name; end
  def name=(_arg0); end
  def oid; end
  def oid=(_arg0); end

  # Returns coder attributes as Hash.
  #
  # source://pg//lib/pg/coder.rb#27
  def to_h; end
end

# source://pg//lib/pg/coder.rb#7
module PG::Coder::BinaryFormatting
  # source://pg//lib/pg/coder.rb#9
  def initialize(params = T.unsafe(nil)); end
end

# source://pg//lib/pg/coder.rb#8
PG::Coder::BinaryFormatting::Params = T.let(T.unsafe(nil), Hash)

class PG::CollationMismatch < ::PG::SyntaxErrorOrAccessRuleViolation; end

# source://pg//lib/pg/coder.rb#57
class PG::CompositeCoder < ::PG::Coder
  def delimiter; end
  def delimiter=(_arg0); end
  def elements_type; end
  def elements_type=(_arg0); end

  # source://pg//lib/pg/coder.rb#66
  def inspect; end

  def needs_quotation=(_arg0); end
  def needs_quotation?; end

  # source://pg//lib/pg/coder.rb#58
  def to_h; end
end

class PG::CompositeDecoder < ::PG::CompositeCoder; end
class PG::CompositeEncoder < ::PG::CompositeCoder; end
class PG::ConfigFileError < ::PG::ServerError; end
class PG::ConfigurationLimitExceeded < ::PG::InsufficientResources; end

# The PostgreSQL connection class. The interface for this class is based on
# {libpq}[http://www.postgresql.org/docs/9.2/interactive/libpq.html], the C
# application programmer's interface to PostgreSQL. Some familiarity with libpq
# is recommended, but not necessary.
#
# For example, to send query to the database on the localhost:
#
#    require 'pg'
#    conn = PG::Connection.open(:dbname => 'test')
#    res = conn.exec_params('SELECT $1 AS a, $2 AS b, $3 AS c', [1, 2, nil])
#    # Equivalent to:
#    #  res  = conn.exec('SELECT 1 AS a, 2 AS b, NULL AS c')
#
# See the PG::Result class for information on working with the results of a query.
#
# source://pg//lib/pg/connection.rb#21
class PG::Connection
  include ::PG::Constants

  def initialize(*_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/patches/db/pg.rb#109
  def async_exec(*args, &blk); end

  def async_exec_without_profiling(*_arg0); end
  def async_query(*_arg0); end
  def backend_pid; end
  def block(*_arg0); end
  def cancel; end
  def client_encoding=(_arg0); end
  def close; end

  # Returns an array of Hashes with connection defaults. See ::conndefaults
  # for details.
  #
  # source://pg//lib/pg/connection.rb#214
  def conndefaults; end

  # Returns a Hash with connection defaults. See ::conndefaults_hash
  # for details.
  #
  # source://pg//lib/pg/connection.rb#230
  def conndefaults_hash; end

  def connect_poll; end
  def connection_needs_password; end
  def connection_used_password; end
  def conninfo; end

  # Return the Postgres connection info structure as a Hash keyed by option
  # keyword (as a Symbol).
  #
  # See also #conninfo
  #
  # source://pg//lib/pg/connection.rb#241
  def conninfo_hash; end

  def consume_input; end

  # call-seq:
  #     conn.copy_data( sql ) {|sql_result| ... } -> PG::Result
  #
  # Execute a copy process for transfering data to or from the server.
  #
  # This issues the SQL COPY command via #exec. The response to this
  # (if there is no error in the command) is a PG::Result object that
  # is passed to the block, bearing a status code of PGRES_COPY_OUT or
  # PGRES_COPY_IN (depending on the specified copy direction).
  # The application should then use #put_copy_data or #get_copy_data
  # to receive or transmit data rows and should return from the block
  # when finished.
  #
  # #copy_data returns another PG::Result object when the data transfer
  # is complete. An exception is raised if some problem was encountered,
  # so it isn't required to make use of any of them.
  # At this point further SQL commands can be issued via #exec.
  # (It is not possible to execute other SQL commands using the same
  # connection while the COPY operation is in progress.)
  #
  # This method ensures, that the copy process is properly terminated
  # in case of client side or server side failures. Therefore, in case
  # of blocking mode of operation, #copy_data is preferred to raw calls
  # of #put_copy_data, #get_copy_data and #put_copy_end.
  #
  # Example with CSV input format:
  #   conn.exec "create table my_table (a text,b text,c text,d text)"
  #   conn.copy_data "COPY my_table FROM STDIN CSV" do
  #     conn.put_copy_data "some,data,to,copy\n"
  #     conn.put_copy_data "more,data,to,copy\n"
  #   end
  # This creates +my_table+ and inserts two CSV rows.
  #
  # The same with text format encoder PG::TextEncoder::CopyRow
  # and Array input:
  #   enco = PG::TextEncoder::CopyRow.new
  #   conn.copy_data "COPY my_table FROM STDIN", enco do
  #     conn.put_copy_data ['some', 'data', 'to', 'copy']
  #     conn.put_copy_data ['more', 'data', 'to', 'copy']
  #   end
  #
  # Example with CSV output format:
  #   conn.copy_data "COPY my_table TO STDOUT CSV" do
  #     while row=conn.get_copy_data
  #       p row
  #     end
  #   end
  # This prints all rows of +my_table+ to stdout:
  #   "some,data,to,copy\n"
  #   "more,data,to,copy\n"
  #
  # The same with text format decoder PG::TextDecoder::CopyRow
  # and Array output:
  #   deco = PG::TextDecoder::CopyRow.new
  #   conn.copy_data "COPY my_table TO STDOUT", deco do
  #     while row=conn.get_copy_data
  #       p row
  #     end
  #   end
  # This receives all rows of +my_table+ as ruby array:
  #   ["some", "data", "to", "copy"]
  #   ["more", "data", "to", "copy"]
  #
  # source://pg//lib/pg/connection.rb#150
  def copy_data(sql, coder = T.unsafe(nil)); end

  def db; end
  def decoder_for_get_copy_data; end
  def decoder_for_get_copy_data=(_arg0); end
  def describe_portal(_arg0); end
  def describe_prepared(_arg0); end
  def encoder_for_put_copy_data; end
  def encoder_for_put_copy_data=(_arg0); end
  def error_message; end
  def escape(_arg0); end
  def escape_bytea(_arg0); end
  def escape_identifier(_arg0); end
  def escape_literal(_arg0); end
  def escape_string(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/patches/db/pg.rb#55
  def exec(*args, &blk); end

  def exec_params(*_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/patches/db/pg.rb#81
  def exec_prepared(*args, &blk); end

  def exec_prepared_without_profiling(*_arg0); end
  def exec_without_profiling(*_arg0); end
  def external_encoding; end
  def finish; end
  def finished?; end
  def flush; end
  def get_client_encoding; end
  def get_copy_data(*_arg0); end
  def get_last_result; end
  def get_result; end
  def host; end
  def internal_encoding; end
  def internal_encoding=(_arg0); end
  def is_busy; end
  def isnonblocking; end
  def lo_close(_arg0); end
  def lo_creat(*_arg0); end
  def lo_create(_arg0); end
  def lo_export(_arg0, _arg1); end
  def lo_import(_arg0); end
  def lo_lseek(_arg0, _arg1, _arg2); end
  def lo_open(*_arg0); end
  def lo_read(_arg0, _arg1); end
  def lo_seek(_arg0, _arg1, _arg2); end
  def lo_tell(_arg0); end
  def lo_truncate(_arg0, _arg1); end
  def lo_unlink(_arg0); end
  def lo_write(_arg0, _arg1); end
  def loclose(_arg0); end
  def locreat(*_arg0); end
  def locreate(_arg0); end
  def loexport(_arg0, _arg1); end
  def loimport(_arg0); end
  def lolseek(_arg0, _arg1, _arg2); end
  def loopen(*_arg0); end
  def loread(_arg0, _arg1); end
  def loseek(_arg0, _arg1, _arg2); end
  def lotell(_arg0); end
  def lotruncate(_arg0, _arg1); end
  def lounlink(_arg0); end
  def lowrite(_arg0, _arg1); end
  def make_empty_pgresult(_arg0); end
  def nonblocking?; end
  def notifies; end
  def notifies_wait(*_arg0); end
  def options; end
  def parameter_status(_arg0); end
  def pass; end
  def port; end

  # source://rack-mini-profiler/3.0.0/lib/patches/db/pg.rb#42
  def prepare(*args, &blk); end

  def prepare_without_profiling(*_arg0); end
  def protocol_version; end
  def put_copy_data(*_arg0); end
  def put_copy_end(*_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/patches/db/pg.rb#55
  def query(*args, &blk); end

  def quote_ident(_arg0); end
  def reset; end
  def reset_poll; end
  def reset_start; end
  def send_describe_portal(_arg0); end
  def send_describe_prepared(_arg0); end
  def send_prepare(*_arg0); end
  def send_query(*_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/patches/db/pg.rb#95
  def send_query_prepared(*args, &blk); end

  def send_query_prepared_without_profiling(*_arg0); end
  def server_version; end
  def set_client_encoding(_arg0); end
  def set_default_encoding; end
  def set_error_verbosity(_arg0); end
  def set_notice_processor; end
  def set_notice_receiver; end
  def set_single_row_mode; end
  def setnonblocking(_arg0); end
  def socket; end
  def socket_io; end
  def ssl_attribute(_arg0); end
  def ssl_attribute_names; end

  # call-seq:
  #   conn.ssl_attributes -> Hash<String,String>
  #
  # Returns SSL-related information about the connection as key/value pairs
  #
  # The available attributes varies depending on the SSL library being used,
  # and the type of connection.
  #
  # See also #ssl_attribute
  #
  # source://pg//lib/pg/connection.rb#259
  def ssl_attributes; end

  def ssl_in_use?; end
  def status; end
  def trace(_arg0); end
  def transaction; end
  def transaction_status; end
  def tty; end
  def type_map_for_queries; end
  def type_map_for_queries=(_arg0); end
  def type_map_for_results; end
  def type_map_for_results=(_arg0); end
  def unescape_bytea(_arg0); end
  def untrace; end
  def user; end
  def wait_for_notify(*_arg0); end

  class << self
    def conndefaults; end

    # Return the Postgres connection defaults structure as a Hash keyed by option
    # keyword (as a Symbol).
    #
    # See also #conndefaults
    #
    # source://pg//lib/pg/connection.rb#222
    def conndefaults_hash; end

    def connect(*_arg0); end
    def connect_start(*_arg0); end
    def encrypt_password(_arg0, _arg1); end
    def escape(_arg0); end
    def escape_bytea(_arg0); end
    def escape_string(_arg0); end
    def isthreadsafe; end
    def open(*_arg0); end

    # Parse the connection +args+ into a connection-parameter string. See PG::Connection.new
    # for valid arguments.
    #
    # source://pg//lib/pg/connection.rb#35
    def parse_connect_args(*args); end

    def ping(*_arg0); end

    # Quote the given +value+ for use in a connection-parameter string.
    #
    # source://pg//lib/pg/connection.rb#28
    def quote_connstr(value); end

    def quote_ident(_arg0); end
    def setdb(*_arg0); end
    def setdblogin(*_arg0); end
    def unescape_bytea(_arg0); end
  end
end

# The order the options are passed to the ::connect method.
#
# source://pg//lib/pg/connection.rb#24
PG::Connection::CONNECT_ARGUMENT_ORDER = T.let(T.unsafe(nil), Array)

class PG::ConnectionBad < ::PG::Error; end
class PG::ConnectionDoesNotExist < ::PG::ConnectionException; end
class PG::ConnectionException < ::PG::ServerError; end
class PG::ConnectionFailure < ::PG::ConnectionException; end

# source://pg//lib/pg/constants.rb#6
module PG::Constants; end

PG::Constants::CONNECTION_AUTH_OK = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_AWAITING_RESPONSE = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_BAD = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_MADE = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_NEEDED = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_OK = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_SETENV = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_SSL_STARTUP = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_STARTED = T.let(T.unsafe(nil), Integer)
PG::Constants::INVALID_OID = T.let(T.unsafe(nil), Integer)
PG::Constants::INV_READ = T.let(T.unsafe(nil), Integer)
PG::Constants::INV_WRITE = T.let(T.unsafe(nil), Integer)
PG::Constants::InvalidOid = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_BAD_RESPONSE = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_COMMAND_OK = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_COPY_BOTH = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_COPY_IN = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_COPY_OUT = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_EMPTY_QUERY = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_FATAL_ERROR = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_NONFATAL_ERROR = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_POLLING_FAILED = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_POLLING_OK = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_POLLING_READING = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_POLLING_WRITING = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_SINGLE_TUPLE = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_TUPLES_OK = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_COLUMN_NAME = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_CONSTRAINT_NAME = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_CONTEXT = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_DATATYPE_NAME = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_INTERNAL_POSITION = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_INTERNAL_QUERY = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_MESSAGE_DETAIL = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_MESSAGE_HINT = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_MESSAGE_PRIMARY = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_SCHEMA_NAME = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_SEVERITY = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_SOURCE_FILE = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_SOURCE_FUNCTION = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_SOURCE_LINE = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_SQLSTATE = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_STATEMENT_POSITION = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_TABLE_NAME = T.let(T.unsafe(nil), Integer)
PG::Constants::PQERRORS_DEFAULT = T.let(T.unsafe(nil), Integer)
PG::Constants::PQERRORS_TERSE = T.let(T.unsafe(nil), Integer)
PG::Constants::PQERRORS_VERBOSE = T.let(T.unsafe(nil), Integer)
PG::Constants::PQPING_NO_ATTEMPT = T.let(T.unsafe(nil), Integer)
PG::Constants::PQPING_NO_RESPONSE = T.let(T.unsafe(nil), Integer)
PG::Constants::PQPING_OK = T.let(T.unsafe(nil), Integer)
PG::Constants::PQPING_REJECT = T.let(T.unsafe(nil), Integer)
PG::Constants::PQTRANS_ACTIVE = T.let(T.unsafe(nil), Integer)
PG::Constants::PQTRANS_IDLE = T.let(T.unsafe(nil), Integer)
PG::Constants::PQTRANS_INERROR = T.let(T.unsafe(nil), Integer)
PG::Constants::PQTRANS_INTRANS = T.let(T.unsafe(nil), Integer)
PG::Constants::PQTRANS_UNKNOWN = T.let(T.unsafe(nil), Integer)
PG::Constants::SEEK_CUR = T.let(T.unsafe(nil), Integer)
PG::Constants::SEEK_END = T.let(T.unsafe(nil), Integer)
PG::Constants::SEEK_SET = T.let(T.unsafe(nil), Integer)

# source://pg//lib/pg/coder.rb#73
class PG::CopyCoder < ::PG::Coder
  def delimiter; end
  def delimiter=(_arg0); end
  def null_string; end
  def null_string=(_arg0); end

  # source://pg//lib/pg/coder.rb#74
  def to_h; end

  def type_map; end
  def type_map=(_arg0); end
end

class PG::CopyDecoder < ::PG::CopyCoder; end
class PG::CopyEncoder < ::PG::CopyCoder; end
class PG::CrashShutdown < ::PG::OperatorIntervention; end
class PG::DataCorrupted < ::PG::InternalError; end
class PG::DataException < ::PG::ServerError; end
class PG::DatabaseDropped < ::PG::OperatorIntervention; end
class PG::DatatypeMismatch < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::DatetimeFieldOverflow < ::PG::DataException; end
class PG::DependentObjectsStillExist < ::PG::DependentPrivilegeDescriptorsStillExist; end
class PG::DependentPrivilegeDescriptorsStillExist < ::PG::ServerError; end
class PG::DiagnosticsException < ::PG::ServerError; end
class PG::DiskFull < ::PG::InsufficientResources; end
class PG::DivisionByZero < ::PG::DataException; end
class PG::DuplicateAlias < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::DuplicateColumn < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::DuplicateCursor < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::DuplicateDatabase < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::DuplicateFile < ::PG::SystemError; end
class PG::DuplicateFunction < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::DuplicateObject < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::DuplicatePstatement < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::DuplicateSchema < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::DuplicateTable < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::EREContainingSqlNotPermitted < ::PG::ExternalRoutineException; end
class PG::EREModifyingSqlDataNotPermitted < ::PG::ExternalRoutineException; end
class PG::EREProhibitedSqlStatementAttempted < ::PG::ExternalRoutineException; end
class PG::EREReadingSqlDataNotPermitted < ::PG::ExternalRoutineException; end
class PG::ERIEEventTriggerProtocolViolated < ::PG::ExternalRoutineInvocationException; end
class PG::ERIEInvalidSqlstateReturned < ::PG::ExternalRoutineInvocationException; end
class PG::ERIENullValueNotAllowed < ::PG::ExternalRoutineInvocationException; end
class PG::ERIESrfProtocolViolated < ::PG::ExternalRoutineInvocationException; end
class PG::ERIETriggerProtocolViolated < ::PG::ExternalRoutineInvocationException; end
PG::ERROR_CLASSES = T.let(T.unsafe(nil), Hash)

# source://pg//lib/pg/exceptions.rb#8
class PG::Error < ::StandardError
  def connection; end
  def error; end
  def result; end
end

class PG::ErrorInAssignment < ::PG::DataException; end
class PG::EscapeCharacterConflict < ::PG::DataException; end
class PG::ExclusionViolation < ::PG::IntegrityConstraintViolation; end
class PG::ExternalRoutineException < ::PG::ServerError; end
class PG::ExternalRoutineInvocationException < ::PG::ServerError; end
class PG::FdwColumnNameNotFound < ::PG::FdwError; end
class PG::FdwDynamicParameterValueNeeded < ::PG::FdwError; end
class PG::FdwError < ::PG::ServerError; end
class PG::FdwFunctionSequenceError < ::PG::FdwError; end
class PG::FdwInconsistentDescriptorInformation < ::PG::FdwError; end
class PG::FdwInvalidAttributeValue < ::PG::FdwError; end
class PG::FdwInvalidColumnName < ::PG::FdwError; end
class PG::FdwInvalidColumnNumber < ::PG::FdwError; end
class PG::FdwInvalidDataType < ::PG::FdwError; end
class PG::FdwInvalidDataTypeDescriptors < ::PG::FdwError; end
class PG::FdwInvalidDescriptorFieldIdentifier < ::PG::FdwError; end
class PG::FdwInvalidHandle < ::PG::FdwError; end
class PG::FdwInvalidOptionIndex < ::PG::FdwError; end
class PG::FdwInvalidOptionName < ::PG::FdwError; end
class PG::FdwInvalidStringFormat < ::PG::FdwError; end
class PG::FdwInvalidStringLengthOrBufferLength < ::PG::FdwError; end
class PG::FdwInvalidUseOfNullPointer < ::PG::FdwError; end
class PG::FdwNoSchemas < ::PG::FdwError; end
class PG::FdwOptionNameNotFound < ::PG::FdwError; end
class PG::FdwOutOfMemory < ::PG::FdwError; end
class PG::FdwReplyHandle < ::PG::FdwError; end
class PG::FdwSchemaNotFound < ::PG::FdwError; end
class PG::FdwTableNotFound < ::PG::FdwError; end
class PG::FdwTooManyHandles < ::PG::FdwError; end
class PG::FdwUnableToCreateExecution < ::PG::FdwError; end
class PG::FdwUnableToCreateReply < ::PG::FdwError; end
class PG::FdwUnableToEstablishConnection < ::PG::FdwError; end
class PG::FeatureNotSupported < ::PG::ServerError; end
class PG::FloatingPointException < ::PG::DataException; end
class PG::ForeignKeyViolation < ::PG::IntegrityConstraintViolation; end
class PG::GroupingError < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::HeldCursorRequiresSameIsolationLevel < ::PG::InvalidTransactionState; end
class PG::IdleInTransactionSessionTimeout < ::PG::InvalidTransactionState; end
class PG::InFailedSqlTransaction < ::PG::InvalidTransactionState; end
class PG::InappropriateAccessModeForBranchTransaction < ::PG::InvalidTransactionState; end
class PG::InappropriateIsolationLevelForBranchTransaction < ::PG::InvalidTransactionState; end
class PG::IndeterminateCollation < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::IndeterminateDatatype < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::IndexCorrupted < ::PG::InternalError; end
class PG::IndicatorOverflow < ::PG::DataException; end
class PG::InsufficientPrivilege < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InsufficientResources < ::PG::ServerError; end
class PG::IntegrityConstraintViolation < ::PG::ServerError; end
class PG::InternalError < ::PG::ServerError; end
class PG::IntervalFieldOverflow < ::PG::DataException; end
class PG::InvalidArgumentForLog < ::PG::DataException; end
class PG::InvalidArgumentForNthValue < ::PG::DataException; end
class PG::InvalidArgumentForNtile < ::PG::DataException; end
class PG::InvalidArgumentForPowerFunction < ::PG::DataException; end
class PG::InvalidArgumentForWidthBucketFunction < ::PG::DataException; end
class PG::InvalidAuthorizationSpecification < ::PG::ServerError; end
class PG::InvalidBinaryRepresentation < ::PG::DataException; end
class PG::InvalidCatalogName < ::PG::ServerError; end
class PG::InvalidChangeOfResultFields < ::PG::Error; end
class PG::InvalidCharacterValueForCast < ::PG::DataException; end
class PG::InvalidColumnDefinition < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidColumnReference < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidCursorDefinition < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidCursorName < ::PG::ServerError; end
class PG::InvalidCursorState < ::PG::ServerError; end
class PG::InvalidDatabaseDefinition < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidDatetimeFormat < ::PG::DataException; end
class PG::InvalidEscapeCharacter < ::PG::DataException; end
class PG::InvalidEscapeOctet < ::PG::DataException; end
class PG::InvalidEscapeSequence < ::PG::DataException; end
class PG::InvalidForeignKey < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidFunctionDefinition < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidGrantOperation < ::PG::InvalidGrantor; end
class PG::InvalidGrantor < ::PG::ServerError; end
class PG::InvalidIndicatorParameterValue < ::PG::DataException; end
class PG::InvalidName < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidObjectDefinition < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidParameterValue < ::PG::DataException; end
class PG::InvalidPassword < ::PG::InvalidAuthorizationSpecification; end
class PG::InvalidPstatementDefinition < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidRecursion < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidRegularExpression < ::PG::DataException; end
class PG::InvalidResultStatus < ::PG::Error; end
class PG::InvalidRoleSpecification < ::PG::ServerError; end
class PG::InvalidRowCountInLimitClause < ::PG::DataException; end
class PG::InvalidRowCountInResultOffsetClause < ::PG::DataException; end
class PG::InvalidSchemaDefinition < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidSchemaName < ::PG::ServerError; end
class PG::InvalidSqlStatementName < ::PG::ServerError; end
class PG::InvalidTableDefinition < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidTablesampleArgument < ::PG::DataException; end
class PG::InvalidTablesampleRepeat < ::PG::DataException; end
class PG::InvalidTextRepresentation < ::PG::DataException; end
class PG::InvalidTimeZoneDisplacementValue < ::PG::DataException; end
class PG::InvalidTransactionInitiation < ::PG::ServerError; end
class PG::InvalidTransactionState < ::PG::ServerError; end
class PG::InvalidTransactionTermination < ::PG::ServerError; end
class PG::InvalidUseOfEscapeCharacter < ::PG::DataException; end
class PG::InvalidXmlComment < ::PG::DataException; end
class PG::InvalidXmlContent < ::PG::DataException; end
class PG::InvalidXmlDocument < ::PG::DataException; end
class PG::InvalidXmlProcessingInstruction < ::PG::DataException; end
class PG::IoError < ::PG::SystemError; end
class PG::LEInvalidSpecification < ::PG::LocatorException; end
class PG::LocatorException < ::PG::ServerError; end
class PG::LockFileExists < ::PG::ConfigFileError; end
class PG::LockNotAvailable < ::PG::ObjectNotInPrerequisiteState; end
class PG::MostSpecificTypeMismatch < ::PG::DataException; end
class PG::NameTooLong < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::NoActiveSqlTransaction < ::PG::InvalidTransactionState; end
class PG::NoActiveSqlTransactionForBranchTransaction < ::PG::InvalidTransactionState; end
class PG::NoDataFound < ::PG::PlpgsqlError; end
class PG::NoResultError < ::PG::Error; end
class PG::NonstandardUseOfEscapeCharacter < ::PG::DataException; end

# source://pg//lib/pg.rb#43
class PG::NotAllCopyDataRetrieved < ::PG::Error; end

class PG::NotAnXmlDocument < ::PG::DataException; end
class PG::NotNullViolation < ::PG::IntegrityConstraintViolation; end
class PG::NullValueNoIndicatorParameter < ::PG::DataException; end
class PG::NullValueNotAllowed < ::PG::DataException; end
class PG::NumericValueOutOfRange < ::PG::DataException; end
class PG::ObjectInUse < ::PG::ObjectNotInPrerequisiteState; end
class PG::ObjectNotInPrerequisiteState < ::PG::ServerError; end
class PG::OperatorIntervention < ::PG::ServerError; end
class PG::OutOfMemory < ::PG::InsufficientResources; end
class PG::PlpgsqlError < ::PG::ServerError; end
class PG::ProgramLimitExceeded < ::PG::ServerError; end
class PG::ProtocolViolation < ::PG::ConnectionException; end
class PG::QueryCanceled < ::PG::OperatorIntervention; end

# VCS revision
#
# source://pg//lib/pg.rb#41
PG::REVISION = T.let(T.unsafe(nil), String)

class PG::RaiseException < ::PG::PlpgsqlError; end
class PG::ReadOnlySqlTransaction < ::PG::InvalidTransactionState; end
class PG::ReservedName < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::RestrictViolation < ::PG::IntegrityConstraintViolation; end

# source://pg//lib/pg/result.rb#6
class PG::Result
  include ::Enumerable
  include ::PG::Constants

  def [](_arg0); end
  def autoclear?; end
  def check; end
  def check_result; end
  def clear; end
  def cleared?; end
  def cmd_status; end
  def cmd_tuples; end
  def cmdtuples; end
  def column_values(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/patches/db/pg.rb#15
  def each(*args, &blk); end

  def each_row; end
  def each_without_profiling; end
  def error_field(_arg0); end
  def error_message; end
  def fformat(_arg0); end
  def field_values(_arg0); end
  def fields; end
  def fmod(_arg0); end
  def fname(_arg0); end
  def fnumber(_arg0); end
  def fsize(_arg0); end
  def ftable(_arg0); end
  def ftablecol(_arg0); end
  def ftype(_arg0); end
  def getisnull(_arg0, _arg1); end
  def getlength(_arg0, _arg1); end
  def getvalue(_arg0, _arg1); end

  # Return a String representation of the object suitable for debugging.
  #
  # source://pg//lib/pg/result.rb#20
  def inspect; end

  # Apply a type map for all value retrieving methods.
  #
  # +type_map+: a PG::TypeMap instance.
  #
  # See PG::BasicTypeMapForResults
  #
  # source://pg//lib/pg/result.rb#13
  def map_types!(type_map); end

  # source://rack-mini-profiler/3.0.0/lib/patches/db/pg.rb#22
  def mp_report_sql(&block); end

  def nfields; end
  def nparams; end
  def ntuples; end
  def num_fields; end
  def num_tuples; end
  def oid_value; end
  def paramtype(_arg0); end
  def res_status(_arg0); end
  def result_error_field(_arg0); end
  def result_error_message; end
  def result_status; end
  def stream_each; end
  def stream_each_row; end
  def type_map; end
  def type_map=(_arg0); end

  # source://rack-mini-profiler/3.0.0/lib/patches/db/pg.rb#8
  def values(*args, &blk); end

  def values_without_profiling; end
end

class PG::SEInvalidSpecification < ::PG::SavepointException; end
class PG::SREFunctionExecutedNoReturnStatement < ::PG::SqlRoutineException; end
class PG::SREModifyingSqlDataNotPermitted < ::PG::SqlRoutineException; end
class PG::SREProhibitedSqlStatementAttempted < ::PG::SqlRoutineException; end
class PG::SREReadingSqlDataNotPermitted < ::PG::SqlRoutineException; end
class PG::SavepointException < ::PG::ServerError; end
class PG::SchemaAndDataStatementMixingNotSupported < ::PG::InvalidTransactionState; end
class PG::ServerError < ::PG::Error; end
class PG::SimpleCoder < ::PG::Coder; end
class PG::SimpleDecoder < ::PG::SimpleCoder; end
class PG::SimpleEncoder < ::PG::SimpleCoder; end
class PG::SnapshotTooOld < ::PG::ServerError; end
class PG::SqlRoutineException < ::PG::ServerError; end
class PG::SqlStatementNotYetComplete < ::PG::ServerError; end
class PG::SqlclientUnableToEstablishSqlconnection < ::PG::ConnectionException; end
class PG::SqlserverRejectedEstablishmentOfSqlconnection < ::PG::ConnectionException; end
class PG::StackedDiagnosticsAccessedWithoutActiveHandler < ::PG::DiagnosticsException; end
class PG::StatementTooComplex < ::PG::ProgramLimitExceeded; end
class PG::StringDataLengthMismatch < ::PG::DataException; end
class PG::StringDataRightTruncation < ::PG::DataException; end
class PG::SubstringError < ::PG::DataException; end
class PG::SyntaxError < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::SyntaxErrorOrAccessRuleViolation < ::PG::ServerError; end
class PG::SystemError < ::PG::ServerError; end
class PG::TRDeadlockDetected < ::PG::TransactionRollback; end
class PG::TRIntegrityConstraintViolation < ::PG::TransactionRollback; end
class PG::TRSerializationFailure < ::PG::TransactionRollback; end
class PG::TRStatementCompletionUnknown < ::PG::TransactionRollback; end

# source://pg//lib/pg/text_decoder.rb#7
module PG::TextDecoder; end

class PG::TextDecoder::Array < ::PG::CompositeDecoder; end
PG::TextDecoder::Array::CFUNC = T.let(T.unsafe(nil), Object)
class PG::TextDecoder::Boolean < ::PG::SimpleDecoder; end
PG::TextDecoder::Boolean::CFUNC = T.let(T.unsafe(nil), Object)
class PG::TextDecoder::Bytea < ::PG::SimpleDecoder; end
PG::TextDecoder::Bytea::CFUNC = T.let(T.unsafe(nil), Object)
class PG::TextDecoder::CopyRow < ::PG::CopyDecoder; end
PG::TextDecoder::CopyRow::CFUNC = T.let(T.unsafe(nil), Object)

# source://pg//lib/pg/text_decoder.rb#8
class PG::TextDecoder::Date < ::PG::SimpleDecoder
  # source://pg//lib/pg/text_decoder.rb#11
  def decode(string, tuple = T.unsafe(nil), field = T.unsafe(nil)); end
end

# source://pg//lib/pg/text_decoder.rb#9
PG::TextDecoder::Date::ISO_DATE = T.let(T.unsafe(nil), Regexp)

class PG::TextDecoder::Float < ::PG::SimpleDecoder; end
PG::TextDecoder::Float::CFUNC = T.let(T.unsafe(nil), Object)
class PG::TextDecoder::FromBase64 < ::PG::CompositeDecoder; end
PG::TextDecoder::FromBase64::CFUNC = T.let(T.unsafe(nil), Object)
class PG::TextDecoder::Identifier < ::PG::SimpleDecoder; end
PG::TextDecoder::Identifier::CFUNC = T.let(T.unsafe(nil), Object)
class PG::TextDecoder::Integer < ::PG::SimpleDecoder; end
PG::TextDecoder::Integer::CFUNC = T.let(T.unsafe(nil), Object)

# source://pg//lib/pg/text_decoder.rb#44
class PG::TextDecoder::JSON < ::PG::SimpleDecoder
  # source://pg//lib/pg/text_decoder.rb#45
  def decode(string, tuple = T.unsafe(nil), field = T.unsafe(nil)); end
end

class PG::TextDecoder::String < ::PG::SimpleDecoder; end
PG::TextDecoder::String::CFUNC = T.let(T.unsafe(nil), Object)

# source://pg//lib/pg/text_decoder.rb#32
class PG::TextDecoder::TimestampWithTimeZone < ::PG::SimpleDecoder
  # source://pg//lib/pg/text_decoder.rb#35
  def decode(string, tuple = T.unsafe(nil), field = T.unsafe(nil)); end
end

# source://pg//lib/pg/text_decoder.rb#33
PG::TextDecoder::TimestampWithTimeZone::ISO_DATETIME_WITH_TIMEZONE = T.let(T.unsafe(nil), Regexp)

# source://pg//lib/pg/text_decoder.rb#20
class PG::TextDecoder::TimestampWithoutTimeZone < ::PG::SimpleDecoder
  # source://pg//lib/pg/text_decoder.rb#23
  def decode(string, tuple = T.unsafe(nil), field = T.unsafe(nil)); end
end

# source://pg//lib/pg/text_decoder.rb#21
PG::TextDecoder::TimestampWithoutTimeZone::ISO_DATETIME_WITHOUT_TIMEZONE = T.let(T.unsafe(nil), Regexp)

# source://pg//lib/pg/text_encoder.rb#6
module PG::TextEncoder; end

class PG::TextEncoder::Array < ::PG::CompositeEncoder; end
PG::TextEncoder::Array::CFUNC = T.let(T.unsafe(nil), Object)
class PG::TextEncoder::Boolean < ::PG::SimpleEncoder; end
PG::TextEncoder::Boolean::CFUNC = T.let(T.unsafe(nil), Object)
class PG::TextEncoder::Bytea < ::PG::SimpleEncoder; end
PG::TextEncoder::Bytea::CFUNC = T.let(T.unsafe(nil), Object)
class PG::TextEncoder::CopyRow < ::PG::CopyEncoder; end
PG::TextEncoder::CopyRow::CFUNC = T.let(T.unsafe(nil), Object)

# source://pg//lib/pg/text_encoder.rb#7
class PG::TextEncoder::Date < ::PG::SimpleEncoder
  # source://pg//lib/pg/text_encoder.rb#9
  def encode(value); end
end

# source://pg//lib/pg/text_encoder.rb#8
PG::TextEncoder::Date::STRFTIME_ISO_DATE = T.let(T.unsafe(nil), String)

class PG::TextEncoder::Float < ::PG::SimpleEncoder; end
PG::TextEncoder::Float::CFUNC = T.let(T.unsafe(nil), Object)
class PG::TextEncoder::Identifier < ::PG::SimpleEncoder; end
PG::TextEncoder::Identifier::CFUNC = T.let(T.unsafe(nil), Object)
class PG::TextEncoder::Integer < ::PG::SimpleEncoder; end
PG::TextEncoder::Integer::CFUNC = T.let(T.unsafe(nil), Object)

# source://pg//lib/pg/text_encoder.rb#28
class PG::TextEncoder::JSON < ::PG::SimpleEncoder
  # source://pg//lib/pg/text_encoder.rb#29
  def encode(value); end
end

class PG::TextEncoder::QuotedLiteral < ::PG::CompositeEncoder; end
PG::TextEncoder::QuotedLiteral::CFUNC = T.let(T.unsafe(nil), Object)
class PG::TextEncoder::String < ::PG::SimpleEncoder; end
PG::TextEncoder::String::CFUNC = T.let(T.unsafe(nil), Object)

# source://pg//lib/pg/text_encoder.rb#21
class PG::TextEncoder::TimestampWithTimeZone < ::PG::SimpleEncoder
  # source://pg//lib/pg/text_encoder.rb#23
  def encode(value); end
end

# source://pg//lib/pg/text_encoder.rb#22
PG::TextEncoder::TimestampWithTimeZone::STRFTIME_ISO_DATETIME_WITH_TIMEZONE = T.let(T.unsafe(nil), String)

# source://pg//lib/pg/text_encoder.rb#14
class PG::TextEncoder::TimestampWithoutTimeZone < ::PG::SimpleEncoder
  # source://pg//lib/pg/text_encoder.rb#16
  def encode(value); end
end

# source://pg//lib/pg/text_encoder.rb#15
PG::TextEncoder::TimestampWithoutTimeZone::STRFTIME_ISO_DATETIME_WITHOUT_TIMEZONE = T.let(T.unsafe(nil), String)

class PG::TextEncoder::ToBase64 < ::PG::CompositeEncoder; end
PG::TextEncoder::ToBase64::CFUNC = T.let(T.unsafe(nil), Object)
class PG::TooManyArguments < ::PG::ProgramLimitExceeded; end
class PG::TooManyColumns < ::PG::ProgramLimitExceeded; end
class PG::TooManyConnections < ::PG::InsufficientResources; end
class PG::TooManyRows < ::PG::PlpgsqlError; end
class PG::TransactionResolutionUnknown < ::PG::ConnectionException; end
class PG::TransactionRollback < ::PG::ServerError; end
class PG::TriggeredActionException < ::PG::ServerError; end
class PG::TriggeredDataChangeViolation < ::PG::ServerError; end
class PG::TrimError < ::PG::DataException; end
class PG::TypeMap; end

module PG::TypeMap::DefaultTypeMappable
  def default_type_map; end
  def default_type_map=(_arg0); end
  def with_default_type_map(_arg0); end
end

class PG::TypeMapAllStrings < ::PG::TypeMap; end

class PG::TypeMapByClass < ::PG::TypeMap
  include ::PG::TypeMap::DefaultTypeMappable

  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def coders; end
end

# source://pg//lib/pg/type_map_by_column.rb#5
class PG::TypeMapByColumn < ::PG::TypeMap
  include ::PG::TypeMap::DefaultTypeMappable

  def initialize(_arg0); end

  def coders; end

  # source://pg//lib/pg/type_map_by_column.rb#11
  def inspect; end

  # Returns the type oids of the assigned coders.
  #
  # source://pg//lib/pg/type_map_by_column.rb#7
  def oids; end
end

class PG::TypeMapByMriType < ::PG::TypeMap
  include ::PG::TypeMap::DefaultTypeMappable

  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def coders; end
end

class PG::TypeMapByOid < ::PG::TypeMap
  include ::PG::TypeMap::DefaultTypeMappable

  def add_coder(_arg0); end
  def build_column_map(_arg0); end
  def coders; end
  def max_rows_for_online_lookup; end
  def max_rows_for_online_lookup=(_arg0); end
  def rm_coder(_arg0, _arg1); end
end

class PG::TypeMapInRuby < ::PG::TypeMap
  include ::PG::TypeMap::DefaultTypeMappable

  def typecast_copy_get(_arg0, _arg1, _arg2, _arg3); end
  def typecast_query_param(_arg0, _arg1); end
  def typecast_result_value(_arg0, _arg1, _arg2); end
end

class PG::UnableToSend < ::PG::Error; end
class PG::UndefinedColumn < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::UndefinedFile < ::PG::SystemError; end
class PG::UndefinedFunction < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::UndefinedObject < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::UndefinedParameter < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::UndefinedTable < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::UniqueViolation < ::PG::IntegrityConstraintViolation; end
class PG::UnterminatedCString < ::PG::DataException; end
class PG::UntranslatableCharacter < ::PG::DataException; end

# Library version
#
# source://pg//lib/pg.rb#38
PG::VERSION = T.let(T.unsafe(nil), String)

class PG::WindowingError < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::WithCheckOptionViolation < ::PG::ServerError; end
class PG::WrongObjectType < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::ZeroLengthCharacterString < ::PG::DataException; end

# source://pg//lib/pg/deprecated_constants.rb#20
PGError = PG::Error

# source://pg//lib/pg/deprecated_constants.rb#18
PGconn = PG::Connection

# source://pg//lib/pg/deprecated_constants.rb#19
PGresult = PG::Result
