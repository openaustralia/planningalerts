# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `newrelic_rpm` gem.
# Please instead update this file by running `bin/tapioca gem newrelic_rpm`.

# typed: true

module DependencyDetection
  private

  def defer(&block); end
  def dependency_by_name(name); end
  def detect!; end
  def installed?(name); end
  def items; end
  def items=(new_items); end

  class << self
    def defer(&block); end
    def dependency_by_name(name); end
    def detect!; end
    def installed?(name); end
    def items; end
    def items=(new_items); end
  end
end

class DependencyDetection::Dependent
  def initialize; end

  def allowed_by_config?; end
  def auto_configured?; end
  def chain_configured?; end
  def chain_instrument(instrumenting_module, supportability_name = T.unsafe(nil)); end
  def chain_instrument_target(target, instrumenting_module, supportability_name = T.unsafe(nil)); end
  def check_dependencies; end
  def config_key; end
  def config_name; end
  def config_name=(_arg0); end
  def config_value; end
  def configure_with(new_config_name); end
  def conflicts_with_prepend(&block); end
  def dependencies; end
  def dependencies_satisfied?; end
  def depends_on(&block); end
  def deprecated_disabled_configured?; end
  def disabled_configured?; end
  def execute; end
  def executed; end
  def executed!; end
  def executes(&block); end
  def extract_supportability_name(instrumenting_module); end
  def fetch_config_value(key); end
  def log_and_instrument(method, instrumenting_module, supportability_name); end
  def name; end
  def name=(_arg0); end
  def named(new_name); end
  def prepend_configured?; end
  def prepend_conflicts; end
  def prepend_conflicts?; end
  def prepend_instrument(target_class, instrumenting_module, supportability_name = T.unsafe(nil)); end
  def source_location_for(klass, method_name); end
  def use_prepend?; end
  def valid_config_value(retrieved_value); end
end

DependencyDetection::Dependent::AUTO_CONFIG_VALUE = T.let(T.unsafe(nil), Symbol)
DependencyDetection::Dependent::VALID_CONFIG_VALUES = T.let(T.unsafe(nil), Array)
module NewRelic; end

module NewRelic::Agent
  extend ::NewRelic::Agent
  extend ::Forwardable
  extend ::NewRelic::SupportabilityHelper

  def add_custom_attributes(params); end
  def add_custom_span_attributes(params); end
  def add_deferred_method_tracers_now; end
  def add_instrumentation(file_pattern); end
  def add_or_defer_method_tracer(receiver, method_name, metric_name, options); end
  def after_fork(options = T.unsafe(nil)); end
  def agent; end
  def agent=(new_instance); end
  def browser_timing_header(nonce = T.unsafe(nil)); end
  def config; end
  def disable_all_tracing; end
  def disable_sql_recording; end
  def disable_transaction_tracing; end
  def drop_buffered_data; end
  def get_transaction_name; end
  def ignore_apdex; end
  def ignore_enduser; end
  def ignore_error_filter(&block); end
  def ignore_transaction; end
  def increment_metric(metric_name, amount = T.unsafe(nil)); end
  def instance; end
  def linking_metadata; end
  def logger; end
  def logger=(log); end
  def manual_start(options = T.unsafe(nil)); end
  def notice_error(exception, options = T.unsafe(nil)); end
  def notify(event_type, *args); end
  def record_custom_event(event_type, event_attrs); end
  def record_metric(metric_name, value); end
  def register_report_channel(*args, &block); end
  def require_test_helper; end
  def reset_config; end
  def set_sql_obfuscator(type = T.unsafe(nil), &block); end
  def set_transaction_name(name, options = T.unsafe(nil)); end
  def shutdown(options = T.unsafe(nil)); end
  def subscribe(event_type, &handler); end
  def tl_is_execution_traced?; end
  def tl_is_sql_recorded?; end
  def with_database_metric_name(model, method = T.unsafe(nil), product = T.unsafe(nil), &block); end
end

class NewRelic::Agent::AdaptiveSampler
  def initialize(target_samples = T.unsafe(nil), period_duration = T.unsafe(nil)); end

  def sampled?; end
  def stats; end

  private

  def register_config_callbacks; end
  def register_sampling_period_callback; end
  def register_sampling_target_callback; end
  def reset_if_period_expired!; end
end

class NewRelic::Agent::Agent
  include ::NewRelic::Agent::Agent::InstanceMethods::Start
  include ::NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread
  include ::NewRelic::Agent::Agent::InstanceMethods::Connect
  include ::NewRelic::Agent::Agent::InstanceMethods
  extend ::NewRelic::Agent::Agent::ClassMethods

  def initialize; end

  def refresh_attribute_filter; end
  def setup_attribute_filter; end

  class << self
    def config; end
  end
end

module NewRelic::Agent::Agent::ClassMethods
  def instance; end
end

module NewRelic::Agent::Agent::InstanceMethods
  include ::NewRelic::Agent::Agent::InstanceMethods::Start
  include ::NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread
  include ::NewRelic::Agent::Agent::InstanceMethods::Connect

  def adaptive_sampler; end
  def after_fork(options = T.unsafe(nil)); end
  def agent_command_router; end
  def agent_id=(agent_id); end
  def agent_should_start?; end
  def attribute_filter; end
  def cross_app_encoding_bytes; end
  def cross_process_id; end
  def custom_event_aggregator; end
  def defer_for_delayed_job?; end
  def drop_buffered_data; end
  def environment_report; end
  def error_collector; end
  def events; end
  def flush_pipe_data; end
  def harvest_samplers; end
  def harvester; end
  def install_pipe_service(channel_id); end
  def javascript_instrumentor; end
  def merge_data_for_endpoint(endpoint, data); end
  def monitors; end
  def monotonic_gc_profiler; end
  def pop_trace_execution_flag; end
  def push_trace_execution_flag(should_trace = T.unsafe(nil)); end
  def record_sql; end
  def reset_objects_with_locks; end
  def revert_to_default_configuration; end
  def service; end
  def service=(_arg0); end
  def set_record_sql(should_record); end
  def shutdown; end
  def span_event_aggregator; end
  def sql_sampler; end
  def start; end
  def started?; end
  def stats_engine; end
  def stop_event_loop; end
  def synthetics_event_aggregator; end
  def transaction_event_aggregator; end
  def transaction_event_recorder; end
  def transaction_rules; end
  def transaction_rules=(_arg0); end
  def transaction_sampler; end
  def trap_signals_for_litespeed; end
  def untraced_graceful_disconnect; end

  private

  def check_for_and_handle_agent_commands; end
  def connect(options = T.unsafe(nil)); end
  def container_for_endpoint(endpoint); end
  def control; end
  def determine_home_directory; end
  def graceful_disconnect; end
  def harvest_and_send_analytic_event_data; end
  def harvest_and_send_custom_event_data; end
  def harvest_and_send_error_event_data; end
  def harvest_and_send_errors; end
  def harvest_and_send_for_agent_commands; end
  def harvest_and_send_from_container(container, endpoint); end
  def harvest_and_send_slowest_sql; end
  def harvest_and_send_span_event_data; end
  def harvest_and_send_timeslice_data; end
  def harvest_and_send_transaction_traces; end
  def harvest_from_container(container, endpoint); end
  def harvest_size(container, items); end
  def log_remote_unavailable(endpoint, e); end
  def send_data_to_endpoint(endpoint, payload, container); end
  def start_worker_thread(connection_options = T.unsafe(nil)); end
  def transmit_analytic_event_data; end
  def transmit_custom_event_data; end
  def transmit_data; end
  def transmit_error_event_data; end
  def transmit_single_data_type(harvest_method, supportability_name); end
  def transmit_span_event_data; end
end

NewRelic::Agent::Agent::InstanceMethods::CUSTOM_EVENT = T.let(T.unsafe(nil), String)

module NewRelic::Agent::Agent::InstanceMethods::Connect
  def apdex_f; end
  def connect_attempts; end
  def connect_attempts=(_arg0); end
  def connect_retry_period; end
  def connect_to_server; end
  def connected?; end
  def disconnect; end
  def disconnected?; end
  def environment_for_connect; end
  def event_harvest_config; end
  def handle_license_error(error); end
  def handle_unrecoverable_agent_error(error); end
  def log_collector_messages(messages); end
  def log_connection(config_data); end
  def log_error(error); end
  def note_connect_failure; end
  def should_connect?(force = T.unsafe(nil)); end
  def signal_connected; end
  def wait_on_connect(timeout); end
  def waited_on_connect?; end
end

class NewRelic::Agent::Agent::InstanceMethods::Connect::WaitOnConnectTimeout < ::StandardError; end
NewRelic::Agent::Agent::InstanceMethods::ERROR_EVENT = T.let(T.unsafe(nil), String)
NewRelic::Agent::Agent::InstanceMethods::SPAN_EVENT = T.let(T.unsafe(nil), String)

module NewRelic::Agent::Agent::InstanceMethods::Start
  def already_started?; end
  def app_name_configured?; end
  def check_config_and_start_agent; end
  def connect_in_foreground; end
  def correct_license_length; end
  def defer_for_resque?; end
  def disabled?; end
  def has_correct_license_key?; end
  def has_license_key?; end
  def in_resque_child_process?; end
  def install_exit_handler; end
  def log_app_name; end
  def log_dispatcher; end
  def log_environment; end
  def log_ignore_url_regexes; end
  def log_startup; end
  def log_version_and_pid; end
  def monitoring?; end
  def setup_and_start_agent(options = T.unsafe(nil)); end
  def should_install_exit_handler?; end
  def sinatra_classic_app?; end
  def using_forking_dispatcher?; end
end

module NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread
  def catch_errors; end
  def create_and_run_event_loop; end
  def create_event_loop; end
  def deferred_work!(connection_options); end
  def handle_force_disconnect(error); end
  def handle_force_restart(error); end
  def handle_other_error(error); end
  def interval_for(event_type); end
end

NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread::ANALYTIC_EVENT_DATA = T.let(T.unsafe(nil), String)
NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread::CUSTOM_EVENT_DATA = T.let(T.unsafe(nil), String)
NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread::ERROR_EVENT_DATA = T.let(T.unsafe(nil), String)
NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread::LOG_ONCE_KEYS_RESET_PERIOD = T.let(T.unsafe(nil), Float)
NewRelic::Agent::Agent::InstanceMethods::StartWorkerThread::SPAN_EVENT_DATA = T.let(T.unsafe(nil), String)
NewRelic::Agent::Agent::InstanceMethods::TRANSACTION_EVENT = T.let(T.unsafe(nil), String)

class NewRelic::Agent::AgentLogger
  include ::NewRelic::Agent::LogOnce

  def initialize(root = T.unsafe(nil), override_logger = T.unsafe(nil)); end

  def debug(*msgs, &blk); end
  def error(*msgs, &blk); end
  def fatal(*msgs, &blk); end
  def info(*msgs, &blk); end
  def is_startup_logger?; end
  def log_exception(level, e, backtrace_level = T.unsafe(nil)); end
  def log_formatter=(formatter); end
  def warn(*msgs, &blk); end

  private

  def backtrace_from_exception(e); end
  def create_log(root, override_logger); end
  def create_log_to_file(root); end
  def create_null_logger; end
  def find_or_create_file_path(path_setting, root); end
  def format_and_send(level, *msgs, &block); end
  def gather_startup_logs; end
  def set_log_format!; end
  def set_log_level!; end
  def wants_stdout?; end

  class << self
    def format_fatal_error(message); end
    def log_level_for(level); end
  end
end

NewRelic::Agent::AgentLogger::LOG_LEVELS = T.let(T.unsafe(nil), Hash)

class NewRelic::Agent::AttributeFilter
  def initialize(config); end

  def allows?(allowed_destinations, requested_destination); end
  def allows_key?(key, destination); end
  def apply(attribute_name, default_destinations); end
  def build_rule(attribute_names, destinations, is_include); end
  def build_uri_rule(excluded_attributes); end
  def cache_prefix_denylist; end
  def high_security?; end
  def include_destinations_for_capture_params(capturing); end
  def might_allow_prefix?(prefix); end
  def might_allow_prefix_uncached?(prefix); end
  def rules; end
  def setup_key_cache; end
end

NewRelic::Agent::AttributeFilter::DST_ALL = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::AttributeFilter::DST_BROWSER_MONITORING = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::AttributeFilter::DST_ERROR_COLLECTOR = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::AttributeFilter::DST_NONE = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::AttributeFilter::DST_SPAN_EVENTS = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::AttributeFilter::DST_TRANSACTION_EVENTS = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::AttributeFilter::DST_TRANSACTION_SEGMENTS = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::AttributeFilter::DST_TRANSACTION_TRACER = T.let(T.unsafe(nil), Integer)

class NewRelic::Agent::AttributeFilterRule
  def initialize(attribute_name, destinations, is_include); end

  def <=>(other); end
  def attribute_name; end
  def destinations; end
  def empty?; end
  def is_include; end
  def match?(name); end
  def wildcard; end
end

module NewRelic::Agent::AttributeProcessing
  private

  def flatten_and_coerce(object, prefix = T.unsafe(nil), result = T.unsafe(nil), &blk); end
  def flatten_and_coerce_array(array, prefix, result, &blk); end
  def flatten_and_coerce_hash(hash, prefix, result, &blk); end

  class << self
    def flatten_and_coerce(object, prefix = T.unsafe(nil), result = T.unsafe(nil), &blk); end
    def flatten_and_coerce_array(array, prefix, result, &blk); end
    def flatten_and_coerce_hash(hash, prefix, result, &blk); end
  end
end

NewRelic::Agent::AttributeProcessing::EMPTY_ARRAY_STRING_LITERAL = T.let(T.unsafe(nil), String)
NewRelic::Agent::AttributeProcessing::EMPTY_HASH_STRING_LITERAL = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Attributes
  def initialize(filter); end

  def add_agent_attribute(key, value, default_destinations); end
  def add_agent_attribute_with_key_check(key, value, default_destinations); end
  def add_intrinsic_attribute(key, value); end
  def agent_attributes_for(destination); end
  def custom_attributes; end
  def custom_attributes_for(destination); end
  def intrinsic_attributes_for(destination); end
  def merge_custom_attributes(other); end
  def merge_untrusted_agent_attributes(attributes, prefix, default_destinations); end

  private

  def add(attributes, key, value); end
  def add_custom_attribute(key, value); end
  def exceeds_bytesize_limit?(value, limit); end
  def for_destination(attributes, calculated_destinations, destination); end
  def slice(incoming); end
end

NewRelic::Agent::Attributes::COUNT_LIMIT = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::Attributes::KEY_LIMIT = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::Attributes::VALUE_LIMIT = T.let(T.unsafe(nil), Integer)

class NewRelic::Agent::AuditLogger
  def initialize; end

  def allowed_endpoint?(uri); end
  def create_log_formatter; end
  def enabled=(_arg0); end
  def enabled?; end
  def ensure_log_path; end
  def log_request(uri, data, marshaller); end
  def log_request_headers(uri, headers); end
  def setup?; end
  def setup_logger; end
  def wants_stdout?; end
end

module NewRelic::Agent::Autostart
  extend ::NewRelic::Agent::Autostart

  def agent_should_start?; end
  def constant_is_defined?(const_name); end
  def denylisted?(value, &block); end
  def denylisted_constants?; end
  def denylisted_executables?; end
  def in_denylisted_rake_task?; end
end

NewRelic::Agent::Autostart::COMMA = T.let(T.unsafe(nil), String)
class NewRelic::Agent::BackgroundLoadingError < ::StandardError; end
module NewRelic::Agent::Commands; end

class NewRelic::Agent::Commands::AgentCommand
  def initialize(raw_collector_command); end

  def arguments; end
  def id; end
  def name; end
end

class NewRelic::Agent::Commands::AgentCommandRouter
  def initialize(event_listener = T.unsafe(nil)); end

  def backtrace_service; end
  def backtrace_service=(_arg0); end
  def call_handler_for(agent_command); end
  def check_for_and_handle_agent_commands; end
  def error(err); end
  def get_agent_commands; end
  def handlers; end
  def harvest!; end
  def harvest_from_thread_profiler_session; end
  def invoke_command(agent_command); end
  def invoke_commands(agent_commands); end
  def log_profiles(profiles); end
  def merge!(*args); end
  def new_relic_service; end
  def on_before_shutdown(*args); end
  def reset!; end
  def select_handler(agent_command); end
  def success; end
  def thread_profiler_session; end
  def thread_profiler_session=(_arg0); end
  def unrecognized_agent_command(agent_command); end
end

class NewRelic::Agent::Commands::AgentCommandRouter::AgentCommandError < ::StandardError; end
NewRelic::Agent::Commands::AgentCommandRouter::ERROR_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::Commands::AgentCommandRouter::SUCCESS_RESULT = T.let(T.unsafe(nil), Hash)

class NewRelic::Agent::Commands::ThreadProfilerSession
  def initialize(backtrace_service); end

  def enabled?; end
  def handle_start_command(agent_command); end
  def handle_stop_command(agent_command); end
  def harvest; end
  def past_time?; end
  def ready_to_harvest?; end
  def running?; end
  def start(agent_command); end
  def stop(report_data); end
  def stopped?; end

  private

  def raise_already_started_error; end
  def raise_command_error(msg); end
  def raise_thread_profiler_disabled; end
  def raise_unsupported_error; end
end

module NewRelic::Agent::Configuration
  class << self
    def deprecated_description(new_setting, description); end
    def instrumentation_value_of(disable_key, prepend_key = T.unsafe(nil)); end
    def value_of(key); end
  end
end

NewRelic::Agent::Configuration::AUTOSTART_DENYLISTED_RAKE_TASKS = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Configuration::Boolean
  class << self
    def ===(o); end
  end
end

NewRelic::Agent::Configuration::DEFAULTS = T.let(T.unsafe(nil), Hash)

class NewRelic::Agent::Configuration::DefaultSource
  extend ::Forwardable

  def initialize; end

  def [](*args, &block); end
  def default_values; end
  def defaults; end
  def delete(*args, &block); end
  def each(*args, &block); end
  def has_key?(*args, &block); end
  def keys(*args, &block); end
  def merge(*args, &block); end
  def to_hash(*args, &block); end

  class << self
    def agent_enabled; end
    def api_host; end
    def app_name; end
    def audit_log_path; end
    def browser_monitoring_loader; end
    def config_path; end
    def config_search_paths; end
    def convert_to_constant_list(raw_value); end
    def convert_to_list(value); end
    def convert_to_list_on_semicolon(value); end
    def convert_to_regexp_list(raw_value); end
    def dispatcher; end
    def enforce_fallback(allowed_values: T.unsafe(nil), fallback: T.unsafe(nil)); end
    def framework; end
    def host; end
    def profiling_available; end
    def thread_profiler_enabled; end
    def transaction_tracer_transaction_threshold; end
    def transform_for(key); end
  end
end

NewRelic::Agent::Configuration::DefaultSource::DEFAULT_LOG_DIR = T.let(T.unsafe(nil), String)
NewRelic::Agent::Configuration::DefaultSource::SEMICOLON = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Configuration::DottedHash < ::Hash
  def initialize(hash, keep_nesting = T.unsafe(nil)); end

  def inspect; end
  def to_hash; end

  protected

  def dot_flattened(nested_hash, names = T.unsafe(nil), result = T.unsafe(nil)); end

  class << self
    def symbolize(hash); end
  end
end

class NewRelic::Agent::Configuration::EnvironmentSource < ::NewRelic::Agent::Configuration::DottedHash
  def initialize; end

  def alias_map; end
  def alias_map=(_arg0); end
  def collect_new_relic_environment_variable_keys; end
  def convert_environment_key_to_config_key(key); end
  def set_aliases(config_setting, value); end
  def set_config_file; end
  def set_dotted_alias(original_config_setting); end
  def set_key_by_type(config_key, environment_key); end
  def set_log_file; end
  def set_value_from_environment_variable(key); end
  def set_values_from_new_relic_environment_variables; end
  def type_map; end
  def type_map=(_arg0); end
end

NewRelic::Agent::Configuration::EnvironmentSource::SPECIAL_CASE_KEYS = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Configuration::EnvironmentSource::SUPPORTED_PREFIXES = T.let(T.unsafe(nil), Regexp)

module NewRelic::Agent::Configuration::EventHarvestConfig
  extend ::NewRelic::Agent::Configuration::EventHarvestConfig

  def from_config(config); end
  def to_config_hash(connect_reply); end

  private

  def transform_event_harvest_config_keys(connect_reply, event_harvest_interval); end
  def transform_span_event_harvest_config(config_hash, connect_reply); end
end

NewRelic::Agent::Configuration::EventHarvestConfig::EVENT_HARVEST_CONFIG_KEY_MAPPING = T.let(T.unsafe(nil), Hash)

class NewRelic::Agent::Configuration::HighSecuritySource < ::NewRelic::Agent::Configuration::DottedHash
  def initialize(local_settings); end

  def record_sql_setting(local_settings, key); end
end

NewRelic::Agent::Configuration::HighSecuritySource::OBFUSCATED = T.let(T.unsafe(nil), String)
NewRelic::Agent::Configuration::HighSecuritySource::OFF = T.let(T.unsafe(nil), String)
NewRelic::Agent::Configuration::HighSecuritySource::RAW = T.let(T.unsafe(nil), String)
NewRelic::Agent::Configuration::HighSecuritySource::SET_TO_OBFUSCATED = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Configuration::MASK_DEFAULTS = T.let(T.unsafe(nil), Hash)

class NewRelic::Agent::Configuration::Manager
  def initialize; end

  def [](key); end
  def add_config_for_testing(source, level = T.unsafe(nil)); end
  def apply_mask(hash); end
  def apply_transformations(key, value); end
  def break_label_string_into_pairs(labels); end
  def config_classes_for_testing; end
  def delete_all_configs_for_testing; end
  def evaluate_procs(value); end
  def fetch(key); end
  def finished_configuring?; end
  def flattened; end
  def has_key?(key); end
  def invoke_callbacks(direction, source); end
  def keys; end
  def limit_number_of_labels(pairs); end
  def log_config(direction, source); end
  def make_label_hash(pairs, labels = T.unsafe(nil)); end
  def notify_finished_configuring; end
  def notify_server_source_added; end
  def num_configs_for_testing; end
  def parse_labels_from_dictionary; end
  def parse_labels_from_string; end
  def parsed_labels; end
  def register_callback(key, &proc); end
  def remove_config(source); end
  def remove_config_type(sym); end
  def remove_duplicates(pairs); end
  def replace_or_add_config(source); end
  def reset_cache; end
  def reset_to_defaults; end
  def source(key); end
  def to_collector_hash; end
  def transform_from_default(key); end
  def truncate(text, key = T.unsafe(nil)); end
  def valid_label_item?(item); end
  def valid_label_pairs?(label_pairs); end

  private

  def config_stack; end
end

NewRelic::Agent::Configuration::Manager::MALFORMED_LABELS_WARNING = T.let(T.unsafe(nil), String)
NewRelic::Agent::Configuration::Manager::MAX_LABEL_COUNT = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::Configuration::Manager::MAX_LABEL_LENGTH = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::Configuration::Manager::PARSING_LABELS_FAILURE = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Configuration::ManualSource < ::NewRelic::Agent::Configuration::DottedHash
  def initialize(hash); end
end

class NewRelic::Agent::Configuration::SecurityPolicySource < ::NewRelic::Agent::Configuration::DottedHash
  def initialize(security_policies); end

  def build_overrides(security_policies); end

  class << self
    def change_setting(policies, option, new_value); end
    def enabled?(option); end
    def not_empty?(option); end
    def record_sql_enabled?(option); end
  end
end

NewRelic::Agent::Configuration::SecurityPolicySource::COLON_COLON = T.let(T.unsafe(nil), String)
NewRelic::Agent::Configuration::SecurityPolicySource::ENABLED = T.let(T.unsafe(nil), String)
NewRelic::Agent::Configuration::SecurityPolicySource::SECURITY_SETTINGS_MAP = T.let(T.unsafe(nil), Hash)

class NewRelic::Agent::Configuration::ServerSource < ::NewRelic::Agent::Configuration::DottedHash
  def initialize(connect_reply, existing_config = T.unsafe(nil)); end

  def add_event_harvest_config(merged_settings, connect_reply); end
  def apply_feature_gates(merged_settings, connect_reply, existing_config); end
  def event_harvest_config_is_valid(connect_reply); end
  def filter_keys(merged_settings); end
  def fix_transaction_threshold(merged_settings); end
  def merge_agent_config_hash(merged_settings, connect_reply); end
  def merge_top_level_keys(merged_settings, connect_reply); end
  def ungated_value(key, merged_settings, existing_config); end
end

NewRelic::Agent::Configuration::ServerSource::EVENT_HARVEST_CONFIG_SUPPORTABILITY_METRIC_NAMES = T.let(T.unsafe(nil), Hash)
NewRelic::Agent::Configuration::ServerSource::TOP_LEVEL_KEYS = T.let(T.unsafe(nil), Array)

class NewRelic::Agent::Configuration::YamlSource < ::NewRelic::Agent::Configuration::DottedHash
  def initialize(path, env); end

  def failed?; end
  def failures; end
  def failures=(_arg0); end
  def file_path; end
  def file_path=(_arg0); end
  def generated_for_user; end
  def license_key; end

  protected

  def booleanify_values(config, *keys); end
  def dot_flattened(nested_hash, names = T.unsafe(nil), result = T.unsafe(nil)); end
  def is_boolean?(value); end
  def log_failure(*messages); end
  def process_erb(file); end
  def process_yaml(file, env, config, path); end
  def substitute_transaction_threshold(config); end
  def validate_config_file_path(path); end
  def warn_missing_config_file(path); end
end

NewRelic::Agent::Configuration::YamlSource::CONFIG_WITH_HASH_VALUE = T.let(T.unsafe(nil), Array)
module NewRelic::Agent::Connect; end

class NewRelic::Agent::Connect::RequestBuilder
  def initialize(new_relic_service, config, event_harvest_config, environment_report); end

  def connect_payload; end
  def environment_metadata; end
  def local_host; end
  def sanitize_environment_report(environment_report); end
end

class NewRelic::Agent::Connect::ResponseHandler
  def initialize(agent, config); end

  def add_security_policy_config(security_policies); end
  def add_server_side_config(config_data); end
  def configure_agent(config_data); end
end

class NewRelic::Agent::CrossAppPayload
  def initialize(id, transaction, transaction_info); end

  def as_json_array(content_length); end
  def id; end
  def referring_guid; end
  def referring_path_hash; end
  def referring_trip_id; end
  def transaction; end

  private

  def string_or_false_for(value); end
end

module NewRelic::Agent::CrossAppTracing
  def add_message_cat_headers(headers); end
  def assign_cross_app_intrinsics; end
  def cat_path_hash; end
  def cat_path_hashes; end
  def cat_path_hashes=(_arg0); end
  def cat_trip_id; end
  def cross_app_monitor; end
  def cross_app_payload; end
  def cross_app_payload=(_arg0); end
  def insert_cross_app_header(headers); end
  def is_cross_app?; end
  def is_cross_app_callee?; end
  def is_cross_app_caller; end
  def is_cross_app_caller=(_arg0); end
  def is_cross_app_caller?; end
  def record_cross_app_metrics; end

  private

  def append_cat_info(payload); end
  def assign_intrinsic_transaction_attributes(state); end
  def cat_referring_path_hash; end
  def cross_app_enabled?; end
  def cross_application_tracer_enabled?; end
  def extract_appdata(response); end
  def insert_message_headers(headers, txn_guid, trip_id, path_hash, synthetics_header); end
  def insert_request_headers(request, txn_guid, trip_id, path_hash); end
  def message_has_crossapp_request_header?(headers); end
  def obfuscator; end
  def record_cat_path_hash(hash); end
  def reject_messaging_cat_headers(headers); end
  def response_has_crossapp_header?(response); end
  def trusted_valid_cross_app_id?(id); end
  def trusts?(id); end
  def valid_cross_app_id?(xp_id); end
  def valid_cross_process_id?; end
  def valid_encoding_key?; end

  class << self
    def assign_intrinsic_transaction_attributes(state); end
    def cross_app_enabled?; end
    def cross_application_tracer_enabled?; end
    def extract_appdata(response); end
    def insert_request_headers(request, txn_guid, trip_id, path_hash); end
    def message_has_crossapp_request_header?(headers); end
    def obfuscator; end
    def reject_messaging_cat_headers(headers); end
    def response_has_crossapp_header?(response); end
    def trusted_valid_cross_app_id?(id); end
    def trusts?(id); end
    def valid_cross_app_id?(xp_id); end
    def valid_cross_process_id?; end
    def valid_encoding_key?; end
  end
end

NewRelic::Agent::CrossAppTracing::NR_APPDATA_HEADER = T.let(T.unsafe(nil), String)
NewRelic::Agent::CrossAppTracing::NR_ID_HEADER = T.let(T.unsafe(nil), String)
NewRelic::Agent::CrossAppTracing::NR_MESSAGE_BROKER_ID_HEADER = T.let(T.unsafe(nil), String)
NewRelic::Agent::CrossAppTracing::NR_MESSAGE_BROKER_SYNTHETICS_HEADER = T.let(T.unsafe(nil), String)
NewRelic::Agent::CrossAppTracing::NR_MESSAGE_BROKER_TXN_HEADER = T.let(T.unsafe(nil), String)
NewRelic::Agent::CrossAppTracing::NR_TXN_HEADER = T.let(T.unsafe(nil), String)

class NewRelic::Agent::CustomEventAggregator < ::NewRelic::Agent::EventAggregator
  include ::NewRelic::Coerce

  def record(type, attributes); end

  private

  def after_harvest(metadata); end
  def after_initialize; end
  def create_event(type, priority, attributes); end
  def note_dropped_event(type); end
  def note_dropped_events(total_count, dropped_count); end
  def record_supportability_metrics(total_count, captured_count, dropped_count); end
end

NewRelic::Agent::CustomEventAggregator::EVENT_TYPE_REGEX = T.let(T.unsafe(nil), Regexp)
NewRelic::Agent::CustomEventAggregator::PRIORITY = T.let(T.unsafe(nil), String)
NewRelic::Agent::CustomEventAggregator::TIMESTAMP = T.let(T.unsafe(nil), String)
NewRelic::Agent::CustomEventAggregator::TYPE = T.let(T.unsafe(nil), String)

module NewRelic::Agent::Database
  extend ::NewRelic::Agent::Database

  def capture_query(query); end
  def close_connections; end
  def explain_sql(statement); end
  def get_connection(config, &connector); end
  def obfuscate_sql(sql); end
  def parse_operation_from_query(sql); end
  def record_sql_method(config_section = T.unsafe(nil)); end
  def record_sql_method_key(config_section); end
  def set_sql_obfuscator(type, &block); end
  def should_collect_explain_plans?(config_section = T.unsafe(nil)); end
  def should_record_sql?(config_section = T.unsafe(nil)); end
  def truncate_query(query); end
end

class NewRelic::Agent::Database::ConnectionManager
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  def close_connections; end
  def get_connection(config, &connector); end
end

NewRelic::Agent::Database::ELLIPSIS = T.let(T.unsafe(nil), String)

module NewRelic::Agent::Database::ExplainPlanHelpers
  def handle_exception_in_explain; end
  def is_select?(sql); end
  def multiple_queries?(sql); end
  def parameterized?(sql); end
  def process_explain_results_mysql(results); end
  def process_explain_results_mysql2(results); end
  def process_explain_results_postgres(results); end
  def process_explain_results_sqlite(results); end
  def process_resultset(results, adapter); end
  def string_explain_plan_results(results); end
end

NewRelic::Agent::Database::ExplainPlanHelpers::MULTIPLE_QUERIES = T.let(T.unsafe(nil), Regexp)
NewRelic::Agent::Database::ExplainPlanHelpers::QUERY_PLAN = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::ExplainPlanHelpers::SELECT = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::ExplainPlanHelpers::SQLITE_EXPLAIN_COLUMNS = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Database::ExplainPlanHelpers::SUPPORTED_ADAPTERS_FOR_EXPLAIN = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Database::KNOWN_OPERATIONS = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Database::MAX_QUERY_LENGTH = T.let(T.unsafe(nil), Integer)

module NewRelic::Agent::Database::ObfuscationHelpers
  def detect_unmatched_pairs(obfuscated, adapter); end
  def obfuscate(sql, adapter); end
  def obfuscate_single_quote_literals(sql); end

  class << self
    def generate_regex(dialect); end
  end
end

NewRelic::Agent::Database::ObfuscationHelpers::CASSANDRA_COMPONENTS_REGEX = T.let(T.unsafe(nil), Regexp)
NewRelic::Agent::Database::ObfuscationHelpers::CLEANUP_REGEX = T.let(T.unsafe(nil), Hash)
NewRelic::Agent::Database::ObfuscationHelpers::COMPONENTS_REGEX_MAP = T.let(T.unsafe(nil), Hash)
NewRelic::Agent::Database::ObfuscationHelpers::DIALECT_COMPONENTS = T.let(T.unsafe(nil), Hash)
NewRelic::Agent::Database::ObfuscationHelpers::FAILED_TO_OBFUSCATE_MESSAGE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::ObfuscationHelpers::FALLBACK_REGEX = T.let(T.unsafe(nil), Regexp)
NewRelic::Agent::Database::ObfuscationHelpers::MYSQL_COMPONENTS_REGEX = T.let(T.unsafe(nil), Regexp)
NewRelic::Agent::Database::ObfuscationHelpers::ORACLE_COMPONENTS_REGEX = T.let(T.unsafe(nil), Regexp)
NewRelic::Agent::Database::ObfuscationHelpers::PLACEHOLDER = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::ObfuscationHelpers::POSTGRES_COMPONENTS_REGEX = T.let(T.unsafe(nil), Regexp)
NewRelic::Agent::Database::ObfuscationHelpers::SQLITE_COMPONENTS_REGEX = T.let(T.unsafe(nil), Regexp)

class NewRelic::Agent::Database::Obfuscator
  include ::Singleton
  include ::NewRelic::Agent::Database::ObfuscationHelpers
  extend ::Singleton::SingletonClassMethods

  def initialize; end

  def default_sql_obfuscator(sql); end
  def obfuscator; end
  def reset; end
  def set_sql_obfuscator(type, &block); end
end

NewRelic::Agent::Database::Obfuscator::ELLIPSIS = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::Obfuscator::QUERY_TOO_LARGE_MESSAGE = T.let(T.unsafe(nil), String)

module NewRelic::Agent::Database::PostgresExplainObfuscator
  extend ::NewRelic::Agent::Database::PostgresExplainObfuscator

  def obfuscate(explain); end
end

NewRelic::Agent::Database::PostgresExplainObfuscator::LABEL_LINE_REGEX = T.let(T.unsafe(nil), Regexp)
NewRelic::Agent::Database::PostgresExplainObfuscator::QUOTED_STRINGS_REGEX = T.let(T.unsafe(nil), Regexp)
NewRelic::Agent::Database::RECORD_FOR = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Database::SQL_COMMENT_REGEX = T.let(T.unsafe(nil), Regexp)

class NewRelic::Agent::Database::Statement
  include ::NewRelic::Agent::Database::ExplainPlanHelpers

  def initialize(sql, config = T.unsafe(nil), explainer = T.unsafe(nil), binds = T.unsafe(nil), name = T.unsafe(nil), host = T.unsafe(nil), port_path_or_id = T.unsafe(nil), database_name = T.unsafe(nil)); end

  def adapter; end
  def append_sql(new_sql); end
  def binds; end
  def binds=(_arg0); end
  def config; end
  def config=(_arg0); end
  def database_name; end
  def database_name=(_arg0); end
  def explain; end
  def explainer; end
  def explainer=(_arg0); end
  def host; end
  def host=(_arg0); end
  def name; end
  def name=(_arg0); end
  def port_path_or_id; end
  def port_path_or_id=(_arg0); end
  def safe_sql; end
  def sql; end
  def sql=(_arg0); end

  private

  def explainable?; end
  def symbolized_adapter(adapter); end
end

NewRelic::Agent::Database::Statement::DEFAULT_QUERY_NAME = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::Statement::MYSQL2_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::Statement::MYSQL_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::Statement::NEWLINE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::Statement::POSTGIS_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::Statement::POSTGRES_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Database::Statement::SQLITE_PREFIX = T.let(T.unsafe(nil), String)

class NewRelic::Agent::DatabaseAdapter
  def initialize(env, version); end

  def env; end
  def value; end
  def version; end

  class << self
    def value; end
  end
end

NewRelic::Agent::DatabaseAdapter::VERSIONS = T.let(T.unsafe(nil), Hash)

module NewRelic::Agent::Datastores
  class << self
    def notice_sql(query, scoped_metric, elapsed); end
    def notice_statement(statement, elapsed); end
    def trace(klass, method_name, product, operation = T.unsafe(nil)); end
    def wrap(product, operation, collection = T.unsafe(nil), callback = T.unsafe(nil)); end
  end
end

module NewRelic::Agent::Datastores::MetricHelper
  class << self
    def all_suffix; end
    def instance_metric_for(product, host, port_path_or_id); end
    def metrics_for(product, operation, collection = T.unsafe(nil), generic_product = T.unsafe(nil), host = T.unsafe(nil), port_path_or_id = T.unsafe(nil)); end
    def metrics_from_sql(product, sql); end
    def operation_from_sql(sql); end
    def operation_metric_for(product, operation); end
    def overridden_operation_and_collection; end
    def product_operation_collection_for(product, operation, collection = T.unsafe(nil), generic_product = T.unsafe(nil)); end
    def product_rollup(product); end
    def product_suffixed_rollup(product, suffix); end
    def scoped_metric_for(product, operation, collection = T.unsafe(nil)); end
    def should_override?(overrides, product, generic_product); end
    def statement_metric_for(product, collection, operation); end
    def suffixed_rollup(suffix); end
    def unscoped_metrics_for(product, operation, collection = T.unsafe(nil), host = T.unsafe(nil), port_path_or_id = T.unsafe(nil)); end
  end
end

NewRelic::Agent::Datastores::MetricHelper::ALL = T.let(T.unsafe(nil), String)
NewRelic::Agent::Datastores::MetricHelper::ALL_OTHER = T.let(T.unsafe(nil), String)
NewRelic::Agent::Datastores::MetricHelper::ALL_WEB = T.let(T.unsafe(nil), String)
NewRelic::Agent::Datastores::MetricHelper::DEFAULT_PRODUCT_NAME = T.let(T.unsafe(nil), String)
NewRelic::Agent::Datastores::MetricHelper::OTHER = T.let(T.unsafe(nil), String)
NewRelic::Agent::Datastores::MetricHelper::OTHER_ROLLUP_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Datastores::MetricHelper::ROLLUP_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Datastores::MetricHelper::WEB_ROLLUP_METRIC = T.let(T.unsafe(nil), String)

module NewRelic::Agent::Deprecator
  class << self
    def deprecate(method_name, new_method_name = T.unsafe(nil), version = T.unsafe(nil)); end
  end
end

module NewRelic::Agent::DistributedTraceAttributes
  extend ::NewRelic::Agent::DistributedTraceAttributes

  def copy_from_transaction(transaction, trace_payload, destination); end
  def copy_parent_attributes(transaction, trace_payload, destination); end
  def copy_to_attributes(transaction_payload, destination); end
  def copy_to_hash(transaction_payload, destination); end

  private

  def enabled?; end
end

NewRelic::Agent::DistributedTraceAttributes::GUID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceAttributes::INTRINSIC_KEYS = T.let(T.unsafe(nil), Array)
NewRelic::Agent::DistributedTraceAttributes::PARENT_ACCOUNT_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceAttributes::PARENT_APP_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceAttributes::PARENT_SPAN_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceAttributes::PARENT_TRANSACTION_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceAttributes::PARENT_TRANSPORT_DURATION_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceAttributes::PARENT_TRANSPORT_TYPE_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceAttributes::PARENT_TYPE_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceAttributes::SAMPLED_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceAttributes::TRACE_ID_KEY = T.let(T.unsafe(nil), String)

module NewRelic::Agent::DistributedTraceMetrics
  extend ::NewRelic::Agent::DistributedTraceMetrics

  def prefix_for_metric(name, transaction, payload); end
  def record_caller_by_duration_metrics(transaction, payload); end
  def record_errors_by_caller_metrics(transaction, payload); end
  def record_metrics_for_transaction(transaction); end
  def record_transport_duration_metrics(transaction, payload); end
  def transaction_type_suffix; end

  private

  def record_unscoped_metric(transaction, prefix, duration); end
end

NewRelic::Agent::DistributedTraceMetrics::ALL_OTHER_SUFFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceMetrics::ALL_SUFFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceMetrics::ALL_WEB_SUFFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceMetrics::UNKNOWN_CALLER_PREFIX = T.let(T.unsafe(nil), String)

class NewRelic::Agent::DistributedTracePayload
  extend ::NewRelic::Coerce

  def http_safe; end
  def id; end
  def id=(_arg0); end
  def parent_account_id; end
  def parent_account_id=(_arg0); end
  def parent_app_id; end
  def parent_app_id=(_arg0); end
  def parent_type; end
  def parent_type=(_arg0); end
  def priority; end
  def priority=(_arg0); end
  def sampled; end
  def sampled=(_arg0); end
  def sampled?; end
  def text; end
  def timestamp; end
  def timestamp=(_arg0); end
  def trace_id; end
  def trace_id=(_arg0); end
  def transaction_id; end
  def transaction_id=(_arg0); end
  def trusted_account_key; end
  def trusted_account_key=(_arg0); end
  def version; end
  def version=(_arg0); end

  class << self
    def for_transaction(transaction); end
    def from_http_safe(http_safe_payload); end
    def from_json(serialized_payload); end
    def major_version_matches?(payload); end

    private

    def assign_trusted_account_key(payload, account_id); end
    def connected?; end
    def current_segment_id(transaction); end
  end
end

NewRelic::Agent::DistributedTracePayload::DATA_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracePayload::ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracePayload::PARENT_ACCOUNT_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracePayload::PARENT_APP_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracePayload::PARENT_TYPE = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracePayload::PARENT_TYPE_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracePayload::POUND = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracePayload::PRIORITY_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracePayload::SAMPLED_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracePayload::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracePayload::TRACE_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracePayload::TRUSTED_ACCOUNT_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracePayload::TX_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracePayload::VERSION = T.let(T.unsafe(nil), Array)
NewRelic::Agent::DistributedTracePayload::VERSION_KEY = T.let(T.unsafe(nil), String)

module NewRelic::Agent::DistributedTraceTransportType
  extend ::NewRelic::Agent::DistributedTraceTransportType

  def for_rack_request(request); end
  def from(value); end
end

NewRelic::Agent::DistributedTraceTransportType::ALLOWABLE_TRANSPORT_TYPES = T.let(T.unsafe(nil), Array)
NewRelic::Agent::DistributedTraceTransportType::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTraceTransportType::URL_SCHEMES = T.let(T.unsafe(nil), Hash)

module NewRelic::Agent::DistributedTracing
  extend ::NewRelic::SupportabilityHelper
  extend ::NewRelic::Agent::DistributedTracing

  def accept_distributed_trace_headers(headers, transport_type = T.unsafe(nil)); end
  def insert_distributed_trace_headers(headers = T.unsafe(nil)); end

  private

  def has_variant_key?(key, variants); end
  def variant_key_value(headers, variants); end
end

class NewRelic::Agent::DistributedTracing::CrossAppMonitor < ::NewRelic::Agent::InboundRequestMonitor
  def on_finished_configuring(events); end
  def path_hash(txn_name, seed); end

  private

  def content_length_from_request(request); end
  def decoded_id(request); end
  def hash_transaction_name(identifier); end
  def insert_response_header(state, request_headers, response_headers); end
  def referring_transaction_info(state, request_headers); end
  def register_event_listeners(events); end
  def set_response_headers(transaction, response_headers, content_length); end
  def should_process_request?(id); end
end

NewRelic::Agent::DistributedTracing::CrossAppMonitor::CONTENT_LENGTH_HEADER_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::CrossAppMonitor::NEWRELIC_APPDATA_HEADER = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::CrossAppMonitor::NEWRELIC_ID_HEADER = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::CrossAppMonitor::NEWRELIC_ID_HEADER_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::CrossAppMonitor::NEWRELIC_TXN_HEADER = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::CrossAppMonitor::NEWRELIC_TXN_HEADER_KEY = T.let(T.unsafe(nil), String)

class NewRelic::Agent::DistributedTracing::Monitor < ::NewRelic::Agent::InboundRequestMonitor
  def on_before_call(request); end
  def on_finished_configuring(events); end
end

class NewRelic::Agent::DistributedTracing::TraceContext
  class << self
    def create_trace_state_entry(entry_key, payload); end
    def insert(format: T.unsafe(nil), carrier: T.unsafe(nil), parent_id: T.unsafe(nil), trace_id: T.unsafe(nil), trace_flags: T.unsafe(nil), trace_state: T.unsafe(nil)); end
    def parse(format: T.unsafe(nil), carrier: T.unsafe(nil), trace_state_entry_key: T.unsafe(nil)); end

    private

    def decode_payload(payload); end
    def extract_traceparent(format, carrier); end
    def extract_tracestate(format, carrier, trace_state_entry_key); end
    def format_trace_parent(trace_id: T.unsafe(nil), parent_id: T.unsafe(nil), trace_flags: T.unsafe(nil)); end
    def trace_parent_header_for_format(format); end
    def trace_parent_valid?(trace_parent); end
    def trace_state_header_for_format(format); end
  end
end

NewRelic::Agent::DistributedTracing::TraceContext::COMMA = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::EQUALS = T.let(T.unsafe(nil), String)

class NewRelic::Agent::DistributedTracing::TraceContext::HeaderData
  def initialize(trace_parent, trace_state_payload, trace_state_entries, trace_state_size, trace_state_vendors); end

  def parent_id; end
  def trace_id; end
  def trace_parent; end
  def trace_parent=(_arg0); end
  def trace_state(trace_state_entry); end
  def trace_state_payload; end
  def trace_state_payload=(_arg0); end
  def trace_state_vendors; end
  def trace_state_vendors=(_arg0); end

  private

  def join_trace_state(trace_state_entry_size); end

  class << self
    def create(trace_parent: T.unsafe(nil), trace_state_payload: T.unsafe(nil), trace_state_entries: T.unsafe(nil), trace_state_size: T.unsafe(nil), trace_state_vendors: T.unsafe(nil)); end
  end
end

NewRelic::Agent::DistributedTracing::TraceContext::INVALID_PARENT_ID = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::INVALID_TRACE_ID = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::INVALID_VERSION = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::MAX_TRACE_STATE_ENTRY_SIZE = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::DistributedTracing::TraceContext::MAX_TRACE_STATE_SIZE = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::DistributedTracing::TraceContext::PARENT_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::SUPPORTABILITY_TRACE_PARENT_PARSE_EXCEPTION = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::SUPPORTABILITY_TRACE_STATE_INVALID_NR_ENTRY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::SUPPORTABILITY_TRACE_STATE_PARSE_EXCEPTION = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::TP_PARENT_ID = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::TP_TRACE_FLAGS = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::TP_TRACE_ID = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::TP_UNDEFINED_FIELDS = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::TP_VERSION = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::TRACE_FLAGS_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::TRACE_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::TRACE_PARENT_FORMAT_STRING = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::TRACE_PARENT_REGEX = T.let(T.unsafe(nil), Regexp)
NewRelic::Agent::DistributedTracing::TraceContext::UNDEFINED_FIELDS_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::DistributedTracing::TraceContext::VERSION = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::DistributedTracing::TraceContext::VERSION_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::ENTITY_GUID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::ENTITY_NAME_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::ENTITY_TYPE = T.let(T.unsafe(nil), String)
NewRelic::Agent::ENTITY_TYPE_KEY = T.let(T.unsafe(nil), String)

module NewRelic::Agent::EncodingNormalizer
  class << self
    def normalize_object(object); end
    def normalize_string(raw_string); end
  end
end

module NewRelic::Agent::EncodingNormalizer::EncodingNormalizer
  class << self
    def normalize(raw_string); end
  end
end

class NewRelic::Agent::ErrorCollector
  def initialize(events); end

  def aggregated_metric_names(txn); end
  def blamed_metric_name(txn, options); end
  def create_noticed_error(exception, options); end
  def disabled?; end
  def drop_buffered_data; end
  def enabled?; end
  def error_event_aggregator; end
  def error_is_ignored?(error, status_code = T.unsafe(nil)); end
  def error_trace_aggregator; end
  def exception_is_java_object?(exception); end
  def exception_tagged_with?(ivar, exception); end
  def expect(errors); end
  def expected?(ex, status_code = T.unsafe(nil)); end
  def extract_stack_trace(exception); end
  def ignore(errors); end
  def ignore?(ex, status_code = T.unsafe(nil)); end
  def ignored_by_filter_proc?(error); end
  def increment_error_count!(state, exception, options = T.unsafe(nil)); end
  def increment_expected_error_count!(state, exception); end
  def load_error_filters; end
  def notice_agent_error(exception); end
  def notice_error(exception, options = T.unsafe(nil), span_id = T.unsafe(nil)); end
  def notice_segment_error(segment, exception, options = T.unsafe(nil)); end
  def reset_error_filters; end
  def sense_method(object, method); end
  def skip_notice_error?(exception, status_code = T.unsafe(nil)); end
  def tag_exception(exception); end
  def tag_exception_using(ivar, exception); end
  def truncate_trace(trace, keep_frames = T.unsafe(nil)); end

  class << self
    def ignore_error_filter; end
    def ignore_error_filter=(block); end
  end
end

NewRelic::Agent::ErrorCollector::EXCEPTION_TAG_IVAR = T.let(T.unsafe(nil), Symbol)
NewRelic::Agent::ErrorCollector::MAX_ERROR_QUEUE_LENGTH = T.let(T.unsafe(nil), Integer)

class NewRelic::Agent::ErrorEventAggregator < ::NewRelic::Agent::EventAggregator
  include ::NewRelic::Coerce

  def record(noticed_error, transaction_payload = T.unsafe(nil), span_id = T.unsafe(nil)); end

  private

  def create_event(noticed_error, transaction_payload, span_id); end
end

class NewRelic::Agent::ErrorFilter
  def initialize; end

  def expect(*args); end
  def expected?(ex, status_code = T.unsafe(nil)); end
  def fetch_agent_config(cfg); end
  def ignore(*args); end
  def ignore?(ex, status_code = T.unsafe(nil)); end
  def load_all; end
  def load_from_config(setting, value = T.unsafe(nil)); end
  def reset; end

  private

  def log_filter(setting, errors); end
  def parse_status_codes(codes); end
end

class NewRelic::Agent::ErrorTraceAggregator
  def initialize(capacity); end

  def add_to_error_queue(noticed_error); end
  def enabled?; end
  def harvest!; end
  def merge!(errors); end
  def notice_agent_error(exception); end
  def over_queue_limit?(message); end
  def register_config_callbacks; end
  def reset!; end
end

class NewRelic::Agent::EventAggregator
  def initialize(events); end

  def after_harvest(metadata); end
  def after_initialize; end
  def enabled?; end
  def harvest!; end
  def has_metadata?; end
  def merge!(payload, adjust_count = T.unsafe(nil)); end
  def reset!; end

  private

  def notify_if_full; end
  def register_capacity_callback; end
  def register_enabled_callback(events); end
  def reservoir_metadata(metadata); end
  def reset_buffer!; end

  class << self
    def buffer_class(klass = T.unsafe(nil)); end
    def capacity_key(key = T.unsafe(nil)); end
    def enabled_fn(fn = T.unsafe(nil)); end
    def enabled_key(*keys); end
    def enabled_keys(*keys); end
    def named(named = T.unsafe(nil)); end
  end
end

class NewRelic::Agent::EventBuffer
  def initialize(capacity); end

  def <<(x); end
  def append(x); end
  def capacity; end
  def capacity=(new_capacity); end
  def full?; end
  def metadata; end
  def note_dropped; end
  def num_dropped; end
  def num_seen; end
  def reset!; end
  def sample_rate; end
  def size; end
  def to_a; end
end

class NewRelic::Agent::EventListener
  def initialize; end

  def check_for_runaway_subscriptions(event); end
  def clear; end
  def notify(event, *args); end
  def runaway_threshold; end
  def runaway_threshold=(_arg0); end
  def subscribe(event, &handler); end
end

class NewRelic::Agent::EventLoop
  def initialize; end

  def dispatch_event(event, args); end
  def fire(event, *args); end
  def fire_after(interval, event); end
  def fire_every(interval, event); end
  def fire_timer(timer); end
  def fire_timers; end
  def next_timeout; end
  def on(event, &blk); end
  def prune_timers; end
  def reschedule_timer_for_event(e); end
  def run; end
  def run_once(nonblock = T.unsafe(nil)); end
  def set_timer(timer); end
  def stop; end
  def stopped?; end
  def wait_to_run(nonblock); end
  def wakeup; end
end

class NewRelic::Agent::EventLoop::Timer
  def initialize(interval, event, repeat = T.unsafe(nil)); end

  def advance(amount); end
  def calculate_next_fire_time; end
  def due?(now = T.unsafe(nil)); end
  def event; end
  def finished?; end
  def interval; end
  def last_fired_at; end
  def last_interval_start; end
  def next_fire_time; end
  def reschedule; end
  def set_fired_time; end
end

module NewRelic::Agent::External
  extend ::NewRelic::Agent::External

  def get_response_metadata; end
  def process_request_metadata(request_metadata); end

  private

  def obfuscator; end
end

NewRelic::Agent::External::NON_HTTP_CAT_CONTENT_LENGTH = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::External::NON_HTTP_CAT_ID_HEADER = T.let(T.unsafe(nil), String)
NewRelic::Agent::External::NON_HTTP_CAT_SYNTHETICS_HEADER = T.let(T.unsafe(nil), String)
NewRelic::Agent::External::NON_HTTP_CAT_TXN_HEADER = T.let(T.unsafe(nil), String)
class NewRelic::Agent::ForceDisconnectException < ::StandardError; end

class NewRelic::Agent::ForceRestartException < ::StandardError
  def message; end
end

module NewRelic::Agent::GuidGenerator
  private

  def generate_guid(length = T.unsafe(nil)); end

  class << self
    def generate_guid(length = T.unsafe(nil)); end
  end
end

NewRelic::Agent::GuidGenerator::HEX_DIGITS = T.let(T.unsafe(nil), Array)
NewRelic::Agent::HOSTNAME_KEY = T.let(T.unsafe(nil), String)
module NewRelic::Agent::HTTPClients; end

module NewRelic::Agent::HTTPClients::URIUtil
  class << self
    def obfuscated_uri(url); end
    def parse_and_normalize_url(url); end
    def strip_query_string(fragment); end
  end
end

NewRelic::Agent::HTTPClients::URIUtil::QUESTION_MARK = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Harvester
  def initialize(events, after_forker = T.unsafe(nil)); end

  def harvest_thread_enabled?; end
  def mark_started(pid = T.unsafe(nil)); end
  def needs_restart?(pid = T.unsafe(nil)); end
  def on_transaction(*_); end
  def restart_harvest_thread; end
  def restart_in_children_enabled?; end
  def starting_pid; end
  def starting_pid=(_arg0); end
end

class NewRelic::Agent::Heap
  def initialize(items = T.unsafe(nil), &priority_fn); end

  def <<(item); end
  def [](index); end
  def []=(index, value); end
  def empty?; end
  def fix(index); end
  def pop; end
  def push(item); end
  def size; end
  def to_a; end

  private

  def heapify_down(parent_index); end
  def heapify_up(child_index); end
  def in_range?(index); end
  def left_child_index_for(parent_index); end
  def parent_index_for(child_index); end
  def priority(index); end
  def right_sibling_smaller?(lchild_index); end
  def swap(i, j); end
end

module NewRelic::Agent::Hostname
  class << self
    def get; end
    def get_dyno_prefixes; end
    def get_external(host_or_ip); end
    def get_fqdn; end
    def heroku_dyno_name_prefix(dyno_name); end
    def local?(host_or_ip); end
  end
end

NewRelic::Agent::Hostname::LOCALHOST = T.let(T.unsafe(nil), Array)

class NewRelic::Agent::InboundRequestMonitor
  def initialize(events); end

  def deserialize_header(encoded_header, key); end
  def obfuscator; end
  def setup_obfuscator; end
end

module NewRelic::Agent::Instrumentation; end

module NewRelic::Agent::Instrumentation::ControllerInstrumentation
  mixes_in_class_methods ::NewRelic::Agent::Instrumentation::ControllerInstrumentation::ClassMethods

  def perform_action_with_newrelic_trace(*args, &block); end

  protected

  def do_not_trace?; end
  def ignore_apdex?; end
  def ignore_enduser?; end
  def newrelic_request(args); end
  def newrelic_request_headers(request); end
  def newrelic_response_code; end

  private

  def _is_filtered?(key); end
  def create_transaction_options(trace_options, category, state, queue_start_time); end
  def detect_queue_start_time(request); end

  class << self
    def included(clazz); end
  end
end

module NewRelic::Agent::Instrumentation::ControllerInstrumentation::ClassMethods
  def add_transaction_tracer(method, options = T.unsafe(nil)); end
  def already_added_transaction_tracer?(target, with_method_name); end
  def build_method_names(traced_method, punctuation); end
  def generate_argument_list(options); end
  def newrelic_ignore(specifiers = T.unsafe(nil)); end
  def newrelic_ignore_apdex(specifiers = T.unsafe(nil)); end
  def newrelic_ignore_aspect(property, specifiers = T.unsafe(nil)); end
  def newrelic_ignore_enduser(specifiers = T.unsafe(nil)); end
  def newrelic_read_attr(attr_name); end
  def newrelic_write_attr(attr_name, value); end
  def parse_punctuation(method); end
end

module NewRelic::Agent::Instrumentation::ControllerInstrumentation::ClassMethodsShim
  def newrelic_ignore(*args); end
  def newrelic_ignore_apdex(*args); end
  def newrelic_ignore_enduser(*args); end
end

NewRelic::Agent::Instrumentation::ControllerInstrumentation::NR_DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)
NewRelic::Agent::Instrumentation::ControllerInstrumentation::NR_DO_NOT_TRACE_KEY = T.let(T.unsafe(nil), Symbol)
NewRelic::Agent::Instrumentation::ControllerInstrumentation::NR_IGNORE_APDEX_KEY = T.let(T.unsafe(nil), Symbol)
NewRelic::Agent::Instrumentation::ControllerInstrumentation::NR_IGNORE_ENDUSER_KEY = T.let(T.unsafe(nil), Symbol)

module NewRelic::Agent::Instrumentation::ControllerInstrumentation::Shim
  mixes_in_class_methods ::NewRelic::Agent::Instrumentation::ControllerInstrumentation::ClassMethodsShim

  def new_relic_trace_controller_action(*args); end
  def perform_action_with_newrelic_trace(*args); end

  class << self
    def included(clazz); end
  end
end

class NewRelic::Agent::Instrumentation::ControllerInstrumentation::TransactionNamer
  class << self
    def class_name(traced_obj, options = T.unsafe(nil)); end
    def name_for(txn, traced_obj, category, options = T.unsafe(nil)); end
    def path_name(traced_obj, options = T.unsafe(nil)); end
    def prefix_for_category(txn, category = T.unsafe(nil)); end
  end
end

module NewRelic::Agent::Instrumentation::IgnoreActions
  class << self
    def is_filtered?(key, klass, action_name); end
  end
end

module NewRelic::Agent::Instrumentation::QueueTime
  private

  def parse_frontend_timestamp(headers, now = T.unsafe(nil)); end
  def parse_timestamp(string); end
  def timestamp_string_from_header_value(value); end

  class << self
    def parse_frontend_timestamp(headers, now = T.unsafe(nil)); end
    def parse_timestamp(string); end
    def timestamp_string_from_header_value(value); end
  end
end

NewRelic::Agent::Instrumentation::QueueTime::ALL_QUEUE_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Instrumentation::QueueTime::CANDIDATE_HEADERS = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Instrumentation::QueueTime::DIVISORS = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Instrumentation::QueueTime::EARLIEST_ACCEPTABLE_TIME = T.let(T.unsafe(nil), Float)
NewRelic::Agent::Instrumentation::QueueTime::MIDDLEWARE_START_HEADER = T.let(T.unsafe(nil), String)
NewRelic::Agent::Instrumentation::QueueTime::QUEUE_START_HEADER = T.let(T.unsafe(nil), String)
NewRelic::Agent::Instrumentation::QueueTime::REQUEST_START_HEADER = T.let(T.unsafe(nil), String)
module NewRelic::Agent::Instrumentation::Resque; end

module NewRelic::Agent::Instrumentation::Resque::Helper
  extend ::NewRelic::Agent::Instrumentation::Resque::Helper

  def resque_fork_per_job?; end
end

class NewRelic::Agent::InternalAgentError < ::StandardError
  def initialize(msg = T.unsafe(nil)); end
end

class NewRelic::Agent::JavascriptInstrumentor
  include ::NewRelic::Coerce

  def initialize(event_listener); end

  def add_attributes(data, txn); end
  def add_ssl_for_http(data); end
  def append_agent_attributes!(txn, atts); end
  def append_custom_attributes!(txn, atts); end
  def browser_timing_config(state, nonce = T.unsafe(nil)); end
  def browser_timing_header(nonce = T.unsafe(nil)); end
  def browser_timing_loader(nonce = T.unsafe(nil)); end
  def create_nonce(nonce = T.unsafe(nil)); end
  def data_for_js_agent(transaction); end
  def enabled?; end
  def html_safe_if_needed(string); end
  def insert_js?(state); end
  def js_enabled_and_ready?; end
  def log_configuration; end
  def missing_config?(key); end
  def obfuscator; end
end

NewRelic::Agent::JavascriptInstrumentor::AGENT_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::APPLICATIONID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::APPLICATION_TIME_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::ATTS_AGENT_SUBKEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::ATTS_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::ATTS_USER_SUBKEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::BEACON_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::ERROR_BEACON_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::LICENSE_KEY_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::QUEUE_TIME_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::RUM_KEY_LENGTH = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::JavascriptInstrumentor::SSL_FOR_HTTP_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::JavascriptInstrumentor::TRANSACTION_NAME_KEY = T.let(T.unsafe(nil), String)
class NewRelic::Agent::LicenseException < ::StandardError; end

module NewRelic::Agent::LogOnce
  def clear_already_logged; end
  def log_once(level, key, *msgs); end
end

NewRelic::Agent::LogOnce::NUM_LOG_ONCE_KEYS = T.let(T.unsafe(nil), Integer)
module NewRelic::Agent::Logging; end

class NewRelic::Agent::Logging::DecoratingFormatter < ::Logger::Formatter
  def initialize; end

  def add_key_value(message, key, value); end
  def app_name; end
  def call(severity, time, progname, msg); end
  def clear_tags!; end
  def escape(message); end
end

NewRelic::Agent::Logging::DecoratingFormatter::CLOSING_BRACE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Logging::DecoratingFormatter::COLON = T.let(T.unsafe(nil), String)
NewRelic::Agent::Logging::DecoratingFormatter::COMMA = T.let(T.unsafe(nil), String)
NewRelic::Agent::Logging::DecoratingFormatter::LOG_LEVEL_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::Logging::DecoratingFormatter::LOG_NAME_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::Logging::DecoratingFormatter::MESSAGE_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::Logging::DecoratingFormatter::NEWLINE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Logging::DecoratingFormatter::QUOTE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Logging::DecoratingFormatter::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Logging::DecoratingLogger < ::ActiveSupport::Logger
  def initialize(*args, **kwargs); end

  def write(progname = T.unsafe(nil), &block); end
end

class NewRelic::Agent::MemoryLogger
  include ::NewRelic::Agent::LogOnce

  def initialize; end

  def debug(*msgs, &blk); end
  def dump(logger); end
  def error(*msgs, &blk); end
  def fatal(*msgs, &blk); end
  def info(*msgs, &blk); end
  def is_startup_logger?; end
  def level; end
  def level=(_arg0); end
  def log_exception(level, e, backtrace_level = T.unsafe(nil)); end
  def log_formatter; end
  def log_formatter=(_arg0); end
  def messages; end
  def messages=(_arg0); end
  def warn(*msgs, &blk); end
end

module NewRelic::Agent::MethodTracer
  mixes_in_class_methods ::NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer
  mixes_in_class_methods ::NewRelic::Agent::MethodTracer::ClassMethods

  def trace_execution_scoped(metric_names, options = T.unsafe(nil)); end
  def trace_execution_unscoped(metric_names, options = T.unsafe(nil)); end

  class << self
    def extended(klass); end
    def included(klass); end
  end
end

module NewRelic::Agent::MethodTracer::ClassMethods
  include ::NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer

  def add_method_tracer(method_name, metric_name = T.unsafe(nil), options = T.unsafe(nil)); end
  def remove_method_tracer(method_name); end

  private

  def _nr_add_method_tracer_now(method_name, metric_name, options); end
  def _nr_define_traced_method(method_name, scoped_metric: T.unsafe(nil), unscoped_metrics: T.unsafe(nil), code_header: T.unsafe(nil), code_footer: T.unsafe(nil), record_metrics: T.unsafe(nil), visibility: T.unsafe(nil)); end
  def _nr_scoped_unscoped_metrics(metric_name, method_name, push_scope: T.unsafe(nil)); end
end

module NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer
  def _nr_clear_traced_methods!; end
  def _nr_default_metric_name(method_name); end
  def _nr_derived_class_name; end
  def _nr_traced_method_module; end
  def _nr_validate_method_tracer_options(method_name, options); end
  def method_traced?(method_name); end
  def newrelic_method_exists?(method_name); end
end

NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer::ALLOWED_KEYS = T.let(T.unsafe(nil), Array)
NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer::DEFAULT_SETTINGS = T.let(T.unsafe(nil), Hash)

module NewRelic::Agent::MethodTracerHelpers
  extend ::NewRelic::Agent::MethodTracerHelpers

  def trace_execution_scoped(metric_names, options = T.unsafe(nil)); end
end

NewRelic::Agent::MethodTracerHelpers::MAX_ALLOWED_METRIC_DURATION = T.let(T.unsafe(nil), Integer)

class NewRelic::Agent::Monitors
  def initialize(events); end

  def cross_app_monitor; end
  def distributed_tracing_monitor; end
  def synthetics_monitor; end
end

class NewRelic::Agent::NewRelicService
  def initialize(license_key = T.unsafe(nil), collector = T.unsafe(nil)); end

  def agent_command_results(results); end
  def agent_id; end
  def agent_id=(id); end
  def analytic_event_data(data); end
  def build_metric_data_array(stats_hash); end
  def cert_file_path; end
  def close_shared_connection; end
  def collector; end
  def compress_request_if_needed(data, endpoint); end
  def connect(settings = T.unsafe(nil)); end
  def create_and_start_http_connection; end
  def create_http_connection; end
  def custom_event_data(data); end
  def error_data(unsent_errors); end
  def error_event_data(data); end
  def establish_shared_connection; end
  def force_restart; end
  def get_agent_commands; end
  def has_shared_connection?; end
  def http_connection; end
  def marshaller; end
  def metric_data(stats_hash); end
  def preconnect; end
  def profile_data(profile); end
  def request_timeout; end
  def request_timeout=(_arg0); end
  def session(&block); end
  def session_with_keepalive(&block); end
  def session_without_keepalive(&block); end
  def set_cert_store(conn); end
  def setup_connection_for_ssl(conn); end
  def setup_connection_timeouts(conn); end
  def shutdown(time); end
  def span_event_data(data); end
  def sql_trace_data(sql_traces); end
  def ssl_cert_store; end
  def start_connection(conn); end
  def transaction_sample_data(traces); end
  def valid_to_marshal?(data); end

  private

  def check_post_size(post_string, endpoint); end
  def control; end
  def decompress_response(response); end
  def generate_remote_method_uri(method); end
  def handle_serialization_error(method, e); end
  def invoke_remote(method, payload = T.unsafe(nil), options = T.unsafe(nil)); end
  def license_key; end
  def log_response(response); end
  def record_endpoint_attempts_supportability_metrics(endpoint); end
  def record_error_response_supportability_metrics(response_code); end
  def record_size_supportability_metrics(method, size_bytes, item_count); end
  def record_timing_supportability_metrics(method, start_ts, serialize_finish_ts, request_send_ts, response_check_ts); end
  def remote_method_uri(method); end
  def reset_remote_method_uris; end
  def send_request(opts); end
  def user_agent; end
end

NewRelic::Agent::NewRelicService::CONNECTION_ERRORS = T.let(T.unsafe(nil), Array)
module NewRelic::Agent::NewRelicService::Encoders; end

module NewRelic::Agent::NewRelicService::Encoders::Base64CompressedJSON
  class << self
    def encode(data, opts = T.unsafe(nil)); end
  end
end

module NewRelic::Agent::NewRelicService::Encoders::Compressed; end

module NewRelic::Agent::NewRelicService::Encoders::Compressed::Deflate
  class << self
    def encode(data, opts = T.unsafe(nil)); end
  end
end

module NewRelic::Agent::NewRelicService::Encoders::Compressed::Gzip
  class << self
    def encode(data, opts = T.unsafe(nil)); end
  end
end

NewRelic::Agent::NewRelicService::Encoders::Compressed::Gzip::BINARY = T.let(T.unsafe(nil), String)

module NewRelic::Agent::NewRelicService::Encoders::Identity
  class << self
    def encode(data, opts = T.unsafe(nil)); end
  end
end

class NewRelic::Agent::NewRelicService::JsonMarshaller < ::NewRelic::Agent::NewRelicService::Marshaller
  def initialize; end

  def default_encoder; end
  def dump(ruby, opts = T.unsafe(nil)); end
  def format; end
  def load(data); end
  def warn_for_yajl; end

  class << self
    def human_readable?; end
  end
end

NewRelic::Agent::NewRelicService::JsonMarshaller::OK_YAJL_VERSION = T.let(T.unsafe(nil), Gem::Version)

class NewRelic::Agent::NewRelicService::Marshaller
  def default_encoder; end
  def prepare(data, options = T.unsafe(nil)); end

  protected

  def return_value(data); end

  class << self
    def human_readable?; end
  end
end

NewRelic::Agent::NewRelicService::PROTOCOL_VERSION = T.let(T.unsafe(nil), Integer)

module NewRelic::Agent::NewRelicService::SecurityPolicySettings
  class << self
    def preliminary_settings(security_policies); end
  end
end

NewRelic::Agent::NewRelicService::SecurityPolicySettings::EXPECTED_SECURITY_POLICIES = T.let(T.unsafe(nil), Array)

class NewRelic::Agent::NewRelicService::SecurityPolicySettings::Validator
  def initialize(preconnect_response); end

  def validate_matching_agent_config!; end
end

class NewRelic::Agent::NoticibleError
  def initialize(class_name, message); end

  def class_name; end
  def message; end
end

class NewRelic::Agent::NullLogger
  def debug(*args); end
  def error(*args); end
  def fatal(*args); end
  def info(*args); end
  def method_missing(method, *args, &blk); end
  def warn(*args); end
end

class NewRelic::Agent::Obfuscator
  def initialize(key, length = T.unsafe(nil)); end

  def deobfuscate(text); end
  def encode(text); end
  def key_bytes; end
  def obfuscate(text); end
end

NewRelic::Agent::Obfuscator::EMPTY_KEY_BYTES = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Obfuscator::PACK_FORMAT = T.let(T.unsafe(nil), String)

module NewRelic::Agent::PayloadMetricMapping
  class << self
    def append_mapped_metrics(txn_metrics, sample); end

    private

    def map_metric(metric_name, to_add = T.unsafe(nil)); end
  end
end

NewRelic::Agent::PayloadMetricMapping::SPEC_MAPPINGS = T.let(T.unsafe(nil), Hash)

module NewRelic::Agent::PipeChannelManager
  extend ::NewRelic::Agent::PipeChannelManager

  def channels; end
  def listener; end
  def register_report_channel(id); end
end

class NewRelic::Agent::PipeChannelManager::Listener
  def initialize; end

  def close_all_pipes; end
  def pipes; end
  def pipes=(_arg0); end
  def register_pipe(id); end
  def select_timeout; end
  def select_timeout=(_arg0); end
  def start; end
  def started?; end
  def stop; end
  def stop_listener_thread; end
  def thread; end
  def timeout; end
  def timeout=(_arg0); end
  def wake; end
  def wakeup; end

  protected

  def clean_up_pipes; end
  def find_pipe_for_handle(out_handle); end
  def merge_data_from_pipe(pipe_handle); end
  def should_keep_listening?; end
  def unmarshal(data); end
end

class NewRelic::Agent::PipeChannelManager::Pipe
  def initialize; end

  def after_fork_in_child; end
  def after_fork_in_parent; end
  def close; end
  def closed?; end
  def deserialize_message_length(data); end
  def eof?; end
  def in; end
  def in=(_arg0); end
  def last_read; end
  def out; end
  def out=(_arg0); end
  def parent_pid; end
  def read; end
  def serialize_message_length(data); end
  def write(data); end
end

NewRelic::Agent::PipeChannelManager::Pipe::NUM_LENGTH_BYTES = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::PipeChannelManager::Pipe::READY_MARKER = T.let(T.unsafe(nil), String)

class NewRelic::Agent::PipeService
  def initialize(channel_id); end

  def agent_id; end
  def agent_id=(_arg0); end
  def analytic_event_data(events); end
  def buffer; end
  def channel_id; end
  def collector; end
  def collector=(_arg0); end
  def connect(config); end
  def custom_event_data(events); end
  def error_data(errors); end
  def error_event_data(events); end
  def get_agent_commands; end
  def metric_data(unsent_timeslice_data); end
  def pipe; end
  def request_timeout; end
  def request_timeout=(_arg0); end
  def session; end
  def shutdown; end
  def span_event_data(events); end
  def sql_trace_data(sql); end
  def transaction_sample_data(transactions); end

  private

  def marshal_payload(data); end
  def write_to_pipe(endpoint, data); end
end

class NewRelic::Agent::PrioritySampledBuffer < ::NewRelic::Agent::EventBuffer
  def initialize(capacity); end

  def append(priority: T.unsafe(nil), event: T.unsafe(nil), &blk); end
  def append_event(priority: T.unsafe(nil), event: T.unsafe(nil), &blk); end
  def capacity=(new_capacity); end
  def captured_lifetime; end
  def decrement_lifetime_counts_by(n); end
  def heapify_items_array; end
  def metadata; end
  def sample_rate_lifetime; end
  def seen_lifetime; end
  def to_a; end

  private

  def increment_seen; end
  def priority_for(event); end
end

NewRelic::Agent::PrioritySampledBuffer::PRIORITY_KEY = T.let(T.unsafe(nil), String)

module NewRelic::Agent::RangeExtensions
  private

  def compute_overlap(range, ranges); end
  def intersects?(r1, r2); end
  def merge(r1, r2); end
  def merge_or_append(range, ranges); end

  class << self
    def compute_overlap(range, ranges); end
    def intersects?(r1, r2); end
    def merge(r1, r2); end
    def merge_or_append(range, ranges); end
  end
end

class NewRelic::Agent::RulesEngine
  include ::Enumerable
  extend ::Forwardable

  def initialize(rules = T.unsafe(nil), segment_term_rules = T.unsafe(nil)); end

  def apply_rules(rules, string); end
  def clear(*args, &block); end
  def each(*args, &block); end
  def inspect(*args, &block); end
  def rename(original_string); end
  def size(*args, &block); end

  class << self
    def create_metric_rules(connect_response); end
    def create_transaction_rules(connect_response); end
    def reject_rules_with_duplicate_prefixes!(rules); end
  end
end

NewRelic::Agent::RulesEngine::LEADING_SLASH_REGEX = T.let(T.unsafe(nil), Regexp)

class NewRelic::Agent::RulesEngine::ReplacementRule
  def initialize(options); end

  def <=>(other); end
  def apply(string); end
  def apply_replacement(string); end
  def apply_to_each_segment(string); end
  def each_segment; end
  def eval_order; end
  def ignore; end
  def match_expression; end
  def matches?(string); end
  def replace_all; end
  def replacement; end
  def terminal?; end
  def terminate_chain; end
end

NewRelic::Agent::RulesEngine::SEGMENT_SEPARATOR = T.let(T.unsafe(nil), String)

class NewRelic::Agent::RulesEngine::SegmentTermsRule
  def initialize(options); end

  def apply(string); end
  def collapse_adjacent_placeholder_segments(segments); end
  def matches?(string); end
  def prefix; end
  def prefix_matches_on_segment_boundary?(string); end
  def terminal?; end
  def terms; end

  class << self
    def valid?(rule_spec); end
    def valid_prefix_segment_count?(prefix); end
  end
end

NewRelic::Agent::RulesEngine::SegmentTermsRule::ADJACENT_PLACEHOLDERS_REGEX = T.let(T.unsafe(nil), Regexp)
NewRelic::Agent::RulesEngine::SegmentTermsRule::ADJACENT_PLACEHOLDERS_REPLACEMENT = T.let(T.unsafe(nil), String)
NewRelic::Agent::RulesEngine::SegmentTermsRule::PREFIX_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::RulesEngine::SegmentTermsRule::SEGMENT_PLACEHOLDER = T.let(T.unsafe(nil), String)
NewRelic::Agent::RulesEngine::SegmentTermsRule::TERMS_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::RulesEngine::SegmentTermsRule::VALID_PREFIX_SEGMENT_COUNT = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::SPAN_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SUPPORTABILITY_INCREMENT_METRIC = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Sampler
  def initialize(id = T.unsafe(nil)); end

  def id; end
  def poll; end

  class << self
    def enabled?; end
    def inherited(subclass); end
    def named(new_name); end
    def sampler_classes; end
    def shorthand_name; end
    def supported_on_this_platform?; end
  end
end

class NewRelic::Agent::Sampler::Unsupported < ::StandardError; end

class NewRelic::Agent::SamplerCollection
  include ::Enumerable

  def initialize(event_listener); end

  def add_sampler(sampler_class); end
  def clear; end
  def each(&blk); end
  def load_samplers; end
  def poll_samplers; end
  def sampler_class_registered?(sampler_class); end
end

module NewRelic::Agent::Samplers; end

class NewRelic::Agent::Samplers::CpuSampler < ::NewRelic::Agent::Sampler
  def initialize; end

  def last_time; end
  def poll; end
  def record_system_util(value); end
  def record_systemtime(value); end
  def record_user_util(value); end
  def record_usertime(value); end

  class << self
    def supported_on_this_platform?; end
  end
end

class NewRelic::Agent::Samplers::DelayedJobSampler < ::NewRelic::Agent::Sampler
  def initialize; end

  def count(query); end
  def failed_jobs; end
  def locked_jobs; end
  def poll; end
  def record_failed_jobs(value); end
  def record_locked_jobs(value); end

  private

  def queue_counts(column_name); end
  def record_counts_by(column_name, metric_node = T.unsafe(nil)); end
  def record_queue_length_metrics; end

  class << self
    def supported_backend?; end
    def supported_on_this_platform?; end
  end
end

NewRelic::Agent::Samplers::DelayedJobSampler::FAILED_QUERY = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::DelayedJobSampler::LOCKED_QUERY = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::DelayedJobSampler::QUEUE_QUERY_CONDITION = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Samplers::MemorySampler < ::NewRelic::Agent::Sampler
  def initialize; end

  def platform; end
  def poll; end
  def sampler; end
  def sampler=(_arg0); end

  class << self
    def platform; end
    def supported_on_this_platform?; end
  end
end

class NewRelic::Agent::Samplers::MemorySampler::Base
  def initialize; end

  def can_run?; end
  def get_sample; end
end

class NewRelic::Agent::Samplers::MemorySampler::JavaHeapSampler < ::NewRelic::Agent::Samplers::MemorySampler::Base
  def get_memory; end
  def to_s; end
end

class NewRelic::Agent::Samplers::MemorySampler::ProcStatus < ::NewRelic::Agent::Samplers::MemorySampler::Base
  def get_memory; end
  def proc_status_file; end
  def to_s; end
end

class NewRelic::Agent::Samplers::MemorySampler::ShellPS < ::NewRelic::Agent::Samplers::MemorySampler::Base
  def initialize(command); end

  def get_memory; end
  def to_s; end
end

class NewRelic::Agent::Samplers::ObjectSampler < ::NewRelic::Agent::Sampler
  def poll; end

  class << self
    def supported_on_this_platform?; end
  end
end

class NewRelic::Agent::Samplers::VMSampler < ::NewRelic::Agent::Sampler
  def initialize; end

  def on_transaction_finished(*_); end
  def poll; end
  def record_delta(snapshot, key, metric, txn_count); end
  def record_gauge_metric(metric_name, value); end
  def record_gc_runs_metric(snapshot, txn_count); end
  def record_heap_free_metric(snapshot); end
  def record_heap_live_metric(snapshot); end
  def record_thread_count_metric(snapshot); end
  def reset_transaction_count; end
  def setup_events(event_listener); end
  def take_snapshot; end
  def transaction_count; end
end

NewRelic::Agent::Samplers::VMSampler::CONSTANT_INVALIDATIONS_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::VMSampler::GC_RUNS_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::VMSampler::HEAP_FREE_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::VMSampler::HEAP_LIVE_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::VMSampler::MAJOR_GC_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::VMSampler::METHOD_INVALIDATIONS_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::VMSampler::MINOR_GC_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::VMSampler::OBJECT_ALLOCATIONS_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Samplers::VMSampler::THREAD_COUNT_METRIC = T.let(T.unsafe(nil), String)
class NewRelic::Agent::SerializationError < ::StandardError; end
class NewRelic::Agent::ServerConnectionException < ::StandardError; end

class NewRelic::Agent::SlowSql
  def initialize(statement, metric_name, duration, backtrace = T.unsafe(nil), params = T.unsafe(nil)); end

  def backtrace; end
  def base_params; end
  def duration; end
  def explain; end
  def metric_name; end
  def normalize; end
  def obfuscate; end
  def prepare_to_send; end
  def sql; end
  def statement; end
end

class NewRelic::Agent::SpanEventAggregator < ::NewRelic::Agent::EventAggregator
  def after_harvest(metadata); end
  def record(priority: T.unsafe(nil), event: T.unsafe(nil), &blk); end
end

NewRelic::Agent::SpanEventAggregator::SUPPORTABILITY_DISCARDED = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventAggregator::SUPPORTABILITY_TOTAL_SEEN = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventAggregator::SUPPORTABILITY_TOTAL_SENT = T.let(T.unsafe(nil), String)

module NewRelic::Agent::SpanEventPrimitive
  include ::NewRelic::Coerce
  extend ::NewRelic::Coerce
  extend ::NewRelic::Agent::SpanEventPrimitive

  def error_attributes(segment); end
  def for_datastore_segment(segment); end
  def for_external_request_segment(segment); end
  def for_segment(segment); end

  private

  def agent_attributes(segment); end
  def allowed?(key); end
  def custom_attributes(segment); end
  def intrinsics_for(segment); end
  def merge_and_freeze_attributes(agent_attributes, error_attributes); end
  def milliseconds_since_epoch(segment); end
  def parent_guid(segment); end
  def truncate(value, max_size = T.unsafe(nil)); end
end

NewRelic::Agent::SpanEventPrimitive::CATEGORY_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::CLIENT = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::COMPONENT_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::DATASTORE_CATEGORY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::DB_INSTANCE_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::DB_STATEMENT_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::DURATION_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::ELLIPSIS = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::ENTRY_POINT_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::EVENT_TYPE = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::GENERIC_CATEGORY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::GRANDPARENT_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::GUID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::HTTP_CATEGORY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::HTTP_METHOD_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::HTTP_STATUS_CODE_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::HTTP_URL_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::NAME_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::PARENT_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::PEER_ADDRESS_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::PEER_HOSTNAME_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::PRIORITY_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::SAMPLED_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::SPAN_KIND_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::TRACE_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::TRACING_VENDORS_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::TRANSACTION_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::TRANSACTION_NAME_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::TRUSTED_PARENT_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::SpanEventPrimitive::TYPE_KEY = T.let(T.unsafe(nil), String)

class NewRelic::Agent::SqlSampler
  def initialize; end

  def disabled; end
  def distributed_trace_attributes(state); end
  def enabled?; end
  def harvest!; end
  def has_room?; end
  def merge!(sql_traces); end
  def notice_sql(sql, metric_name, config, duration, state = T.unsafe(nil), explainer = T.unsafe(nil), binds = T.unsafe(nil), name = T.unsafe(nil)); end
  def notice_sql_statement(statement, metric_name, duration); end
  def on_finishing_transaction(state, name); end
  def on_start_transaction(state, uri = T.unsafe(nil)); end
  def remove_shortest_trace; end
  def reset!; end
  def save_slow_sql(transaction_sql_data); end
  def should_add_trace?(sql_item); end
  def sql_traces; end
  def tl_transaction_data; end
end

NewRelic::Agent::SqlSampler::MAX_SAMPLES = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::SqlSampler::PRIORITY = T.let(T.unsafe(nil), String)

class NewRelic::Agent::SqlTrace < ::NewRelic::Agent::Stats
  include ::NewRelic::Coerce

  def initialize(normalized_query, slow_sql, path, uri); end

  def aggregate(slow_sql, path, uri); end
  def aggregate_trace(trace); end
  def database_metric_name; end
  def need_to_explain?; end
  def need_to_obfuscate?; end
  def params; end
  def path; end
  def prepare_to_send; end
  def set_primary(slow_sql, path, uri); end
  def slow_sql; end
  def sql; end
  def sql_id; end
  def to_collector_array(encoder); end
  def url; end

  private

  def consistent_hash(string); end
end

class NewRelic::Agent::StartupLogger < ::NewRelic::Agent::MemoryLogger
  include ::Singleton
  extend ::Singleton::SingletonClassMethods
end

class NewRelic::Agent::Stats
  def initialize; end

  def ==(other); end
  def apdex_f; end
  def apdex_s; end
  def apdex_t; end
  def call_count; end
  def call_count=(_arg0); end
  def increment_count(value = T.unsafe(nil)); end
  def inspect_full; end
  def is_reset?; end
  def max_call_time; end
  def max_call_time=(_arg0); end
  def merge(other_stats); end
  def merge!(other); end
  def min_call_time; end
  def min_call_time=(_arg0); end
  def record(value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end
  def record_apdex(bucket, apdex_t); end
  def record_data_point(value, exclusive_time = T.unsafe(nil)); end
  def reset; end
  def sum_of_squares; end
  def sum_of_squares=(_arg0); end
  def to_json(*_); end
  def to_s; end
  def total_call_time; end
  def total_call_time=(_arg0); end
  def total_exclusive_time; end
  def total_exclusive_time=(_arg0); end
  def trace_call(value, exclusive_time = T.unsafe(nil)); end

  protected

  def min_time_less?(other); end
end

class NewRelic::Agent::StatsEngine
  def initialize; end

  def apply_rules_to_metric_data(rules_engine, stats_hash); end
  def clear_stats; end
  def coerce_to_metric_spec_array(metric_names_or_specs, scope); end
  def harvest!; end
  def merge!(other_stats_hash); end
  def merge_transaction_metrics!(txn_metrics, scope); end
  def metric_rules; end
  def metric_rules=(_arg0); end
  def record_scoped_and_unscoped_metrics(state, scoped_metric, summary_metrics = T.unsafe(nil), value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end
  def record_unscoped_metrics(state, metric_names, value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end
  def reset!; end
  def tl_record_scoped_and_unscoped_metrics(scoped_metric, summary_metrics = T.unsafe(nil), value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end
  def tl_record_supportability_metric_count(metric, value); end
  def tl_record_unscoped_metrics(metric_names, value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end
  def to_h; end
  def with_stats_lock; end
end

module NewRelic::Agent::StatsEngine::GCProfiler
  class << self
    def gc_metric_name; end
    def init; end
    def record_delta(start_snapshot, end_snapshot); end
    def record_gc_metric(call_count, elapsed); end
    def reset; end
    def take_snapshot; end
  end
end

class NewRelic::Agent::StatsEngine::GCProfiler::CoreGCProfiler
  def call_count; end
  def call_time_s; end
  def reset; end

  class << self
    def enabled?; end
  end
end

class NewRelic::Agent::StatsEngine::GCProfiler::GCSnapshot < ::Struct
  def gc_call_count; end
  def gc_call_count=(_); end
  def gc_time_s; end
  def gc_time_s=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

NewRelic::Agent::StatsEngine::GCProfiler::GC_OTHER = T.let(T.unsafe(nil), String)
NewRelic::Agent::StatsEngine::GCProfiler::GC_ROLLUP = T.let(T.unsafe(nil), String)
NewRelic::Agent::StatsEngine::GCProfiler::GC_WEB = T.let(T.unsafe(nil), String)

class NewRelic::Agent::StatsEngine::GCProfiler::RailsBenchProfiler
  def call_count; end
  def call_time_s; end
  def reset; end

  class << self
    def enabled?; end
  end
end

class NewRelic::Agent::StatsHash
  def initialize(started_at = T.unsafe(nil)); end

  def ==(other); end
  def [](key); end
  def each; end
  def empty?; end
  def handle_stats_lookup_error(key, hash, error); end
  def harvested_at; end
  def harvested_at=(_arg0); end
  def marshal_dump; end
  def marshal_load(data); end
  def merge!(other); end
  def merge_or_insert(target, name, stats); end
  def merge_transaction_metrics!(txn_metrics, scope); end
  def record(metric_specs, value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end
  def size; end
  def started_at; end
  def started_at=(_arg0); end
  def to_h; end
end

class NewRelic::Agent::StatsHash::StatsHashLookupError < ::NewRelic::Agent::InternalAgentError
  def initialize(original_error, hash, metric_spec); end
end

class NewRelic::Agent::SyntheticsEventAggregator < ::NewRelic::Agent::EventAggregator
  def record(event); end

  private

  def after_harvest(metadata); end
  def record_dropped_synthetics(metadata); end
end

NewRelic::Agent::SyntheticsEventAggregator::TIMESTAMP = T.let(T.unsafe(nil), String)

class NewRelic::Agent::SyntheticsMonitor < ::NewRelic::Agent::InboundRequestMonitor
  def on_before_call(request); end
  def on_finished_configuring(events); end

  class << self
    def is_supported_version?(incoming_payload); end
    def is_trusted?(incoming_payload); end
    def is_valid_payload?(incoming_payload); end
    def reject_messaging_synthetics_header(headers); end
  end
end

NewRelic::Agent::SyntheticsMonitor::EXPECTED_PAYLOAD_LENGTH = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::SyntheticsMonitor::SUPPORTED_VERSION = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::SyntheticsMonitor::SYNTHETICS_HEADER_KEY = T.let(T.unsafe(nil), String)

module NewRelic::Agent::SystemInfo
  class << self
    def boot_id; end
    def bsd?; end
    def clear_processor_info; end
    def darwin?; end
    def docker_container_id; end
    def get_processor_info; end
    def ip_addresses; end
    def linux?; end
    def num_logical_processors; end
    def num_physical_cores; end
    def num_physical_packages; end
    def os_version; end
    def parse_cgroup_ids(cgroup_info); end
    def parse_cpuinfo(cpuinfo); end
    def parse_docker_container_id(cgroup_info); end
    def parse_linux_meminfo_in_mib(meminfo); end
    def proc_try_read(path); end
    def processor_arch; end
    def ram_in_mib; end
    def ruby_os_identifier; end
    def sysctl_value(name); end
  end
end

NewRelic::Agent::TRACE_ID_KEY = T.let(T.unsafe(nil), String)
module NewRelic::Agent::Threading; end

class NewRelic::Agent::Threading::AgentThread
  class << self
    def backing_thread_class; end
    def backing_thread_class=(clazz); end
    def bucket_thread(thread, profile_agent_code); end
    def create(label, &blk); end
    def list; end
    def scrub_backtrace(thread, profile_agent_code); end
  end
end

class NewRelic::Agent::Threading::BacktraceBase
  def initialize; end

  def add_child(child); end
  def add_child_unless_present(child); end
  def children; end
  def find_child(raw_line); end
end

class NewRelic::Agent::Threading::BacktraceNode < ::NewRelic::Agent::Threading::BacktraceBase
  include ::NewRelic::Coerce

  def initialize(line); end

  def ==(other); end
  def as_array; end
  def complete_array_conversion; end
  def depth; end
  def depth=(_arg0); end
  def dump_string(indent = T.unsafe(nil)); end
  def file; end
  def line_no; end
  def mark_for_array_conversion; end
  def method; end
  def parse_backtrace_frame(frame); end
  def raw_line; end
  def runnable_count; end
  def runnable_count=(_arg0); end
end

class NewRelic::Agent::Threading::BacktraceRoot < ::NewRelic::Agent::Threading::BacktraceBase
  def initialize; end

  def ==(other); end
  def aggregate(backtrace); end
  def as_array; end
  def dump_string; end
  def flattened; end
end

class NewRelic::Agent::Threading::BacktraceService
  def initialize(event_listener = T.unsafe(nil)); end

  def adjust_polling_time(now, poll_start); end
  def aggregate_backtraces(backtraces, name, start, duration, bucket, thread); end
  def aggregate_global_backtrace(backtrace, bucket, thread); end
  def allowed_bucket?(bucket); end
  def buffer; end
  def buffer_backtrace_for_thread(thread, timestamp, backtrace, bucket); end
  def effective_polling_period; end
  def effective_polling_period=(new_period); end
  def find_effective_polling_period; end
  def harvest(transaction_name); end
  def need_backtrace?(bucket); end
  def on_transaction_finished(payload); end
  def overhead_percent_threshold; end
  def poll; end
  def profile_agent_code; end
  def profile_agent_code=(_arg0); end
  def profiles; end
  def record_polling_time(now, poll_start); end
  def record_skew(poll_start); end
  def record_supportability_metrics(now, poll_start); end
  def running?; end
  def sample_thread(thread); end
  def should_buffer?(bucket); end
  def should_profile_agent_code?; end
  def start; end
  def stop; end
  def subscribe(transaction_name, command_arguments = T.unsafe(nil)); end
  def subscribed?(transaction_name); end
  def unsubscribe(transaction_name); end
  def update_values_from_profiles; end
  def watching_for_transaction?; end
  def worker_loop; end
  def worker_thread; end
  def worker_thread=(_arg0); end

  class << self
    def is_resque?; end
    def is_supported?; end
  end
end

NewRelic::Agent::Threading::BacktraceService::ALL_TRANSACTIONS = T.let(T.unsafe(nil), String)
NewRelic::Agent::Threading::BacktraceService::MAX_BUFFER_LENGTH = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::Threading::MAX_THREAD_PROFILE_DEPTH = T.let(T.unsafe(nil), Integer)

class NewRelic::Agent::Threading::ThreadProfile
  include ::NewRelic::Coerce

  def initialize(command_arguments = T.unsafe(nil)); end

  def aggregate(backtrace, bucket, thread); end
  def backtrace_count; end
  def command_arguments; end
  def convert_N_trace_nodes_to_arrays(count_to_keep); end
  def created_at; end
  def duration; end
  def empty?; end
  def failure_count; end
  def finished_at; end
  def finished_at=(_arg0); end
  def generate_traces; end
  def increment_poll_count; end
  def poll_count; end
  def profile_agent_code; end
  def profile_id; end
  def requested_period; end
  def sample_period; end
  def to_collector_array(encoder); end
  def to_log_description; end
  def traces; end
  def unique_thread_count; end
end

NewRelic::Agent::Threading::ThreadProfile::THREAD_PROFILER_NODES = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::Threading::UNKNOWN_LINE_NUMBER = T.let(T.unsafe(nil), Integer)

class NewRelic::Agent::TimestampSampledBuffer < ::NewRelic::Agent::PrioritySampledBuffer
  private

  def priority_for(event); end
end

NewRelic::Agent::TimestampSampledBuffer::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)

class NewRelic::Agent::TraceContextPayload
  extend ::NewRelic::Coerce

  def initialize(version, parent_type_id, parent_account_id, parent_app_id, id, transaction_id, sampled, priority, timestamp); end

  def id; end
  def id=(_arg0); end
  def parent_account_id; end
  def parent_account_id=(_arg0); end
  def parent_app_id; end
  def parent_app_id=(_arg0); end
  def parent_type; end
  def parent_type_id; end
  def parent_type_id=(_arg0); end
  def priority; end
  def priority=(_arg0); end
  def sampled; end
  def sampled=(_arg0); end
  def sampled?; end
  def timestamp; end
  def timestamp=(_arg0); end
  def to_s; end
  def transaction_id; end
  def transaction_id=(_arg0); end
  def valid?; end
  def version; end
  def version=(_arg0); end

  class << self
    def create(version: T.unsafe(nil), parent_type: T.unsafe(nil), parent_account_id: T.unsafe(nil), parent_app_id: T.unsafe(nil), id: T.unsafe(nil), transaction_id: T.unsafe(nil), sampled: T.unsafe(nil), priority: T.unsafe(nil), timestamp: T.unsafe(nil)); end
    def from_s(payload_string); end

    private

    def handle_invalid_payload(error: T.unsafe(nil), message: T.unsafe(nil)); end
    def now_ms; end
  end
end

NewRelic::Agent::TraceContextPayload::DELIMITER = T.let(T.unsafe(nil), String)
NewRelic::Agent::TraceContextPayload::FALSE_CHAR = T.let(T.unsafe(nil), String)
NewRelic::Agent::TraceContextPayload::PARENT_TYPE = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::TraceContextPayload::PARENT_TYPES = T.let(T.unsafe(nil), Array)
NewRelic::Agent::TraceContextPayload::SUPPORTABILITY_PARSE_EXCEPTION = T.let(T.unsafe(nil), String)
NewRelic::Agent::TraceContextPayload::TRUE_CHAR = T.let(T.unsafe(nil), String)
NewRelic::Agent::TraceContextPayload::VERSION = T.let(T.unsafe(nil), Integer)

class NewRelic::Agent::Tracer
  class << self
    def accept_distributed_trace_payload(payload); end
    def capture_segment_error(segment); end
    def clear_state; end
    def create_distributed_trace_payload; end
    def current_segment; end
    def current_span_id; end
    def current_trace_id; end
    def current_transaction; end
    def in_transaction(name: T.unsafe(nil), partial_name: T.unsafe(nil), category: T.unsafe(nil), options: T.unsafe(nil)); end
    def sampled?; end
    def span_id; end
    def start_datastore_segment(product: T.unsafe(nil), operation: T.unsafe(nil), collection: T.unsafe(nil), host: T.unsafe(nil), port_path_or_id: T.unsafe(nil), database_name: T.unsafe(nil), start_time: T.unsafe(nil), parent: T.unsafe(nil)); end
    def start_external_request_segment(library:, uri:, procedure:, start_time: T.unsafe(nil), parent: T.unsafe(nil)); end
    def start_message_broker_segment(action:, library:, destination_type:, destination_name:, headers: T.unsafe(nil), parameters: T.unsafe(nil), start_time: T.unsafe(nil), parent: T.unsafe(nil)); end
    def start_segment(name:, unscoped_metrics: T.unsafe(nil), start_time: T.unsafe(nil), parent: T.unsafe(nil)); end
    def start_transaction(category:, name: T.unsafe(nil), partial_name: T.unsafe(nil), **options); end
    def start_transaction_or_segment(category:, name: T.unsafe(nil), partial_name: T.unsafe(nil), options: T.unsafe(nil)); end
    def state; end
    def state_for(thread); end
    def tl_clear; end
    def tl_get; end
    def tl_state_for(thread); end
    def trace_id; end
    def tracing_enabled?; end
    def transaction_sampled?; end

    private

    def log_error(method_name, exception); end
    def start_and_add_segment(segment, parent = T.unsafe(nil)); end
  end
end

class NewRelic::Agent::Tracer::State
  def initialize; end

  def current_transaction; end
  def is_execution_traced?; end
  def is_sql_recorded?; end
  def pop_traced; end
  def push_traced(should_trace); end
  def record_sql; end
  def record_sql=(_arg0); end
  def reset(transaction = T.unsafe(nil)); end
  def sql_sampler_transaction_data; end
  def sql_sampler_transaction_data=(_arg0); end
  def tracing_enabled?; end
  def untraced; end
  def untraced=(_arg0); end
end

class NewRelic::Agent::Transaction
  include ::NewRelic::Agent::Transaction::Tracing

  def initialize(category, options); end

  def abort_transaction!; end
  def add_agent_attribute(key, value, default_destinations); end
  def add_custom_attributes(p); end
  def apdex_bucket(duration, current_apdex_t); end
  def apdex_start; end
  def apdex_start=(_arg0); end
  def apdex_t; end
  def append_apdex_perf_zone(payload); end
  def append_synthetics_to(payload); end
  def assign_agent_attributes; end
  def assign_intrinsics; end
  def assign_segment_dt_attributes; end
  def attributes; end
  def background_summary_metrics; end
  def best_name; end
  def calculate_gc_time; end
  def calculate_transport_duration(distributed_trace_payload); end
  def category; end
  def commit!(outermost_node_name); end
  def cpu_burn; end
  def create_initial_segment; end
  def create_nested_segment(category, options); end
  def create_segment(name); end
  def default_name=(name); end
  def distributed_tracer; end
  def duration; end
  def end_time; end
  def exceptions; end
  def exceptions=(_arg0); end
  def filtered_params; end
  def filtered_params=(_arg0); end
  def finish; end
  def freeze_name_and_execute_if_not_ignored; end
  def gc_start_snapshot; end
  def generate_payload; end
  def guid; end
  def had_error_affecting_apdex?; end
  def http_response_code; end
  def http_response_code=(_arg0); end
  def ignore!; end
  def ignore?; end
  def ignore_apdex!; end
  def ignore_apdex?; end
  def ignore_enduser!; end
  def ignore_enduser?; end
  def ignore_trace?; end
  def include_guid?; end
  def influences_transaction_name?(category); end
  def initial_segment; end
  def instrumentation_state; end
  def is_synthetics_request?; end
  def jruby_cpu_burn; end
  def jruby_cpu_start; end
  def jruby_cpu_start=(_arg0); end
  def log_frozen_name(name); end
  def merge_metrics; end
  def merge_request_parameters(params); end
  def merge_untrusted_agent_attributes(attributes, prefix, default_destinations); end
  def metrics; end
  def name_frozen?; end
  def needs_middleware_summary_metrics?(name); end
  def nest_initial_segment; end
  def nesting_max_depth; end
  def normal_cpu_burn; end
  def notice_error(error, options = T.unsafe(nil)); end
  def overridden_name=(name); end
  def parent_span_id; end
  def parent_span_id=(_arg0); end
  def payload; end
  def priority; end
  def priority=(_arg0); end
  def process_cpu_start; end
  def process_cpu_start=(_arg0); end
  def promoted_transaction_name(name); end
  def queue_time; end
  def raw_synthetics_header; end
  def raw_synthetics_header=(_arg0); end
  def record_apdex; end
  def record_apdex_metrics(rollup_metric, transaction_prefix, current_apdex_t); end
  def record_exceptions; end
  def record_queue_time; end
  def record_summary_metrics(outermost_node_name); end
  def record_transaction_event; end
  def recording_web_transaction?; end
  def referer; end
  def request_path; end
  def request_port; end
  def response_content_length; end
  def response_content_length=(_arg0); end
  def response_content_type; end
  def response_content_type=(_arg0); end
  def sampled=(_arg0); end
  def sampled?; end
  def segments; end
  def send_transaction_finished_event; end
  def set_default_transaction_name(name, category); end
  def set_overriding_transaction_name(name, category); end
  def similar_category?(category); end
  def start; end
  def start_time; end
  def start_time=(_arg0); end
  def state; end
  def state=(_arg0); end
  def summary_metrics; end
  def synthetics_account_id; end
  def synthetics_job_id; end
  def synthetics_monitor_id; end
  def synthetics_payload; end
  def synthetics_payload=(_arg0); end
  def synthetics_resource_id; end
  def synthetics_version; end
  def threshold; end
  def trace_id; end
  def trace_id=(value); end
  def transaction_name; end
  def transaction_specific_apdex_t; end
  def transaction_trace; end
  def user_defined_rules_ignore?; end
  def web_category?(category); end
  def with_database_metric_name(model, method, product = T.unsafe(nil)); end

  private

  def agent; end
  def jruby_cpu_time; end
  def process_cpu; end
  def sql_sampler; end
  def transaction_sampler; end

  class << self
    def abort_transaction!; end
    def add_agent_attribute(key, value, default_destinations); end
    def apdex_bucket(duration, failed, apdex_t); end
    def merge_untrusted_agent_attributes(attributes, prefix, default_destinations); end
    def name_from_partial(partial_name, category); end
    def nested_transaction_name(name); end
    def notice_error(e, options = T.unsafe(nil)); end
    def recording_web_transaction?; end
    def set_default_transaction_name(partial_name, category = T.unsafe(nil)); end
    def set_overriding_transaction_name(partial_name, category = T.unsafe(nil)); end
    def start_new_transaction(state, category, options); end
    def tl_current; end
  end
end

NewRelic::Agent::Transaction::ACTION_CABLE_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::APDEX_ALL_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::APDEX_F = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::APDEX_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::APDEX_OTHER_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::APDEX_OTHER_TXN_METRIC_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::APDEX_S = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::APDEX_T = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::APDEX_TXN_METRIC_PREFIX = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Transaction::AbstractSegment
  def initialize(name = T.unsafe(nil), start_time = T.unsafe(nil)); end

  def children_time; end
  def children_time=(_arg0); end
  def children_time_ranges; end
  def children_time_ranges?; end
  def concurrent_children?; end
  def duration; end
  def end_time; end
  def exclusive_duration; end
  def finalize; end
  def finish; end
  def finished?; end
  def guid; end
  def inspect; end
  def name; end
  def name=(_arg0); end
  def notice_error(exception, options = T.unsafe(nil)); end
  def noticed_error; end
  def noticed_error_attributes; end
  def params; end
  def params?; end
  def parent; end
  def parent=(_arg0); end
  def record_metrics=(_arg0); end
  def record_metrics?; end
  def record_on_finish=(_arg0); end
  def record_on_finish?; end
  def record_scoped_metric=(_arg0); end
  def record_scoped_metric?; end
  def set_noticed_error(noticed_error); end
  def start; end
  def start_time; end
  def time_range; end
  def transaction; end
  def transaction=(_arg0); end
  def transaction_assigned; end
  def transaction_name; end
  def transaction_name=(_arg0); end

  protected

  def child_complete(segment); end
  def child_start(segment); end
  def descendant_complete(child, descendant); end
  def range_recorded=(_arg0); end
  def range_recorded?; end

  private

  def force_finish; end
  def metric_cache; end
  def record_child_time(child); end
  def record_child_time_as_number(child); end
  def record_child_time_as_range(child); end
  def record_exclusive_duration; end
  def record_metrics; end
  def run_complete_callbacks; end
  def segment_complete; end
  def transaction_state; end
end

NewRelic::Agent::Transaction::AbstractSegment::INSPECT_IGNORE = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Transaction::CONTROLLER_PREFIX = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Transaction::DatastoreSegment < ::NewRelic::Agent::Transaction::Segment
  def initialize(product, operation, collection = T.unsafe(nil), host = T.unsafe(nil), port_path_or_id = T.unsafe(nil), database_name = T.unsafe(nil), start_time = T.unsafe(nil)); end

  def _notice_sql(sql, config = T.unsafe(nil), explainer = T.unsafe(nil), binds = T.unsafe(nil), name = T.unsafe(nil)); end
  def collection; end
  def database_name; end
  def database_name=(_arg0); end
  def host; end
  def nosql_statement; end
  def notice_nosql_statement(nosql_statement); end
  def notice_sql(sql); end
  def operation; end
  def port_path_or_id; end
  def product; end
  def record_metrics; end
  def record_sql; end
  def record_sql=(_arg0); end
  def set_instance_info(host = T.unsafe(nil), port_path_or_id = T.unsafe(nil)); end
  def sql_statement; end

  private

  def add_backtrace_parameter; end
  def add_database_name_parameter; end
  def add_instance_parameters; end
  def notice_sql_statement; end
  def notice_statement; end
  def record_span_event; end
  def record_sql?; end
  def segment_complete; end
end

NewRelic::Agent::Transaction::DatastoreSegment::NEWLINE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DatastoreSegment::UNKNOWN = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Transaction::DistributedTracer
  include ::NewRelic::Agent::CrossAppTracing
  include ::NewRelic::Agent::Transaction::DistributedTracing
  include ::NewRelic::Coerce
  include ::NewRelic::Agent::Transaction::TraceContext

  def initialize(transaction); end

  def accept_incoming_request(request, transport_type = T.unsafe(nil)); end
  def accept_incoming_transport_type(request, transport_type); end
  def accept_transport_type_from_api(value); end
  def append_payload(payload); end
  def assign_intrinsics; end
  def caller_transport_type; end
  def consume_message_headers(headers, tracer_state, transport_type); end
  def insert_cat_headers(headers); end
  def insert_distributed_trace_header(headers); end
  def insert_headers(headers); end
  def log_request_headers(headers, direction = T.unsafe(nil)); end
  def parent_guid; end
  def parent_transaction_id; end
  def parent_transaction_id=(_arg0); end
  def record_metrics; end
  def transaction; end

  private

  def accept_cross_app_payload(headers, tracer_state); end
  def consume_message_cross_app_tracing_headers(headers, tracer_state); end
  def consume_message_distributed_tracing_headers(headers, transport_type); end
  def consume_message_synthetics_headers(headers); end
  def deobfuscate(message); end
end

module NewRelic::Agent::Transaction::DistributedTracing
  def accept_distributed_trace_payload(payload); end
  def accept_distributed_tracing_incoming_request(request); end
  def create_distributed_trace_payload; end
  def distributed_trace_payload; end
  def distributed_trace_payload=(_arg0); end
  def distributed_trace_payload_created=(_arg0); end
  def distributed_trace_payload_created?; end

  private

  def assign_payload_and_sampling_params(payload); end
  def check_payload_ignored(payload); end
  def check_payload_present(payload); end
  def check_required_fields_present(payload); end
  def check_trusted_account(payload); end
  def check_valid_version(payload); end
  def decode_payload(payload); end
end

NewRelic::Agent::Transaction::DistributedTracing::ACCEPT_EXCEPTION_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::ACCEPT_PARSE_EXCEPTION_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::ACCEPT_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::ACCEPT_SUCCESS_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::CREATE_EXCEPTION_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::CREATE_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::CREATE_SUCCESS_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::IGNORE_ACCEPT_AFTER_CREATE_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::IGNORE_ACCEPT_MAJOR_VERSION_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::IGNORE_ACCEPT_NULL_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::IGNORE_ACCEPT_UNTRUSTED_ACCOUNT_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::IGNORE_MULTIPLE_ACCEPT_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::IGNORE_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::LBRACE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::NEWRELIC_TRACE_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::NULL_PAYLOAD = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::DistributedTracing::SUPPORTABILITY_DISTRIBUTED_TRACE = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Transaction::ExternalRequestSegment < ::NewRelic::Agent::Transaction::Segment
  def initialize(library, uri, procedure, start_time = T.unsafe(nil)); end

  def add_request_headers(request); end
  def cross_app_request?; end
  def cross_process_id; end
  def cross_process_transaction_name; end
  def get_request_metadata; end
  def host; end
  def http_status_code; end
  def library; end
  def name; end
  def procedure; end
  def process_response_headers(response); end
  def process_response_metadata(response_metadata); end
  def read_response_headers(response); end
  def record_metrics; end
  def transaction_guid; end
  def uri; end

  private

  def add_unscoped_metrics; end
  def insert_synthetics_header(request, header); end
  def obfuscator; end
  def process_host_header(request); end
  def record_span_event; end
  def segment_complete; end
  def set_http_status_code(response); end
  def suffixed_rollup_metric; end
  def update_segment_name; end
end

NewRelic::Agent::Transaction::ExternalRequestSegment::APP_DATA_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::ExternalRequestSegment::EXTERNAL_ALL = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::ExternalRequestSegment::EXTERNAL_ALL_OTHER = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::ExternalRequestSegment::EXTERNAL_ALL_WEB = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::ExternalRequestSegment::MISSING_STATUS_CODE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::ExternalRequestSegment::NR_SYNTHETICS_HEADER = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::GRAPE_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::JRUBY_CPU_TIME_ERROR = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MESSAGE_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MIDDLEWARE_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MIDDLEWARE_SUMMARY_METRICS = T.let(T.unsafe(nil), Array)

class NewRelic::Agent::Transaction::MessageBrokerSegment < ::NewRelic::Agent::Transaction::Segment
  def initialize(action:, library:, destination_type:, destination_name:, headers: T.unsafe(nil), parameters: T.unsafe(nil), start_time: T.unsafe(nil)); end

  def action; end
  def destination_name; end
  def destination_type; end
  def headers; end
  def library; end
  def name; end
  def transaction_assigned; end
end

NewRelic::Agent::Transaction::MessageBrokerSegment::ACTIONS = T.let(T.unsafe(nil), Hash)
NewRelic::Agent::Transaction::MessageBrokerSegment::CONSUME = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::DESTINATION_TYPES = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Transaction::MessageBrokerSegment::EXCHANGE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::METRIC_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::NAMED = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::PRODUCE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::PURGE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::QUEUE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::SLASH = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::TEMP = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::TOPIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::MessageBrokerSegment::TYPES = T.let(T.unsafe(nil), Hash)
NewRelic::Agent::Transaction::MessageBrokerSegment::UNKNOWN = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::NESTED_TRANSACTION_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::OTHER_SUMMARY_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::OTHER_TRANSACTION_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::QUEUE_TIME_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::RACK_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::RAKE_PREFIX = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Transaction::RequestAttributes
  def initialize(request); end

  def accept; end
  def assign_agent_attributes(txn); end
  def content_length; end
  def content_type; end
  def host; end
  def port; end
  def referer; end
  def request_method; end
  def request_path; end
  def user_agent; end

  private

  def attribute_from_env(request, key); end
  def attribute_from_request(request, attribute_method); end
  def content_length_from_request(request); end
  def path_from_request(request); end
  def port_from_request(request); end
  def referer_from_request(request); end
end

NewRelic::Agent::Transaction::RequestAttributes::HTTP_ACCEPT_HEADER_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::RequestAttributes::ROOT_PATH = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::SINATRA_PREFIX = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Transaction::Segment < ::NewRelic::Agent::Transaction::AbstractSegment
  def initialize(name = T.unsafe(nil), unscoped_metrics = T.unsafe(nil), start_time = T.unsafe(nil)); end

  def add_agent_attribute(key, value, default_destinations = T.unsafe(nil)); end
  def add_custom_attributes(p); end
  def attributes; end
  def custom_transaction_attributes; end
  def merge_untrusted_agent_attributes(agent_attributes, prefix, default_destinations); end
  def unscoped_metrics; end

  private

  def append_unscoped_metric(metric); end
  def record_metrics; end
  def record_span_event; end
  def segment_complete; end

  class << self
    def merge_untrusted_agent_attributes(attributes, prefix, default_destinations); end
  end
end

class NewRelic::Agent::Transaction::SlowestSampleBuffer < ::NewRelic::Agent::Transaction::TransactionSampleBuffer
  def allow_sample?(sample); end
  def capacity; end
end

NewRelic::Agent::Transaction::SlowestSampleBuffer::CAPACITY = T.let(T.unsafe(nil), Integer)

class NewRelic::Agent::Transaction::SyntheticsSampleBuffer < ::NewRelic::Agent::Transaction::TransactionSampleBuffer
  def allow_sample?(sample); end
  def capacity; end
  def truncate_samples; end
end

NewRelic::Agent::Transaction::TASK_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TRANSACTION_NAMING_SOURCES = T.let(T.unsafe(nil), Array)

class NewRelic::Agent::Transaction::Trace
  def initialize(start_time); end

  def attributes; end
  def attributes=(_arg0); end
  def attributes_for_tracer_destination; end
  def collect_explain_plans!; end
  def count_nodes; end
  def create_node(time_since_start, metric_name = T.unsafe(nil)); end
  def duration; end
  def each_node(&block); end
  def each_node_with_nest_tracking(&block); end
  def finished; end
  def finished=(_arg0); end
  def guid; end
  def guid=(_arg0); end
  def node_count; end
  def node_count=(_arg0); end
  def prepare_sql_for_transmission!; end
  def prepare_to_send!; end
  def profile; end
  def profile=(_arg0); end
  def root_node; end
  def sample_id; end
  def start_time; end
  def strip_sql!; end
  def synthetics_resource_id; end
  def threshold; end
  def threshold=(_arg0); end
  def to_collector_array(encoder); end
  def to_s_compact; end
  def trace_tree(attributes_hash); end
  def transaction_name; end
  def transaction_name=(_arg0); end
end

NewRelic::Agent::Transaction::Trace::AGENT_ATTRIBUTES_KEY = T.let(T.unsafe(nil), String)
class NewRelic::Agent::Transaction::Trace::FinishedTraceError < ::StandardError; end
NewRelic::Agent::Transaction::Trace::INTRINSIC_ATTRIBUTES_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::Trace::ROOT = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::Trace::USER_ATTRIBUTES_KEY = T.let(T.unsafe(nil), String)

module NewRelic::Agent::Transaction::TraceBuilder
  extend ::NewRelic::Agent::Transaction::TraceBuilder

  def build_trace(transaction); end

  private

  def copy_attributes(transaction, trace); end
  def create_trace_node(transaction, segment, parent); end
  def process_segments(transaction, segment, parent, relationship_map); end
end

module NewRelic::Agent::Transaction::TraceContext
  include ::NewRelic::Coerce

  def accept_trace_context(header_data); end
  def assign_trace_state_payload; end
  def create_trace_state; end
  def create_trace_state_payload; end
  def ignore_trace_context?; end
  def insert_trace_context_header(header, format = T.unsafe(nil)); end
  def trace_context_header_data; end
  def trace_context_header_data=(_arg0); end
  def trace_context_inserted?; end
  def trace_parent_header_present?(request); end
  def trace_state_payload; end

  private

  def accept_trace_context_incoming_request(request); end
end

NewRelic::Agent::Transaction::TraceContext::ACCEPT_EXCEPTION_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::ACCEPT_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::ACCEPT_SUCCESS_METRIC = T.let(T.unsafe(nil), String)

module NewRelic::Agent::Transaction::TraceContext::AccountHelpers
  extend ::NewRelic::Agent::Transaction::TraceContext::AccountHelpers

  def trace_state_entry_key; end
end

NewRelic::Agent::Transaction::TraceContext::CREATE_EXCEPTION_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::CREATE_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::CREATE_SUCCESS_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::IGNORE_ACCEPT_AFTER_CREATE_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::IGNORE_MULTIPLE_ACCEPT_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::INVALID_TRACESTATE_PAYLOAD_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::NO_NR_ENTRY_TRACESTATE_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::SUPPORTABILITY_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::TraceContext::TRACESTATE_PREFIX = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Transaction::TraceNode
  def initialize(metric_name, relative_start, relative_end = T.unsafe(nil), params = T.unsafe(nil), parent = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def children; end
  def children=(_arg0); end
  def count_nodes; end
  def duration; end
  def each_node(&block); end
  def each_node_with_nest_tracking(&block); end
  def end_trace(timestamp); end
  def entry_timestamp; end
  def exclusive_duration; end
  def exit_timestamp; end
  def exit_timestamp=(_arg0); end
  def explain_sql; end
  def metric_name; end
  def metric_name=(_arg0); end
  def obfuscated_sql; end
  def params; end
  def params=(_arg0); end
  def parent_node; end
  def parent_node=(s); end
  def path_string; end
  def select_allowed_params(params); end
  def to_array; end
  def to_debug_str(depth); end
  def to_s; end
  def to_s_compact; end
end

NewRelic::Agent::Transaction::TraceNode::UNKNOWN_NODE_NAME = T.let(T.unsafe(nil), String)

module NewRelic::Agent::Transaction::Tracing
  def add_segment(segment, parent = T.unsafe(nil)); end
  def async=(_arg0); end
  def async?; end
  def current_segment; end
  def segment_complete(segment); end
  def segment_limit; end
  def total_time; end
  def total_time=(_arg0); end

  private

  def finalize_segments; end
  def record_total_time_metrics; end
end

NewRelic::Agent::Transaction::Tracing::OTHER_TRANSACTION_TOTAL_TIME = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::Tracing::WEB_TRANSACTION_TOTAL_TIME = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Transaction::TransactionSampleBuffer
  def initialize; end

  def allow_sample?(sample); end
  def capacity; end
  def enabled?; end
  def full?; end
  def harvest_samples; end
  def max_capacity; end
  def reset!; end
  def samples; end
  def store(sample); end
  def store_previous(previous_samples); end
  def truncate_samples; end
  def truncate_samples_if_needed; end
  def visit_node(*_arg0); end

  private

  def add_sample(sample); end
end

NewRelic::Agent::Transaction::TransactionSampleBuffer::NO_SAMPLES = T.let(T.unsafe(nil), Array)
NewRelic::Agent::Transaction::TransactionSampleBuffer::SINGLE_BUFFER_MAX = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::Transaction::WEB_SUMMARY_METRIC = T.let(T.unsafe(nil), String)
NewRelic::Agent::Transaction::WEB_TRANSACTION_CATEGORIES = T.let(T.unsafe(nil), Array)

module NewRelic::Agent::TransactionErrorPrimitive
  extend ::NewRelic::Agent::TransactionErrorPrimitive

  def append_cat(payload, sample); end
  def append_synthetics(payload, sample); end
  def create(noticed_error, payload, span_id); end
  def intrinsic_attributes_for(noticed_error, payload, span_id); end
end

NewRelic::Agent::TransactionErrorPrimitive::DURATION_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::ERROR_CLASS_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::ERROR_EXPECTED_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::ERROR_MESSAGE_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::GUID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::NAME_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::PORT_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::PRIORITY_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::REFERRING_TRANSACTION_GUID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::SAMPLED_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::SAMPLE_TYPE = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::SPAN_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::SYNTHETICS_JOB_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::SYNTHETICS_MONITOR_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::SYNTHETICS_RESOURCE_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionErrorPrimitive::TYPE_KEY = T.let(T.unsafe(nil), String)

class NewRelic::Agent::TransactionEventAggregator < ::NewRelic::Agent::EventAggregator
  def record(priority: T.unsafe(nil), event: T.unsafe(nil), &blk); end

  private

  def after_harvest(metadata); end
  def record_sampling_rate(metadata); end
end

module NewRelic::Agent::TransactionEventPrimitive
  include ::NewRelic::Coerce
  extend ::NewRelic::Coerce
  extend ::NewRelic::Agent::TransactionEventPrimitive

  def create(payload); end

  private

  def agent_attributes(attributes); end
  def append_cat_alternate_path_hashes(sample, payload); end
  def append_optional_attributes(sample, payload); end
  def custom_attributes(attributes); end
  def optionally_append(sample_key, payload_key, sample, payload); end
end

NewRelic::Agent::TransactionEventPrimitive::APDEX_PERF_ZONE_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::CAT_ALTERNATE_PATH_HASHES_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::CAT_PATH_HASH_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::CAT_REFERRING_PATH_HASH_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::COMMA = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::DURATION_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::ERROR_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::GUID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::NAME_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::PRIORITY_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::REFERRING_TRANSACTION_GUID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::SAMPLED_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::SAMPLE_TYPE = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::SYNTHETICS_JOB_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::SYNTHETICS_MONITOR_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::SYNTHETICS_RESOURCE_ID_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)
NewRelic::Agent::TransactionEventPrimitive::TYPE_KEY = T.let(T.unsafe(nil), String)

class NewRelic::Agent::TransactionEventRecorder
  def initialize(events); end

  def create_event(payload); end
  def drop_buffered_data; end
  def record(payload); end
  def synthetics_event?(payload); end
  def synthetics_event_aggregator; end
  def transaction_event_aggregator; end
end

class NewRelic::Agent::TransactionMetrics
  def initialize; end

  def [](key); end
  def _record_metrics(names, value, aux, target, &blk); end
  def each_scoped; end
  def each_unscoped; end
  def has_key?(key); end
  def record_scoped_and_unscoped(names, value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end
  def record_unscoped(names, value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end
end

NewRelic::Agent::TransactionMetrics::DEFAULT_PROC = T.let(T.unsafe(nil), Proc)

class NewRelic::Agent::TransactionSampler
  def initialize; end

  def count; end
  def enabled?; end
  def harvest!; end
  def harvest_from_sample_buffers; end
  def last_sample; end
  def merge!(previous); end
  def on_finishing_transaction(txn); end
  def prepare_samples(samples); end
  def reset!; end
  def store_sample(sample); end
end

class NewRelic::Agent::TransactionSqlData
  def initialize; end

  def guid; end
  def path; end
  def set_transaction_info(uri, guid); end
  def set_transaction_name(name); end
  def sql_data; end
  def uri; end
end

NewRelic::Agent::TransactionState = NewRelic::Agent::Tracer

module NewRelic::Agent::TransactionTimeAggregator
  private

  def harvest!(timestamp = T.unsafe(nil)); end
  def reset!(timestamp = T.unsafe(nil)); end
  def transaction_start(timestamp = T.unsafe(nil)); end
  def transaction_stop(timestamp = T.unsafe(nil), starting_thread_id = T.unsafe(nil)); end

  class << self
    def harvest!(timestamp = T.unsafe(nil)); end
    def reset!(timestamp = T.unsafe(nil)); end
    def transaction_start(timestamp = T.unsafe(nil)); end
    def transaction_stop(timestamp = T.unsafe(nil), starting_thread_id = T.unsafe(nil)); end

    private

    def current_thread; end
    def in_transaction?(thread_id = T.unsafe(nil)); end
    def log_missing_elapsed_transaction_time; end
    def record_elapsed_transaction_time_until(timestamp, thread_id = T.unsafe(nil)); end
    def set_transaction_start_time(timestamp, thread_id = T.unsafe(nil)); end
    def split_transaction_at_harvest(timestamp, thread_id = T.unsafe(nil)); end
    def thread_by_id(thread_id); end
    def thread_is_alive?(thread_id); end
    def transaction_time_in_thread(timestamp, thread_id, entry); end
  end
end

NewRelic::Agent::TransactionTimeAggregator::INSTANCE_BUSY_METRIC = T.let(T.unsafe(nil), String)

class NewRelic::Agent::TransactionTimeAggregator::TransactionStats < ::Struct
  def elapsed_transaction_time; end
  def elapsed_transaction_time=(_); end
  def transaction_started_at; end
  def transaction_started_at=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

NewRelic::Agent::UNKNOWN_METRIC = T.let(T.unsafe(nil), String)
class NewRelic::Agent::UnrecoverableAgentException < ::NewRelic::Agent::ServerConnectionException; end
class NewRelic::Agent::UnrecoverableServerException < ::NewRelic::Agent::ServerConnectionException; end
module NewRelic::Agent::Utilization; end
class NewRelic::Agent::Utilization::AWS < ::NewRelic::Agent::Utilization::Vendor; end
class NewRelic::Agent::Utilization::Azure < ::NewRelic::Agent::Utilization::Vendor; end

class NewRelic::Agent::Utilization::GCP < ::NewRelic::Agent::Utilization::Vendor
  def prepare_response(response); end
  def trim_leading(value); end
end

NewRelic::Agent::Utilization::GCP::MACH_TYPE = T.let(T.unsafe(nil), String)
NewRelic::Agent::Utilization::GCP::SLASH = T.let(T.unsafe(nil), String)
NewRelic::Agent::Utilization::GCP::ZONE = T.let(T.unsafe(nil), String)

class NewRelic::Agent::Utilization::PCF < ::NewRelic::Agent::Utilization::Vendor
  def detect; end
  def pcf_keys_present?; end
end

class NewRelic::Agent::Utilization::Vendor
  def initialize; end

  def detect; end
  def endpoint; end
  def headers; end
  def key_transforms; end
  def keys; end
  def metadata; end
  def vendor_name; end

  private

  def normalize(value); end
  def prepare_response(response); end
  def process_response(response); end
  def record_supportability_metric; end
  def request_metadata; end
  def transform_key(key); end
  def valid_chars?(value); end
  def valid_length?(value); end

  class << self
    def endpoint(endpoint = T.unsafe(nil)); end
    def headers(headers = T.unsafe(nil)); end
    def key_transforms(key_transforms = T.unsafe(nil)); end
    def keys(keys = T.unsafe(nil)); end
    def vendor_name(vendor_name = T.unsafe(nil)); end
  end
end

NewRelic::Agent::Utilization::Vendor::SUCCESS = T.let(T.unsafe(nil), String)
NewRelic::Agent::Utilization::Vendor::VALID_CHARS = T.let(T.unsafe(nil), Regexp)

class NewRelic::Agent::UtilizationData
  def append_boot_id(collector_hash); end
  def append_configured_values(collector_hash); end
  def append_docker_info(collector_hash); end
  def append_full_hostname(collector_hash); end
  def append_ip_address(collector_hash); end
  def append_kubernetes_info(collector_hash); end
  def append_vendor_info(collector_hash); end
  def config_hash; end
  def configured_hostname; end
  def configured_logical_processors; end
  def configured_total_ram_mib; end
  def container_id; end
  def cpu_count; end
  def fqdn; end
  def hostname; end
  def ip_addresses; end
  def ram_in_mib; end
  def to_collector_hash; end
end

NewRelic::Agent::UtilizationData::KUBERNETES_SERVICE_HOST = T.let(T.unsafe(nil), String)
NewRelic::Agent::UtilizationData::METADATA_VERSION = T.let(T.unsafe(nil), Integer)
NewRelic::Agent::UtilizationData::VENDORS = T.let(T.unsafe(nil), Hash)

module NewRelic::Agent::VM
  class << self
    def create_vm; end
    def snapshot; end
    def vm; end
  end
end

class NewRelic::Agent::VM::JRubyVM
  def gather_stats(snap); end
  def snapshot; end
  def supports?(key); end
end

class NewRelic::Agent::VM::MonotonicGCProfiler
  def initialize; end

  def total_time_s; end
end

class NewRelic::Agent::VM::MriVM
  def gather_gc_stats(snap); end
  def gather_gc_time(snap); end
  def gather_ruby_vm_stats(snap); end
  def gather_stats(snap); end
  def gather_thread_stats(snap); end
  def snapshot; end
  def supports?(key); end
end

class NewRelic::Agent::VM::Snapshot
  def initialize; end

  def constant_cache_invalidations; end
  def constant_cache_invalidations=(_arg0); end
  def gc_runs; end
  def gc_runs=(_arg0); end
  def gc_total_time; end
  def gc_total_time=(_arg0); end
  def heap_free; end
  def heap_free=(_arg0); end
  def heap_live; end
  def heap_live=(_arg0); end
  def major_gc_count; end
  def major_gc_count=(_arg0); end
  def method_cache_invalidations; end
  def method_cache_invalidations=(_arg0); end
  def minor_gc_count; end
  def minor_gc_count=(_arg0); end
  def taken_at; end
  def taken_at=(_arg0); end
  def thread_count; end
  def thread_count=(_arg0); end
  def total_allocated_object; end
  def total_allocated_object=(_arg0); end
end

class NewRelic::Agent::WorkerLoop
  def initialize(opts = T.unsafe(nil)); end

  def iterations; end
  def keep_running?; end
  def period; end
  def period=(_arg0); end
  def propagate_errors; end
  def propagate_errors=(_arg0); end
  def run(period = T.unsafe(nil), &block); end
  def run_task; end
  def schedule_next_invocation; end
  def setup(period, task); end
  def stop; end
  def under_duration?; end
  def under_limit?; end
end

NewRelic::CANDIDATE_NEWRELIC_KEYS = T.let(T.unsafe(nil), Array)
NewRelic::CONNECT_RETRY_PERIODS = T.let(T.unsafe(nil), Array)

class NewRelic::ChainedCall
  def initialize(block1, block2); end

  def call(sql); end
end

module NewRelic::Coerce
  private

  def boolean_int!(value); end
  def float(value, context = T.unsafe(nil)); end
  def float!(value, precision = T.unsafe(nil)); end
  def int(value, context = T.unsafe(nil)); end
  def int!(value); end
  def int_or_nil(value, context = T.unsafe(nil)); end
  def log_failure(value, type, context, error); end
  def scalar(val); end
  def string(value, context = T.unsafe(nil)); end
  def value_or_nil(value); end

  class << self
    def boolean_int!(value); end
    def float(value, context = T.unsafe(nil)); end
    def float!(value, precision = T.unsafe(nil)); end
    def int(value, context = T.unsafe(nil)); end
    def int!(value); end
    def int_or_nil(value, context = T.unsafe(nil)); end
    def log_failure(value, type, context, error); end
    def scalar(val); end
    def string(value, context = T.unsafe(nil)); end
    def value_or_nil(value); end
  end
end

module NewRelic::CollectionHelper
  def normalize_params(params); end

  private

  def flatten(object); end
  def truncate(string, len = T.unsafe(nil)); end
end

NewRelic::CollectionHelper::DEFAULT_ARRAY_TRUNCATION_SIZE = T.let(T.unsafe(nil), Integer)
NewRelic::CollectionHelper::DEFAULT_TRUNCATION_SIZE = T.let(T.unsafe(nil), Integer)

class NewRelic::Control
  include ::NewRelic::Control::ServerMethods
  include ::NewRelic::Control::Instrumentation
  include ::NewRelic::Control::InstanceMethods
  extend ::NewRelic::Control::ClassMethods
end

module NewRelic::Control::ClassMethods
  def camelize(snake_case_name); end
  def instance(create = T.unsafe(nil)); end
  def load_framework_class(framework); end
  def load_test_framework; end
  def local_env; end
  def new_instance; end
  def newrelic_root; end
  def reset; end
end

module NewRelic::Control::Frameworks; end

module NewRelic::Control::InstanceMethods
  def initialize(local_env, config_file_override = T.unsafe(nil)); end

  def [](key); end
  def app; end
  def configure_agent(env, options); end
  def determine_env(options); end
  def dispatcher; end
  def env=(_arg0); end
  def framework; end
  def handle_invalid_security_settings; end
  def init_plugin(options = T.unsafe(nil)); end
  def local_env; end
  def newrelic_root; end
  def security_settings_valid?; end
  def settings; end
  def start_agent; end

  protected

  def root; end
  def stdout; end
end

module NewRelic::Control::Instrumentation
  def add_instrumentation(pattern); end
  def install_instrumentation; end
  def install_shim; end
  def load_instrumentation_files(pattern); end

  private

  def _install_instrumentation; end
end

class NewRelic::Control::Server < ::Struct
  def to_s; end
end

module NewRelic::Control::ServerMethods
  def api_server; end
  def server; end
  def server_from_host(hostname = T.unsafe(nil)); end
end

module NewRelic::DelayedJobInjection
  extend ::NewRelic::DelayedJobInjection

  def worker_name; end
  def worker_name=(_arg0); end
end

NewRelic::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
NewRelic::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
NewRelic::EMPTY_STR = T.let(T.unsafe(nil), String)

class NewRelic::EnvironmentReport
  def initialize; end

  def [](key); end
  def []=(key, value); end
  def data; end
  def to_a; end

  class << self
    def registered_reporters; end
    def registered_reporters=(logic); end
    def report_on(key, &block); end
  end
end

NewRelic::FORMAT_NON_RACK = T.let(T.unsafe(nil), Integer)
NewRelic::FORMAT_RACK = T.let(T.unsafe(nil), Integer)
NewRelic::HTTP = T.let(T.unsafe(nil), String)
NewRelic::HTTPS = T.let(T.unsafe(nil), String)
NewRelic::HTTP_NEWRELIC_KEY = T.let(T.unsafe(nil), String)
NewRelic::HTTP_TRACEPARENT_KEY = T.let(T.unsafe(nil), String)
NewRelic::HTTP_TRACESTATE_KEY = T.let(T.unsafe(nil), String)

module NewRelic::Helper
  extend ::NewRelic::Helper

  def correctly_encoded(string); end
  def instance_method_visibility(klass, method_name); end
  def instance_methods_include?(klass, method_name); end
  def time_to_millis(time); end
end

module NewRelic::LanguageSupport
  extend ::NewRelic::LanguageSupport

  def bundled_gem?(gem_name); end
  def can_fork?; end
  def constantize(const_name); end
  def gc_profiler_enabled?; end
  def gc_profiler_usable?; end
  def jruby?; end
  def object_space_usable?; end
end

class NewRelic::LocalEnvironment
  def initialize; end

  def discovered_dispatcher; end
  def executable; end
  def find_class_in_object_space(klass); end
  def to_s; end

  private

  def check_for_delayed_job; end
  def check_for_fastcgi; end
  def check_for_glassfish; end
  def check_for_litespeed; end
  def check_for_mongrel; end
  def check_for_passenger; end
  def check_for_puma; end
  def check_for_rainbows; end
  def check_for_resque; end
  def check_for_sidekiq; end
  def check_for_thin; end
  def check_for_torquebox; end
  def check_for_trinidad; end
  def check_for_unicorn; end
  def check_for_webrick; end
  def discover_dispatcher; end
  def jruby_rack?; end
end

NewRelic::MAX_RETRY_PERIOD = T.let(T.unsafe(nil), Integer)
NewRelic::MIN_RETRY_PERIOD = T.let(T.unsafe(nil), Integer)
NewRelic::MYSQL_EXPLAIN_COLUMNS = T.let(T.unsafe(nil), Array)

class NewRelic::MetricData
  include ::NewRelic::Coerce

  def initialize(metric_spec, stats); end

  def eql?(o); end
  def hash; end
  def inspect; end
  def metric_spec; end
  def metric_spec=(new_spec); end
  def original_spec; end
  def stats; end
  def stats=(_arg0); end
  def to_collector_array(encoder = T.unsafe(nil)); end
  def to_json(*a); end
  def to_s; end
end

class NewRelic::MetricSpec
  def initialize(metric_name = T.unsafe(nil), metric_scope = T.unsafe(nil)); end

  def <=>(o); end
  def ==(o); end
  def eql?(o); end
  def hash; end
  def inspect; end
  def name; end
  def scope; end
  def to_json(*a); end
  def to_s; end
end

NewRelic::MetricSpec::EMPTY_SCOPE = T.let(T.unsafe(nil), String)
NewRelic::MetricSpec::LENGTH_RANGE = T.let(T.unsafe(nil), Range)
NewRelic::MetricSpec::MAX_LENGTH = T.let(T.unsafe(nil), Integer)
NewRelic::NEWRELIC_KEY = T.let(T.unsafe(nil), String)

class NewRelic::NoticedError
  include ::NewRelic::Coerce
  extend ::NewRelic::CollectionHelper

  def initialize(path, exception, timestamp = T.unsafe(nil), expected = T.unsafe(nil)); end

  def ==(other); end
  def agent_attributes; end
  def append_attributes(outgoing_params, outgoing_key, source_attributes); end
  def attributes; end
  def attributes=(_arg0); end
  def attributes_from_notice_error; end
  def attributes_from_notice_error=(_arg0); end
  def base_parameters; end
  def build_agent_attributes(merged_attributes); end
  def build_error_attributes; end
  def build_intrinsic_attributes; end
  def custom_attributes; end
  def exception_class_name; end
  def exception_class_name=(_arg0); end
  def exception_id; end
  def expected; end
  def expected=(_arg0); end
  def extract_class_name_and_message_from(exception); end
  def file_name; end
  def file_name=(_arg0); end
  def intrinsic_attributes; end
  def is_internal; end
  def line_number; end
  def line_number=(_arg0); end
  def merge_custom_attributes_from_notice_error(merged_attributes); end
  def merge_custom_attributes_from_transaction(merged_attributes); end
  def merged_custom_attributes(merged_attributes); end
  def message; end
  def message=(_arg0); end
  def path; end
  def path=(_arg0); end
  def processed_attributes; end
  def request_port; end
  def request_port=(_arg0); end
  def request_uri; end
  def request_uri=(_arg0); end
  def stack_trace; end
  def stack_trace=(_arg0); end
  def timestamp; end
  def timestamp=(_arg0); end
  def to_collector_array(encoder = T.unsafe(nil)); end

  class << self
    def passes_message_allowlist(exception_class); end
  end
end

NewRelic::NoticedError::AGENT_ATTRIBUTES = T.let(T.unsafe(nil), String)
NewRelic::NoticedError::DESTINATION = T.let(T.unsafe(nil), Integer)
NewRelic::NoticedError::ERROR_CLASS_KEY = T.let(T.unsafe(nil), String)
NewRelic::NoticedError::ERROR_EXPECTED_KEY = T.let(T.unsafe(nil), String)
NewRelic::NoticedError::ERROR_MESSAGE_KEY = T.let(T.unsafe(nil), String)
NewRelic::NoticedError::ERROR_PREFIX_KEY = T.let(T.unsafe(nil), String)
NewRelic::NoticedError::INTRINSIC_ATTRIBUTES = T.let(T.unsafe(nil), String)
NewRelic::NoticedError::NIL_ERROR_MESSAGE = T.let(T.unsafe(nil), String)
NewRelic::NoticedError::STRIPPED_EXCEPTION_REPLACEMENT_MESSAGE = T.let(T.unsafe(nil), String)
NewRelic::NoticedError::UNKNOWN_ERROR_CLASS_NAME = T.let(T.unsafe(nil), String)
NewRelic::NoticedError::USER_ATTRIBUTES = T.let(T.unsafe(nil), String)
NewRelic::PRIORITY_PRECISION = T.let(T.unsafe(nil), Integer)
class NewRelic::Railtie < ::Rails::Railtie; end

module NewRelic::SupportabilityHelper
  def record_api_supportability_metric(method_name); end
  def valid_api_argument_class?(arg, name, klass); end
end

NewRelic::SupportabilityHelper::API_SUPPORTABILITY_METRICS = T.let(T.unsafe(nil), Hash)
NewRelic::SupportabilityHelper::API_SUPPORTABILITY_PREFIX = T.let(T.unsafe(nil), String)
NewRelic::TRACEPARENT_KEY = T.let(T.unsafe(nil), String)
NewRelic::TRACESTATE_KEY = T.let(T.unsafe(nil), String)
NewRelic::UNKNOWN = T.let(T.unsafe(nil), String)

module NewRelic::VERSION
  class << self
    def build_version_string(*parts); end
  end
end

NewRelic::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)
NewRelic::VERSION::MINOR = T.let(T.unsafe(nil), Integer)
NewRelic::VERSION::STRING = T.let(T.unsafe(nil), String)
NewRelic::VERSION::TINY = T.let(T.unsafe(nil), Integer)
