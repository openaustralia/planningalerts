# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dbf` gem.
# Please instead update this file by running `bin/tapioca gem dbf`.


# source://dbf//lib/dbf/version.rb#1
module DBF; end

# source://dbf//lib/dbf/column.rb#2
class DBF::Column
  extend ::Forwardable

  # Initialize a new DBF::Column
  #
  # @param table [String]
  # @param name [String]
  # @param type [String]
  # @param length [Integer]
  # @param decimal [Integer]
  # @return [Column] a new instance of Column
  #
  # source://dbf//lib/dbf/column.rb#37
  def initialize(table, name, type, length, decimal); end

  # Returns the value of attribute decimal.
  #
  # source://dbf//lib/dbf/column.rb#11
  def decimal; end

  # Returns the value of attribute length.
  #
  # source://dbf//lib/dbf/column.rb#11
  def length; end

  # Returns true if the column is a memo
  #
  # @return [Boolean]
  #
  # source://dbf//lib/dbf/column.rb#53
  def memo?; end

  # Returns the value of attribute name.
  #
  # source://dbf//lib/dbf/column.rb#11
  def name; end

  # Returns the value of attribute table.
  #
  # source://dbf//lib/dbf/column.rb#11
  def table; end

  # Returns a Hash with :name, :type, :length, and :decimal keys
  #
  # @return [Hash]
  #
  # source://dbf//lib/dbf/column.rb#60
  def to_hash; end

  # Returns the value of attribute type.
  #
  # source://dbf//lib/dbf/column.rb#11
  def type; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def type_cast(*args, **_arg1, &block); end

  # Underscored name
  #
  # This is the column name converted to underscore format.
  # For example, MyColumn will be returned as my_column.
  #
  # @return [String]
  #
  # source://dbf//lib/dbf/column.rb#70
  def underscored_name; end

  private

  # source://dbf//lib/dbf/column.rb#82
  def clean(value); end

  # source://dbf//lib/dbf/column.rb#86
  def encode(value, strip_output = T.unsafe(nil)); end

  # source://dbf//lib/dbf/column.rb#100
  def encode_string(string); end

  # source://dbf//lib/dbf/column.rb#93
  def encoding_args; end

  # source://dbf//lib/dbf/column.rb#104
  def type_cast_class; end

  # @raise [LengthError]
  #
  # source://dbf//lib/dbf/column.rb#111
  def validate_length; end

  # @raise [NameError]
  #
  # source://dbf//lib/dbf/column.rb#115
  def validate_name; end
end

# source://dbf//lib/dbf/column.rb#5
class DBF::Column::LengthError < ::StandardError; end

# source://dbf//lib/dbf/column.rb#8
class DBF::Column::NameError < ::StandardError; end

# source://dbf//lib/dbf/column.rb#14
DBF::Column::TYPE_CAST_CLASS = T.let(T.unsafe(nil), Hash)

# source://dbf//lib/dbf/column_type.rb#2
module DBF::ColumnType; end

# source://dbf//lib/dbf/column_type.rb#3
class DBF::ColumnType::Base
  # @param decimal [Integer]
  # @param encoding [String, Encoding]
  # @return [Base] a new instance of Base
  #
  # source://dbf//lib/dbf/column_type.rb#8
  def initialize(decimal, encoding); end

  # Returns the value of attribute decimal.
  #
  # source://dbf//lib/dbf/column_type.rb#4
  def decimal; end

  # Returns the value of attribute encoding.
  #
  # source://dbf//lib/dbf/column_type.rb#4
  def encoding; end
end

# source://dbf//lib/dbf/column_type.rb#67
class DBF::ColumnType::Boolean < ::DBF::ColumnType::Base
  # @param value [String]
  #
  # source://dbf//lib/dbf/column_type.rb#69
  def type_cast(value); end
end

# source://dbf//lib/dbf/column_type.rb#30
class DBF::ColumnType::Currency < ::DBF::ColumnType::Base
  # @param value [String]
  #
  # source://dbf//lib/dbf/column_type.rb#32
  def type_cast(value); end
end

# source://dbf//lib/dbf/column_type.rb#74
class DBF::ColumnType::Date < ::DBF::ColumnType::Base
  # @param value [String]
  #
  # source://dbf//lib/dbf/column_type.rb#76
  def type_cast(value); end
end

# source://dbf//lib/dbf/column_type.rb#83
class DBF::ColumnType::DateTime < ::DBF::ColumnType::Base
  # @param value [String]
  #
  # source://dbf//lib/dbf/column_type.rb#85
  def type_cast(value); end
end

# source://dbf//lib/dbf/column_type.rb#60
class DBF::ColumnType::Double < ::DBF::ColumnType::Base
  # @param value [String]
  #
  # source://dbf//lib/dbf/column_type.rb#62
  def type_cast(value); end
end

# source://dbf//lib/dbf/column_type.rb#53
class DBF::ColumnType::Float < ::DBF::ColumnType::Base
  # @param value [String]
  #
  # source://dbf//lib/dbf/column_type.rb#55
  def type_cast(value); end
end

# source://dbf//lib/dbf/column_type.rb#105
class DBF::ColumnType::General < ::DBF::ColumnType::Base
  # @param value [String]
  #
  # source://dbf//lib/dbf/column_type.rb#107
  def type_cast(value); end
end

# source://dbf//lib/dbf/column_type.rb#94
class DBF::ColumnType::Memo < ::DBF::ColumnType::Base
  # @param value [String]
  #
  # source://dbf//lib/dbf/column_type.rb#96
  def type_cast(value); end
end

# source://dbf//lib/dbf/column_type.rb#14
class DBF::ColumnType::Nil < ::DBF::ColumnType::Base
  # @param _value [String]
  #
  # source://dbf//lib/dbf/column_type.rb#16
  def type_cast(_value); end
end

# source://dbf//lib/dbf/column_type.rb#21
class DBF::ColumnType::Number < ::DBF::ColumnType::Base
  # @param value [String]
  #
  # source://dbf//lib/dbf/column_type.rb#23
  def type_cast(value); end
end

# source://dbf//lib/dbf/column_type.rb#37
class DBF::ColumnType::SignedLong < ::DBF::ColumnType::Base
  # @param value [String]
  #
  # source://dbf//lib/dbf/column_type.rb#39
  def type_cast(value); end
end

# source://dbf//lib/dbf/column_type.rb#44
class DBF::ColumnType::SignedLong2 < ::DBF::ColumnType::Base
  # @param value [String]
  #
  # source://dbf//lib/dbf/column_type.rb#46
  def type_cast(value); end
end

# source://dbf//lib/dbf/column_type.rb#112
class DBF::ColumnType::String < ::DBF::ColumnType::Base
  # @param value [String]
  #
  # source://dbf//lib/dbf/column_type.rb#114
  def type_cast(value); end
end

# DBF::Database::Foxpro is the primary interface to a Visual Foxpro database
# container (.dbc file). When using this database container, long fieldnames
# are supported, and you can reference tables directly instead of
# instantiating Table objects yourself.
# Table references are created based on the filename, but it this class
# tries to correct the table filenames because they could be wrong for
# case sensitive filesystems, e.g. when a foxpro database is uploaded to
# a linux server.
#
# source://dbf//lib/dbf/database/foxpro.rb#10
module DBF::Database; end

# source://dbf//lib/dbf/database/foxpro.rb#11
class DBF::Database::Foxpro
  # Opens a DBF::Database::Foxpro
  # Examples:
  #   # working with a database stored on the filesystem
  #   db = DBF::Database::Foxpro.new 'path_to_db/database.dbc'
  #
  #  # Calling a table
  #  contacts = db.contacts.record(0)
  #
  # @param path [String]
  # @return [Foxpro] a new instance of Foxpro
  #
  # source://dbf//lib/dbf/database/foxpro.rb#21
  def initialize(path); end

  # source://dbf//lib/dbf/database/foxpro.rb#58
  def method_missing(method, *args); end

  # Returns table with given name
  #
  # @param name [String]
  # @return [DBF::Table]
  #
  # source://dbf//lib/dbf/database/foxpro.rb#38
  def table(name); end

  # source://dbf//lib/dbf/database/foxpro.rb#30
  def table_names; end

  # Searches the database directory for the table's dbf file
  # and returns the absolute path. Ensures case-insensitivity
  # on any platform.
  #
  # @param name [String]
  # @raise [DBF::FileNotFoundError]
  # @return [String]
  #
  # source://dbf//lib/dbf/database/foxpro.rb#49
  def table_path(name); end

  private

  # This method extracts the data from the database container. This is
  # just an ordinary table with a treelike structure. Field definitions
  # are in the same order as in the linked tables but only the long name
  # is provided.
  #
  # source://dbf//lib/dbf/database/foxpro.rb#72
  def extract_dbc_data; end

  # source://dbf//lib/dbf/database/foxpro.rb#99
  def process_field(record, data); end

  # source://dbf//lib/dbf/database/foxpro.rb#93
  def process_table(record, data); end

  # @return [Boolean]
  #
  # source://dbf//lib/dbf/database/foxpro.rb#62
  def respond_to_missing?(method, *_arg1); end

  # source://dbf//lib/dbf/database/foxpro.rb#107
  def table_field_hash(name); end
end

# source://dbf//lib/dbf/database/foxpro.rb#112
class DBF::Database::Table < ::DBF::Table
  # source://dbf//lib/dbf/database/foxpro.rb#115
  def build_columns; end

  # Returns the value of attribute long_names.
  #
  # source://dbf//lib/dbf/database/foxpro.rb#113
  def long_names; end

  # Sets the attribute long_names
  #
  # @param value the value to set the attribute long_names to.
  #
  # source://dbf//lib/dbf/database/foxpro.rb#113
  def long_names=(_arg0); end
end

# source://dbf//lib/dbf/encodings.rb#2
DBF::ENCODINGS = T.let(T.unsafe(nil), Hash)

# source://dbf//lib/dbf/table.rb#2
class DBF::FileNotFoundError < ::StandardError; end

# source://dbf//lib/dbf/header.rb#2
class DBF::Header
  # @return [Header] a new instance of Header
  #
  # source://dbf//lib/dbf/header.rb#10
  def initialize(data); end

  # Returns the value of attribute encoding.
  #
  # source://dbf//lib/dbf/header.rb#8
  def encoding; end

  # Returns the value of attribute encoding_key.
  #
  # source://dbf//lib/dbf/header.rb#7
  def encoding_key; end

  # Returns the value of attribute header_length.
  #
  # source://dbf//lib/dbf/header.rb#5
  def header_length; end

  # Returns the value of attribute record_count.
  #
  # source://dbf//lib/dbf/header.rb#4
  def record_count; end

  # Returns the value of attribute record_length.
  #
  # source://dbf//lib/dbf/header.rb#6
  def record_length; end

  # source://dbf//lib/dbf/header.rb#15
  def unpack_header; end

  # Returns the value of attribute version.
  #
  # source://dbf//lib/dbf/header.rb#3
  def version; end
end

# source://dbf//lib/dbf/memo/base.rb#2
module DBF::Memo; end

# source://dbf//lib/dbf/memo/base.rb#3
class DBF::Memo::Base
  # @return [Base] a new instance of Base
  #
  # source://dbf//lib/dbf/memo/base.rb#11
  def initialize(data, version); end

  # source://dbf//lib/dbf/memo/base.rb#22
  def close; end

  # @return [Boolean]
  #
  # source://dbf//lib/dbf/memo/base.rb#26
  def closed?; end

  # source://dbf//lib/dbf/memo/base.rb#16
  def get(start_block); end

  private

  # source://dbf//lib/dbf/memo/base.rb#40
  def block_content_size; end

  # source://dbf//lib/dbf/memo/base.rb#44
  def block_size; end

  # source://dbf//lib/dbf/memo/base.rb#36
  def content_size(memo_size); end

  # source://dbf//lib/dbf/memo/base.rb#32
  def offset(start_block); end

  class << self
    # source://dbf//lib/dbf/memo/base.rb#7
    def open(filename, version); end
  end
end

# source://dbf//lib/dbf/memo/base.rb#4
DBF::Memo::Base::BLOCK_HEADER_SIZE = T.let(T.unsafe(nil), Integer)

# source://dbf//lib/dbf/memo/base.rb#5
DBF::Memo::Base::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# source://dbf//lib/dbf/memo/dbase3.rb#3
class DBF::Memo::Dbase3 < ::DBF::Memo::Base
  # source://dbf//lib/dbf/memo/dbase3.rb#4
  def build_memo(start_block); end
end

# source://dbf//lib/dbf/memo/dbase4.rb#3
class DBF::Memo::Dbase4 < ::DBF::Memo::Base
  # source://dbf//lib/dbf/memo/dbase4.rb#4
  def build_memo(start_block); end
end

# source://dbf//lib/dbf/memo/foxpro.rb#3
class DBF::Memo::Foxpro < ::DBF::Memo::Base
  # source://dbf//lib/dbf/memo/foxpro.rb#6
  def build_memo(start_block); end

  private

  # source://dbf//lib/dbf/memo/foxpro.rb#24
  def block_size; end
end

# source://dbf//lib/dbf/memo/foxpro.rb#4
DBF::Memo::Foxpro::FPT_HEADER_SIZE = T.let(T.unsafe(nil), Integer)

# source://dbf//lib/dbf/table.rb#5
class DBF::NoColumnsDefined < ::StandardError; end

# An instance of DBF::Record represents a row in the DBF file
#
# source://dbf//lib/dbf/record.rb#3
class DBF::Record
  # Initialize a new DBF::Record
  #
  # @param data [String, StringIO] data
  # @param columns [Column]
  # @param version [String]
  # @param memo [DBF::Memo]
  # @return [Record] a new instance of Record
  #
  # source://dbf//lib/dbf/record.rb#10
  def initialize(data, columns, version, memo); end

  # Equality
  #
  # @param other [DBF::Record]
  # @return [Boolean]
  #
  # source://dbf//lib/dbf/record.rb#21
  def ==(other); end

  # Reads attributes by column name
  #
  # @param name [String, Symbol] key
  #
  # source://dbf//lib/dbf/record.rb#28
  def [](name); end

  # Record attributes
  #
  # @return [Hash]
  #
  # source://dbf//lib/dbf/record.rb#40
  def attributes; end

  # Do all search parameters match?
  #
  # @param options [Hash]
  # @return [Boolean]
  #
  # source://dbf//lib/dbf/record.rb#48
  def match?(options); end

  # Maps a row to an array of values
  #
  # @return [Array]
  #
  # source://dbf//lib/dbf/record.rb#55
  def to_a; end

  private

  # source://dbf//lib/dbf/record.rb#61
  def column_names; end

  # source://dbf//lib/dbf/record.rb#65
  def get_data(column); end

  # source://dbf//lib/dbf/record.rb#69
  def get_memo(column); end

  # source://dbf//lib/dbf/record.rb#79
  def init_attribute(column); end

  # source://dbf//lib/dbf/record.rb#84
  def memo_start_block(column); end

  # source://dbf//lib/dbf/record.rb#90
  def method_missing(method, *args); end

  # @return [Boolean]
  #
  # source://dbf//lib/dbf/record.rb#98
  def respond_to_missing?(method, *_arg1); end

  # source://dbf//lib/dbf/record.rb#102
  def underscored_column_names; end
end

# The Schema module is mixin for the Table class
#
# source://dbf//lib/dbf/schema.rb#3
module DBF::Schema
  # source://dbf//lib/dbf/schema.rb#49
  def activerecord_schema(_table_only = T.unsafe(nil)); end

  # ActiveRecord schema definition
  #
  # @param column [DBF::Column]
  # @return [String]
  #
  # source://dbf//lib/dbf/schema.rb#81
  def activerecord_schema_definition(column); end

  # source://dbf//lib/dbf/schema.rb#73
  def json_schema(_table_only = T.unsafe(nil)); end

  # source://dbf//lib/dbf/schema.rb#104
  def number_data_type(column); end

  # Generate an ActiveRecord::Schema
  #
  # xBase data types are converted to generic types as follows:
  # - Number columns with no decimals are converted to :integer
  # - Number columns with decimals are converted to :float
  # - Date columns are converted to :datetime
  # - Logical columns are converted to :boolean
  # - Memo columns are converted to :text
  # - Character columns are converted to :string and the :limit option is set
  #   to the length of the character column
  #
  # Example:
  #   create_table "mydata" do |t|
  #     t.column :name, :string, :limit => 30
  #     t.column :last_update, :datetime
  #     t.column :is_active, :boolean
  #     t.column :age, :integer
  #     t.column :notes, :text
  #   end
  #
  # @param format [Symbol] format Valid options are :activerecord and :json
  # @param table_only [Boolean]
  # @return [String]
  #
  # source://dbf//lib/dbf/schema.rb#38
  def schema(format = T.unsafe(nil), table_only = T.unsafe(nil)); end

  # source://dbf//lib/dbf/schema.rb#93
  def schema_data_type(column, format = T.unsafe(nil)); end

  # source://dbf//lib/dbf/schema.rb#45
  def schema_name(format); end

  # source://dbf//lib/dbf/schema.rb#59
  def sequel_schema(table_only = T.unsafe(nil)); end

  # Sequel schema definition
  #
  # @param column [DBF::Column]
  # @return [String]
  #
  # source://dbf//lib/dbf/schema.rb#89
  def sequel_schema_definition(column); end

  # source://dbf//lib/dbf/schema.rb#108
  def string_data_format(format, column); end
end

# source://dbf//lib/dbf/schema.rb#4
DBF::Schema::FORMATS = T.let(T.unsafe(nil), Array)

# source://dbf//lib/dbf/schema.rb#6
DBF::Schema::OTHER_DATA_TYPES = T.let(T.unsafe(nil), Hash)

# DBF::Table is the primary interface to a single DBF file and provides
# methods for enumerating and searching the records.
#
# source://dbf//lib/dbf/table.rb#10
class DBF::Table
  include ::Enumerable
  include ::DBF::Schema
  extend ::Forwardable

  # Opens a DBF::Table
  # Examples:
  #   # working with a file stored on the filesystem
  #   table = DBF::Table.new 'data.dbf'
  #
  #   # working with a misnamed memo file
  #   table = DBF::Table.new 'data.dbf', 'memo.dbt'
  #
  #   # working with a dbf in memory
  #   table = DBF::Table.new StringIO.new(dbf_data)
  #
  #   # working with a dbf and memo in memory
  #   table = DBF::Table.new StringIO.new(dbf_data), StringIO.new(memo_data)
  #
  #   # working with a dbf overriding specified in the dbf encoding
  #   table = DBF::Table.new 'data.dbf', nil, 'cp437'
  #   table = DBF::Table.new 'data.dbf', 'memo.dbt', Encoding::US_ASCII
  #
  # @param data [String, StringIO] data Path to the dbf file or a StringIO object
  # @param memo [optional String, StringIO] memo Path to the memo file or a StringIO object
  # @param encoding [optional String, Encoding] encoding Name of the encoding or an Encoding object
  # @return [Table] a new instance of Table
  # @yield [_self]
  # @yieldparam _self [DBF::Table] the object that the method was called on
  #
  # source://dbf//lib/dbf/table.rb#77
  def initialize(data, memo = T.unsafe(nil), encoding = T.unsafe(nil)); end

  # Closes the table and memo file
  #
  # @return [TrueClass, FalseClass]
  #
  # source://dbf//lib/dbf/table.rb#87
  def close; end

  # @return [TrueClass, FalseClass]
  #
  # source://dbf//lib/dbf/table.rb#93
  def closed?; end

  # Column names
  #
  # @return [String]
  #
  # source://dbf//lib/dbf/table.rb#104
  def column_names; end

  # All columns
  #
  # @return [Array]
  #
  # source://dbf//lib/dbf/table.rb#111
  def columns; end

  # Calls block once for each record in the table. The record may be nil
  # if the record has been marked as deleted.
  #
  # @yield [nil, DBF::Record]
  #
  # source://dbf//lib/dbf/table.rb#119
  def each; end

  # Returns the value of attribute encoding.
  #
  # source://dbf//lib/dbf/table.rb#48
  def encoding; end

  # Sets the attribute encoding
  #
  # @param value the value to set the attribute encoding to.
  #
  # source://dbf//lib/dbf/table.rb#48
  def encoding=(_arg0); end

  # @return [String]
  #
  # source://dbf//lib/dbf/table.rb#124
  def filename; end

  # Find records using a simple ActiveRecord-like syntax.
  #
  # Examples:
  #   table = DBF::Table.new 'mydata.dbf'
  #
  #   # Find record number 5
  #   table.find(5)
  #
  #   # Find all records for Keith Morrison
  #   table.find :all, first_name: "Keith", last_name: "Morrison"
  #
  #   # Find first record
  #   table.find :first, first_name: "Keith"
  #
  # The <b>command</b> may be a record index, :all, or :first.
  # <b>options</b> is optional and, if specified, should be a hash where the
  # keys correspond to column names in the database.  The values will be
  # matched exactly with the value in the database.  If you specify more
  # than one key, all values must match in order for the record to be
  # returned.  The equivalent SQL would be "WHERE key1 = 'value1'
  # AND key2 = 'value2'".
  #
  # @param command [Integer, Symbol] command
  # @param options [optional, Hash] options Hash of search parameters
  # @yield [optional, DBF::Record, NilClass]
  #
  # source://dbf//lib/dbf/table.rb#155
  def find(command, options = T.unsafe(nil), &block); end

  # @return [TrueClass, FalseClass]
  #
  # source://dbf//lib/dbf/table.rb#169
  def has_memo_file?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def header_length(*args, **_arg1, &block); end

  # @return [String]
  #
  # source://dbf//lib/dbf/table.rb#174
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://dbf//lib/dbf/table.rb#49
  def name=(_arg0); end

  # Retrieve a record by index number.
  # The record will be nil if it has been deleted, but not yet pruned from
  # the database.
  #
  # @param index [Integer]
  # @raise [DBF::NoColumnsDefined]
  # @return [DBF::Record, NilClass]
  #
  # source://dbf//lib/dbf/table.rb#184
  def record(index); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def record_count(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def record_length(*args, **_arg1, &block); end

  # Retrieve a record by index number.
  # The record will be nil if it has been deleted, but not yet pruned from
  # the database.
  #
  # @param index [Integer]
  # @raise [DBF::NoColumnsDefined]
  # @return [DBF::Record, NilClass]
  #
  # source://dbf//lib/dbf/table.rb#184
  def row(index); end

  # Dumps all records to a CSV file.  If no filename is given then CSV is
  # output to STDOUT.
  #
  # @param path [optional String] Defaults to STDOUT
  #
  # source://dbf//lib/dbf/table.rb#200
  def to_csv(path = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def version(*args, **_arg1, &block); end

  # Human readable version description
  #
  # @return [String]
  #
  # source://dbf//lib/dbf/table.rb#210
  def version_description; end

  private

  # source://dbf//lib/dbf/table.rb#216
  def build_columns; end

  # @return [Boolean]
  #
  # source://dbf//lib/dbf/table.rb#247
  def deleted_record?; end

  # @return [Boolean]
  #
  # source://dbf//lib/dbf/table.rb#252
  def end_of_record?; end

  # source://dbf//lib/dbf/table.rb#256
  def find_all(options); end

  # source://dbf//lib/dbf/table.rb#265
  def find_first(options); end

  # @return [Boolean]
  #
  # source://dbf//lib/dbf/table.rb#269
  def foxpro?; end

  # source://dbf//lib/dbf/table.rb#273
  def header; end

  # source://dbf//lib/dbf/table.rb#236
  def header_size; end

  # source://dbf//lib/dbf/table.rb#280
  def memo_class; end

  # source://dbf//lib/dbf/table.rb#290
  def memo_search_path(io); end

  # source://dbf//lib/dbf/table.rb#296
  def open_data(data); end

  # source://dbf//lib/dbf/table.rb#302
  def open_memo(data, memo = T.unsafe(nil)); end

  # source://dbf//lib/dbf/table.rb#312
  def safe_seek; end

  # source://dbf//lib/dbf/table.rb#317
  def seek(offset); end

  # source://dbf//lib/dbf/table.rb#321
  def seek_to_record(index); end
end

# source://dbf//lib/dbf/table.rb#15
DBF::Table::DBASE2_HEADER_SIZE = T.let(T.unsafe(nil), Integer)

# source://dbf//lib/dbf/table.rb#16
DBF::Table::DBASE3_HEADER_SIZE = T.let(T.unsafe(nil), Integer)

# source://dbf//lib/dbf/table.rb#17
DBF::Table::DBASE7_HEADER_SIZE = T.let(T.unsafe(nil), Integer)

# source://dbf//lib/dbf/table.rb#41
DBF::Table::FOXPRO_VERSIONS = T.let(T.unsafe(nil), Hash)

# source://dbf//lib/dbf/table.rb#19
DBF::Table::VERSIONS = T.let(T.unsafe(nil), Hash)

# source://dbf//lib/dbf/version.rb#2
DBF::VERSION = T.let(T.unsafe(nil), String)
