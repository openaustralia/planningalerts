# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sass` gem.
# Please instead update this file by running `bin/tapioca gem sass`.

# typed: true

module Sass
  extend ::Sass::Version
  extend ::Sass::Features

  class << self
    def compile(contents, options = T.unsafe(nil)); end
    def compile_file(filename, *args); end
    def load_paths; end
    def logger; end
    def logger=(l); end
    def tests_running; end
    def tests_running=(_arg0); end
  end
end

class Sass::BaseEnvironment
  def initialize(parent = T.unsafe(nil), options = T.unsafe(nil)); end

  def caller; end
  def caller=(_arg0); end
  def content; end
  def content=(_arg0); end
  def function(name); end
  def global?; end
  def global_env; end
  def is_function_global?(name); end
  def is_mixin_global?(name); end
  def is_var_global?(name); end
  def mixin(name); end
  def options; end
  def selector; end
  def selector=(_arg0); end
  def stack; end
  def var(name); end

  protected

  def _function(name); end
  def _mixin(name); end
  def _var(name); end

  class << self
    def inherited_hash_accessor(name); end
    def inherited_hash_reader(name); end
    def inherited_hash_writer(name); end
  end
end

module Sass::CacheStores; end

class Sass::CacheStores::Base
  def _retrieve(key, version, sha); end
  def _store(key, version, sha, contents); end
  def key(sass_dirname, sass_basename); end
  def retrieve(key, sha); end
  def store(key, sha, root); end
end

class Sass::CacheStores::Chain < ::Sass::CacheStores::Base
  def initialize(*caches); end

  def retrieve(key, sha); end
  def store(key, sha, obj); end
end

class Sass::CacheStores::Filesystem < ::Sass::CacheStores::Base
  def initialize(cache_location); end

  def _retrieve(key, version, sha); end
  def _store(key, version, sha, contents); end
  def cache_location; end
  def cache_location=(_arg0); end

  private

  def path_to(key); end
end

class Sass::CacheStores::Memory < ::Sass::CacheStores::Base
  def initialize; end

  def _dump(depth); end
  def reset!; end
  def retrieve(key, sha); end
  def store(key, sha, obj); end

  class << self
    def _load(repr); end
  end
end

class Sass::Callable < ::Struct
  def args; end
  def args=(_); end
  def environment; end
  def environment=(_); end
  def has_content; end
  def has_content=(_); end
  def name; end
  def name=(_); end
  def splat; end
  def splat=(_); end
  def tree; end
  def tree=(_); end
  def type; end
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Sass::Callbacks
  protected

  def define_callback(name); end

  class << self
    def extended(base); end
  end
end

module Sass::Callbacks::InstanceMethods
  def clear_callbacks!; end
end

class Sass::Deprecation
  def initialize; end

  def warn(filename, line, column_or_message, message = T.unsafe(nil)); end

  class << self
    def allow_double_warnings; end
  end
end

class Sass::Engine
  def initialize(template, options = T.unsafe(nil)); end

  def _dependencies(seen, engines); end
  def dependencies; end
  def options; end
  def render; end
  def render_with_sourcemap(sourcemap_uri); end
  def source_encoding; end
  def to_css; end
  def to_tree; end

  private

  def _render_with_sourcemap(sourcemap_uri); end
  def _to_tree; end
  def append_children(parent, children, root); end
  def build_tree(parent, line, root = T.unsafe(nil)); end
  def check_encoding!; end
  def check_for_no_children(node); end
  def format_comment_text(text, silent); end
  def full_line_range(line); end
  def parse_at_root_directive(parent, line, root, value, offset); end
  def parse_charset_directive(parent, line, root, value, offset); end
  def parse_comment(line); end
  def parse_content_directive(parent, line, root, value, offset); end
  def parse_debug_directive(parent, line, root, value, offset); end
  def parse_directive(parent, line, root); end
  def parse_each_directive(parent, line, root, value, offset); end
  def parse_else_directive(parent, line, root, value, offset); end
  def parse_error_directive(parent, line, root, value, offset); end
  def parse_extend_directive(parent, line, root, value, offset); end
  def parse_for_directive(parent, line, root, value, offset); end
  def parse_function_directive(parent, line, root, value, offset); end
  def parse_if_directive(parent, line, root, value, offset); end
  def parse_import_arg(scanner, offset); end
  def parse_import_directive(parent, line, root, value, offset); end
  def parse_include_directive(parent, line, root, value, offset); end
  def parse_interp(text, offset = T.unsafe(nil)); end
  def parse_line(parent, line, root); end
  def parse_media_directive(parent, line, root, value, offset); end
  def parse_mixin_definition(line); end
  def parse_mixin_directive(parent, line, root, value, offset); end
  def parse_mixin_include(line, root); end
  def parse_property(name, parsed_name, value, prop, line, start_offset); end
  def parse_property_or_rule(line); end
  def parse_return_directive(parent, line, root, value, offset); end
  def parse_script(script, options = T.unsafe(nil)); end
  def parse_variable(line); end
  def parse_warn_directive(parent, line, root, value, offset); end
  def parse_while_directive(parent, line, root, value, offset); end
  def sassc_key; end
  def tabulate(string); end
  def to_parser_offset(offset); end
  def tree(arr, i = T.unsafe(nil)); end
  def try_comment(line, last, tab_str, comment_tab_str, index); end
  def validate_and_append_child(parent, child, line, root); end

  class << self
    def for_file(filename, options); end
    def normalize_options(options); end
    def parse_interp(text, line, offset, options); end
  end
end

Sass::Engine::COMMENT_CHAR = T.let(T.unsafe(nil), String)
Sass::Engine::CONTENT_RE = T.let(T.unsafe(nil), Regexp)
Sass::Engine::CSS_COMMENT_CHAR = T.let(T.unsafe(nil), String)
Sass::Engine::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)
Sass::Engine::DIRECTIVES = T.let(T.unsafe(nil), Set)
Sass::Engine::DIRECTIVE_CHAR = T.let(T.unsafe(nil), String)
Sass::Engine::ESCAPE_CHAR = T.let(T.unsafe(nil), String)
Sass::Engine::FUNCTION_RE = T.let(T.unsafe(nil), Regexp)

class Sass::Engine::Line < ::Struct
  def comment?; end
end

Sass::Engine::MIXIN_DEFINITION_CHAR = T.let(T.unsafe(nil), String)
Sass::Engine::MIXIN_DEF_RE = T.let(T.unsafe(nil), Regexp)
Sass::Engine::MIXIN_INCLUDE_CHAR = T.let(T.unsafe(nil), String)
Sass::Engine::MIXIN_INCLUDE_RE = T.let(T.unsafe(nil), Regexp)
Sass::Engine::PROPERTY_CHAR = T.let(T.unsafe(nil), String)
Sass::Engine::PROPERTY_OLD = T.let(T.unsafe(nil), Regexp)
Sass::Engine::SASS_COMMENT_CHAR = T.let(T.unsafe(nil), String)
Sass::Engine::SASS_LOUD_COMMENT_CHAR = T.let(T.unsafe(nil), String)

class Sass::Environment < ::Sass::BaseEnvironment
  def parent; end
  def set_function(name, value); end
  def set_global_function(name, value); end
  def set_global_mixin(name, value); end
  def set_global_var(name, value); end
  def set_local_function(name, value); end
  def set_local_mixin(name, value); end
  def set_local_var(name, value); end
  def set_mixin(name, value); end
  def set_var(name, value); end

  protected

  def try_set_function(name, value); end
  def try_set_mixin(name, value); end
  def try_set_var(name, value); end
end

module Sass::Features
  def add_feature(feature_name); end
  def has_feature?(feature_name); end
end

Sass::Features::KNOWN_FEATURES = T.let(T.unsafe(nil), Set)
module Sass::Importers; end

class Sass::Importers::Base
  def directories_to_watch; end
  def find(uri, options); end
  def find_relative(uri, base, options); end
  def key(uri, options); end
  def mtime(uri, options); end
  def public_url(uri, sourcemap_directory); end
  def to_s; end
  def watched_file?(filename); end
end

class Sass::Importers::DeprecatedPath < ::Sass::Importers::Filesystem
  def initialize(root); end

  def directories_to_watch; end
  def find(*args); end
  def to_s; end

  protected

  def deprecation_warning; end
end

class Sass::Importers::Filesystem < ::Sass::Importers::Base
  def initialize(root); end

  def directories_to_watch; end
  def eql?(other); end
  def find(name, options); end
  def find_relative(name, base, options); end
  def hash; end
  def key(name, options); end
  def mtime(name, options); end
  def public_url(name, sourcemap_directory); end
  def root; end
  def root=(_arg0); end
  def to_s; end
  def watched_file?(filename); end

  protected

  def escape_glob_characters(name); end
  def extensions; end
  def find_real_file(dir, name, options); end
  def possible_files(name); end
  def remove_root(name); end
  def split(name); end

  private

  def _find(dir, name, options); end
end

Sass::Importers::Filesystem::REDUNDANT_DIRECTORY = T.let(T.unsafe(nil), Regexp)
module Sass::Logger; end

class Sass::Logger::Base
  include ::Sass::Logger::LogLevel
  extend ::Sass::Logger::LogLevel::ClassMethods

  def initialize(log_level = T.unsafe(nil), io = T.unsafe(nil)); end

  def _log(level, message); end
  def debug(message); end
  def disabled; end
  def disabled=(_arg0); end
  def error(message); end
  def info(message); end
  def io; end
  def io=(_arg0); end
  def log(level, message); end
  def log_level; end
  def log_level=(_arg0); end
  def logging_level?(level); end
  def trace(message); end
  def warn(message); end
end

class Sass::Logger::Delayed < ::Sass::Logger::Base
  def initialize(inner); end

  def _log(level, message); end
  def flush; end
  def uninstall!; end

  class << self
    def install!; end
  end
end

module Sass::Logger::LogLevel
  mixes_in_class_methods ::Sass::Logger::LogLevel::ClassMethods

  class << self
    def included(base); end
  end
end

module Sass::Logger::LogLevel::ClassMethods
  def define_logger(name, options = T.unsafe(nil)); end
  def inherited(subclass); end
  def log_level(name, options = T.unsafe(nil)); end
  def log_level?(level, min_level); end
  def log_levels; end
  def log_levels=(_arg0); end
end

module Sass::Media
  class << self
    def _interp_to_src(interp, options); end
  end
end

class Sass::Media::Query
  def initialize(modifier, type, expressions); end

  def deep_copy; end
  def expressions; end
  def expressions=(_arg0); end
  def merge(other); end
  def modifier; end
  def modifier=(_arg0); end
  def resolved_modifier; end
  def resolved_type; end
  def to_a; end
  def to_css; end
  def to_src(options); end
  def type; end
  def type=(_arg0); end
end

class Sass::Media::QueryList
  def initialize(queries); end

  def deep_copy; end
  def merge(other); end
  def queries; end
  def queries=(_arg0); end
  def to_a; end
  def to_css; end
  def to_src(options); end
end

module Sass::Plugin
  extend ::Sass::Plugin

  def check_for_updates; end
  def checked_for_updates; end
  def checked_for_updates=(_arg0); end
  def compiler; end
  def force_update_stylesheets(individual_files = T.unsafe(nil)); end
  def method_missing(method, *args, &block); end
  def options; end
  def respond_to?(method); end
  def update_stylesheets(individual_files = T.unsafe(nil)); end
end

class Sass::Plugin::Compiler
  include ::Sass::Plugin::Configuration
  include ::Sass::Callbacks::InstanceMethods
  extend ::Sass::Callbacks

  def initialize(opts = T.unsafe(nil)); end

  def clean(individual_files = T.unsafe(nil)); end
  def engine_options(additional_options = T.unsafe(nil)); end
  def file_list(individual_files = T.unsafe(nil)); end
  def on_compilation_error(&block); end
  def on_compilation_starting(&block); end
  def on_creating_directory(&block); end
  def on_deleting_css(&block); end
  def on_deleting_sourcemap(&block); end
  def on_not_updating_stylesheet(&block); end
  def on_template_created(&block); end
  def on_template_deleted(&block); end
  def on_template_modified(&block); end
  def on_updated_stylesheet(&block); end
  def on_updated_stylesheets(&block); end
  def on_updating_stylesheets(&block); end
  def stylesheet_needs_update?(css_file, template_file); end
  def update_stylesheets(individual_files = T.unsafe(nil)); end
  def watch(individual_files = T.unsafe(nil), options = T.unsafe(nil)); end

  private

  def child_of_directory?(parent, child); end
  def create_listener(*args, &block); end
  def css_filename(name, path); end
  def css_locations; end
  def listen_to(listener); end
  def load_paths(opts = T.unsafe(nil)); end
  def normalized_load_paths; end
  def on_file_changed(individual_files, modified, added, removed); end
  def relative_to_pwd(f); end
  def remove_redundant_directories(directories); end
  def run_compilation_error(*args); end
  def run_compilation_starting(*args); end
  def run_creating_directory(*args); end
  def run_deleting_css(*args); end
  def run_deleting_sourcemap(*args); end
  def run_not_updating_stylesheet(*args); end
  def run_template_created(*args); end
  def run_template_deleted(*args); end
  def run_template_modified(*args); end
  def run_updated_stylesheet(*args); end
  def run_updated_stylesheets(*args); end
  def run_updating_stylesheets(*args); end
  def sass_file_in_directory?(directory, filename); end
  def template_locations; end
  def try_delete_css(css); end
  def update_stylesheet(filename, css, sourcemap); end
  def watched_file?(file); end
  def watched_paths; end
  def write_file(fileName, content); end
end

module Sass::Plugin::Configuration
  def add_template_location(template_location, css_location = T.unsafe(nil)); end
  def default_options; end
  def options; end
  def remove_template_location(template_location, css_location = T.unsafe(nil)); end
  def reset!; end
  def template_location_array; end

  private

  def convert_template_location(template_location, css_location); end
  def normalize_template_location!; end
end

class Sass::Plugin::StalenessChecker
  def initialize(options); end

  def stylesheet_modified_since?(template_file, mtime, importer = T.unsafe(nil)); end
  def stylesheet_needs_update?(css_file, template_file, importer = T.unsafe(nil)); end

  private

  def compute_dependencies(uri, importer); end
  def dependencies(uri, importer); end
  def dependencies_stale?(uri, importer, css_mtime); end
  def dependency_updated?(css_mtime); end
  def mtime(uri, importer); end
  def tree(uri, importer); end
  def with_dependency_cache; end

  class << self
    def dependencies_cache; end
    def dependencies_cache=(_arg0); end
    def dependency_cache_mutex; end
    def stylesheet_modified_since?(template_file, mtime, importer = T.unsafe(nil)); end
    def stylesheet_needs_update?(css_file, template_file, importer = T.unsafe(nil)); end
  end
end

Sass::ROOT_DIR = T.let(T.unsafe(nil), String)

class Sass::ReadOnlyEnvironment < ::Sass::BaseEnvironment
  def caller; end
  def content; end
end

module Sass::SCSS; end

class Sass::SCSS::CssParser < ::Sass::SCSS::StaticParser
  private

  def block_child(context); end
  def block_contents(node, context); end
  def interpolation(warn_for_color = T.unsafe(nil)); end
  def keyframes_ruleset; end
  def nested_properties!(node); end
  def parent_selector; end
  def placeholder_selector; end
  def ruleset; end
  def use_css_import?; end
end

class Sass::SCSS::Parser
  include ::Sass::SCSS::RX

  def initialize(str, filename, importer, line = T.unsafe(nil), offset = T.unsafe(nil)); end

  def offset; end
  def offset=(_arg0); end
  def parse; end
  def parse_at_root_query; end
  def parse_interp_ident; end
  def parse_media_query_list; end
  def parse_supports_clause; end
  def parse_supports_condition; end

  private

  def _interp_string(type); end
  def _moz_document_directive(start_pos); end
  def almost_any_value; end
  def almost_any_value_token; end
  def at_root_directive(start_pos); end
  def at_root_directive_list; end
  def at_root_query; end
  def block(node, context); end
  def block_child(context); end
  def block_contents(node, context); end
  def catch_error(&block); end
  def charset_directive(start_pos); end
  def content_directive(start_pos); end
  def debug_directive(start_pos); end
  def declaration; end
  def declaration_or_ruleset; end
  def deprefix(str); end
  def directive; end
  def directive_body(value, start_pos); end
  def each_directive(start_pos); end
  def else_block(node); end
  def else_directive(start_pos); end
  def err(msg); end
  def error_directive(start_pos); end
  def expected(name); end
  def expr(allow_var = T.unsafe(nil)); end
  def expr!(name); end
  def extend_directive(start_pos); end
  def for_directive(start_pos); end
  def function(allow_var); end
  def function_directive(start_pos); end
  def has_children?(child_or_array); end
  def if_directive(start_pos); end
  def import_arg; end
  def import_directive(start_pos); end
  def import_supports_condition; end
  def include_directive(start_pos); end
  def init_scanner!; end
  def interp_ident(start = T.unsafe(nil)); end
  def interp_ident_or_var; end
  def interp_string; end
  def interp_uri; end
  def interpolation(warn_for_color = T.unsafe(nil)); end
  def media_directive(start_pos); end
  def media_expr; end
  def media_query; end
  def media_query_list; end
  def merge(arr); end
  def mixin_directive(start_pos); end
  def moz_document_function; end
  def nested_properties!(node); end
  def node(node, start_pos, end_pos = T.unsafe(nil)); end
  def operator; end
  def prefixed_directive(name, start_pos); end
  def process_comment(text, node); end
  def query_expr; end
  def range(start_pos, end_pos = T.unsafe(nil)); end
  def rethrow(err); end
  def return_directive(start_pos); end
  def ruleset; end
  def s(node); end
  def sass_script(*args); end
  def source_position; end
  def special_directive(name, start_pos); end
  def ss; end
  def ss_comments(node); end
  def str; end
  def str?; end
  def string; end
  def stylesheet; end
  def supports_clause; end
  def supports_condition; end
  def supports_condition_in_parens; end
  def supports_declaration; end
  def supports_directive(name, start_pos); end
  def supports_interpolation; end
  def supports_negation; end
  def supports_operator; end
  def term(allow_var); end
  def throw_error; end
  def tok(rx, last_group_lookahead = T.unsafe(nil)); end
  def tok!(rx); end
  def tok?(rx); end
  def try_declaration; end
  def use_css_import?; end
  def value!(css_variable = T.unsafe(nil)); end
  def var_expr; end
  def variable; end
  def warn_directive(start_pos); end
  def while_directive(start_pos); end
  def whitespace; end

  class << self
    def expected(scanner, expected, line); end
    def sass_script_parser; end
    def sass_script_parser=(_arg0); end
  end
end

Sass::SCSS::Parser::DIRECTIVES = T.let(T.unsafe(nil), Set)
Sass::SCSS::Parser::EXPR_NAMES = T.let(T.unsafe(nil), Hash)
Sass::SCSS::Parser::NEWLINE = T.let(T.unsafe(nil), String)
Sass::SCSS::Parser::PREFIXED_DIRECTIVES = T.let(T.unsafe(nil), Set)
Sass::SCSS::Parser::TOK_NAMES = T.let(T.unsafe(nil), Hash)

module Sass::SCSS::RX
  class << self
    def escape_char(c); end
    def escape_ident(str); end
    def quote(str, flags = T.unsafe(nil)); end
  end
end

Sass::SCSS::RX::ANY = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::CDC = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::CDO = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::COMMENT = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::DASHMATCH = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::DOMAIN = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::ESCAPE = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::FUNCTION = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::GREATER = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::H = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::HASH = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::HEXCOLOR = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::IDENT = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::IDENT_HYPHEN_INTERP = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::IDENT_START = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::IMPORTANT = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::INCLUDES = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::INTERP_START = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::NAME = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::NL = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::NMCHAR = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::NMSTART = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::NONASCII = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::NOT = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::NUMBER = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::OPTIONAL = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::PERCENTAGE = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::PLUS = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::PREFIXMATCH = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::RANGE = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::S = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::SINGLE_LINE_COMMENT = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::STATIC_COMPONENT = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::STATIC_SELECTOR = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::STATIC_VALUE = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::STRING = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::STRING1 = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::STRING1_NOINTERP = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::STRING2 = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::STRING2_NOINTERP = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::STRING_NOINTERP = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::SUBSTRINGMATCH = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::SUFFIXMATCH = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::TILDE = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::UNICODE = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::UNICODERANGE = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::UNIT = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::UNITLESS_NUMBER = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::URI = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::URL = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::URLCHAR = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::URL_PREFIX = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::VARIABLE = T.let(T.unsafe(nil), Regexp)
Sass::SCSS::RX::W = T.let(T.unsafe(nil), Regexp)

class Sass::SCSS::StaticParser < ::Sass::SCSS::Parser
  def initialize(str, filename, importer, line = T.unsafe(nil), offset = T.unsafe(nil), allow_parent_ref = T.unsafe(nil)); end

  def parse_keyframes_selector; end
  def parse_selector; end
  def parse_static_at_root_query; end

  private

  def a_n_plus_b; end
  def attrib; end
  def attrib_name!; end
  def class_selector; end
  def combinator; end
  def element_name; end
  def id_selector; end
  def interp_ident(ident = T.unsafe(nil)); end
  def interp_string; end
  def interp_uri; end
  def interpolation(warn_for_color = T.unsafe(nil)); end
  def keyframes_selector; end
  def keyframes_selector_component; end
  def moz_document_function; end
  def parent_selector; end
  def placeholder_selector; end
  def prefixed_selector_pseudo; end
  def pseudo; end
  def pseudo_args; end
  def pseudo_expr; end
  def pseudo_expr_token; end
  def qualified_name(allow_star_name = T.unsafe(nil)); end
  def reference_combinator; end
  def script_value; end
  def selector; end
  def selector_comma_sequence; end
  def selector_string; end
  def simple_selector_sequence; end
  def special_directive(name, start_pos); end
  def use_css_import?; end
  def var_expr; end
  def variable; end
end

Sass::SCSS::StaticParser::PREFIXED_SELECTOR_PSEUDO_CLASSES = T.let(T.unsafe(nil), Set)
Sass::SCSS::StaticParser::SELECTOR_PSEUDO_CLASSES = T.let(T.unsafe(nil), Set)

module Sass::Script
  class << self
    def const_missing(name); end
    def parse(value, line, offset, options = T.unsafe(nil)); end
  end
end

Sass::Script::ArgList = Sass::Script::Value::ArgList
Sass::Script::Bool = Sass::Script::Value::Bool
Sass::Script::CONST_RENAMES = T.let(T.unsafe(nil), Hash)
Sass::Script::Color = Sass::Script::Value::Color

class Sass::Script::CssLexer < ::Sass::Script::Lexer
  private

  def important; end
  def string(re, *args); end
  def token; end
end

class Sass::Script::CssParser < ::Sass::Script::Parser
  def div; end
  def or_expr; end

  private

  def interpolation; end
  def lexer_class; end
  def paren; end
  def string; end
  def unary_div; end
end

class Sass::Script::CssVariableWarning
  def initialize; end

  def value=(value); end
  def warn!; end

  private

  def print_warning; end
end

Sass::Script::Funcall = Sass::Script::Tree::Funcall

module Sass::Script::Functions
  include ::Compass::Core::SassExtensions::Functions::Configuration
  include ::Compass::Core::SassExtensions::Functions::Selectors
  include ::Compass::Core::SassExtensions::Functions::Enumerate
  include ::Compass::Core::SassExtensions::Functions::Urls
  include ::Compass::Core::SassExtensions::Functions::Urls::StylesheetUrl
  include ::Compass::Core::SassExtensions::Functions::Urls::FontUrl
  include ::Compass::Core::SassExtensions::Functions::Urls::ImageUrl
  include ::Compass::Core::SassExtensions::Functions::Urls::GeneratedImageUrl
  include ::Compass::Core::SassExtensions::Functions::Display
  include ::Compass::Core::SassExtensions::Functions::InlineImage
  include ::Compass::Core::SassExtensions::Functions::ImageSize
  include ::Sass::Script::Value::Helpers
  include ::Compass::Core::SassExtensions::Functions::GradientSupport::Functions
  include ::Compass::Core::SassExtensions::Functions::FontFiles
  include ::Compass::Core::SassExtensions::Functions::Files
  include ::Compass::Core::SassExtensions::Functions::Constants
  include ::Compass::Core::SassExtensions::Functions::Lists
  include ::Compass::Core::SassExtensions::Functions::Colors
  include ::Compass::Core::SassExtensions::Functions::Math
  include ::Compass::Core::SassExtensions::Functions::CrossBrowserSupport
  include ::Compass::Core::SassExtensions::Functions::Env
  include ::Compass::SassExtensions::Functions::Sprites
  include ::Sprockets::SassProcessor::Functions

  def abs(number); end
  def adjust_color(color, kwargs); end
  def adjust_hue(color, degrees); end
  def alpha(*args); end
  def append(list, val, separator = T.unsafe(nil)); end
  def blue(color); end
  def call(name, *args); end
  def ceil(number); end
  def change_color(color, kwargs); end
  def comparable(number1, number2); end
  def complement(color); end
  def counter(*args); end
  def counters(*args); end
  def darken(color, amount); end
  def desaturate(color, amount); end
  def fade_in(color, amount); end
  def fade_out(color, amount); end
  def feature_exists(feature); end
  def floor(number); end
  def function_exists(name); end
  def global_variable_exists(name); end
  def grayscale(color); end
  def green(color); end
  def hsl(hue, saturation, lightness); end
  def hsla(hue, saturation, lightness, alpha); end
  def hue(color); end
  def ie_hex_str(color); end
  def if(condition, if_true, if_false); end
  def index(list, value); end
  def inspect(value); end
  def invert(color); end
  def is_superselector(sup, sub); end
  def join(list1, list2, separator = T.unsafe(nil)); end
  def keywords(args); end
  def length(list); end
  def lighten(color, amount); end
  def lightness(color); end
  def list_separator(list); end
  def map_get(map, key); end
  def map_has_key(map, key); end
  def map_keys(map); end
  def map_merge(map1, map2); end
  def map_remove(map, *keys); end
  def map_values(map); end
  def max(*values); end
  def min(*numbers); end
  def mix(color1, color2, weight = T.unsafe(nil)); end
  def mixin_exists(name); end
  def nth(list, n); end
  def opacify(color, amount); end
  def opacity(color); end
  def percentage(number); end
  def quote(string); end
  def random(*args); end
  def red(color); end
  def rgb(red, green, blue); end
  def rgba(*args); end
  def round(number); end
  def sass_random(limit = T.unsafe(nil)); end
  def saturate(color, amount = T.unsafe(nil)); end
  def saturation(color); end
  def scale_color(color, kwargs); end
  def selector_append(*selectors); end
  def selector_extend(selector, extendee, extender); end
  def selector_nest(*selectors); end
  def selector_parse(selector); end
  def selector_replace(selector, original, replacement); end
  def selector_unify(selector1, selector2); end
  def set_nth(list, n, value); end
  def simple_selectors(selector); end
  def str_index(string, substring); end
  def str_insert(original, insert, index); end
  def str_length(string); end
  def str_slice(string, start_at, end_at = T.unsafe(nil)); end
  def to_lower_case(string); end
  def to_upper_case(string); end
  def transparentize(color, amount); end
  def type_of(value); end
  def unique_id; end
  def unit(number); end
  def unitless(number); end
  def unquote(string); end
  def variable_exists(name); end
  def zip(*lists); end

  private

  def _adjust(color, amount, attr, range, op, units = T.unsafe(nil)); end
  def check_alpha_unit(alpha, function); end
  def numeric_transformation(value); end

  class << self
    def callable?(*_arg0); end
    def declare(method_name, args, options = T.unsafe(nil)); end
    def random_number_generator; end
    def random_seed=(seed); end
    def signature(method_name, arg_arity, kwarg_arity); end

    private

    def include(*args); end
  end
end

class Sass::Script::Functions::EvaluationContext
  include ::Compass::Core::SassExtensions::Functions::Configuration
  include ::Compass::Core::SassExtensions::Functions::Selectors
  include ::Compass::Core::SassExtensions::Functions::Enumerate
  include ::Compass::Core::SassExtensions::Functions::Urls
  include ::Compass::Core::SassExtensions::Functions::Urls::StylesheetUrl
  include ::Compass::Core::SassExtensions::Functions::Urls::FontUrl
  include ::Compass::Core::SassExtensions::Functions::Urls::ImageUrl
  include ::Compass::Core::SassExtensions::Functions::Urls::GeneratedImageUrl
  include ::Compass::Core::SassExtensions::Functions::Display
  include ::Compass::Core::SassExtensions::Functions::InlineImage
  include ::Compass::Core::SassExtensions::Functions::ImageSize
  include ::Compass::Core::SassExtensions::Functions::GradientSupport::Functions
  include ::Compass::Core::SassExtensions::Functions::FontFiles
  include ::Compass::Core::SassExtensions::Functions::Files
  include ::Compass::Core::SassExtensions::Functions::Constants
  include ::Compass::Core::SassExtensions::Functions::Lists
  include ::Compass::Core::SassExtensions::Functions::Colors
  include ::Compass::Core::SassExtensions::Functions::Math
  include ::Compass::Core::SassExtensions::Functions::CrossBrowserSupport
  include ::Compass::Core::SassExtensions::Functions::Env
  include ::Compass::SassExtensions::Functions::Sprites
  include ::Sprockets::SassProcessor::Functions
  include ::Sass::Script::Functions
  include ::Sass::Script::Value::Helpers

  def initialize(environment); end

  def assert_integer(number, name = T.unsafe(nil)); end
  def assert_type(value, type, name = T.unsafe(nil)); end
  def assert_unit(number, unit, name = T.unsafe(nil)); end
  def environment; end
  def options; end
  def perform(node, env = T.unsafe(nil)); end
end

Sass::Script::Functions::EvaluationContext::TYPE_NAMES = T.let(T.unsafe(nil), Hash)

class Sass::Script::Functions::Signature < ::Struct
  def args; end
  def args=(_); end
  def delayed_args; end
  def delayed_args=(_); end
  def deprecated; end
  def deprecated=(_); end
  def var_args; end
  def var_args=(_); end
  def var_kwargs; end
  def var_kwargs=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

Sass::Script::Interpolation = Sass::Script::Tree::Interpolation

class Sass::Script::Lexer
  include ::Sass::SCSS::RX

  def initialize(str, line, offset, options); end

  def after_interpolation?; end
  def char(pos = T.unsafe(nil)); end
  def done?; end
  def expected!(name); end
  def line; end
  def next; end
  def offset; end
  def peek; end
  def str; end
  def unpeek!; end
  def whitespace?(tok = T.unsafe(nil)); end

  private

  def _variable(rx); end
  def color; end
  def id; end
  def ident; end
  def ident_op; end
  def number; end
  def op; end
  def range(start_pos, end_pos = T.unsafe(nil)); end
  def raw(rx); end
  def read_token; end
  def scan(re); end
  def selector; end
  def source_position; end
  def special_fun; end
  def special_fun_body(parens, prefix = T.unsafe(nil)); end
  def special_val; end
  def string(re, open); end
  def token; end
  def variable; end
  def whitespace; end

  class << self
    private

    def string_re(open, close); end
  end
end

Sass::Script::Lexer::IDENT_OP_NAMES = T.let(T.unsafe(nil), Array)
Sass::Script::Lexer::OPERATORS = T.let(T.unsafe(nil), Hash)
Sass::Script::Lexer::OPERATORS_REVERSE = T.let(T.unsafe(nil), Hash)
Sass::Script::Lexer::OP_NAMES = T.let(T.unsafe(nil), Array)
Sass::Script::Lexer::PARSEABLE_NUMBER = T.let(T.unsafe(nil), Regexp)
Sass::Script::Lexer::REGULAR_EXPRESSIONS = T.let(T.unsafe(nil), Hash)
Sass::Script::Lexer::STRING_REGULAR_EXPRESSIONS = T.let(T.unsafe(nil), Hash)
Sass::Script::Lexer::TOKEN_NAMES = T.let(T.unsafe(nil), Hash)

class Sass::Script::Lexer::Token < ::Struct
  def pos; end
  def pos=(_); end
  def source_range; end
  def source_range=(_); end
  def type; end
  def type=(_); end
  def value; end
  def value=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

Sass::Script::List = Sass::Script::Value::List
Sass::Script::Literal = Sass::Script::Value::Base
Sass::Script::MATCH = T.let(T.unsafe(nil), Regexp)
Sass::Script::Node = Sass::Script::Tree::Node
Sass::Script::Null = Sass::Script::Value::Null
Sass::Script::Number = Sass::Script::Value::Number
Sass::Script::Operation = Sass::Script::Tree::Operation

class Sass::Script::Parser
  def initialize(str, line, offset, options = T.unsafe(nil)); end

  def and_expr; end
  def eq_or_neq; end
  def equals; end
  def line; end
  def offset; end
  def or_expr; end
  def parse(css_variable = T.unsafe(nil)); end
  def parse_function_definition_arglist; end
  def parse_interpolated(warn_for_color = T.unsafe(nil)); end
  def parse_mixin_definition_arglist; end
  def parse_mixin_include_arglist; end
  def parse_string; end
  def parse_until(tokens); end
  def plus_or_minus; end
  def relational; end
  def times_div_or_mod; end
  def unary_div; end
  def unary_minus; end
  def unary_not; end
  def unary_plus; end

  private

  def arglist(subexpr, description); end
  def assert_done; end
  def assert_expr(name, expected = T.unsafe(nil)); end
  def assert_tok(name); end
  def assert_toks(*names); end
  def check_for_interpolation(node); end
  def defn_arglist!(must_have_parens); end
  def expr; end
  def fn_arglist; end
  def funcall; end
  def ident; end
  def interpolation(first = T.unsafe(nil)); end
  def interpolation_deprecation(interpolation); end
  def is_safe_value?(expr); end
  def is_unsafe_before?(expr, char_before); end
  def lexer_class; end
  def list(first, start_pos); end
  def literal; end
  def literal_node(value, source_range_or_start_pos, end_pos = T.unsafe(nil)); end
  def map; end
  def map_pair(key = T.unsafe(nil)); end
  def mixin_arglist; end
  def node(node, source_range_or_start_pos, end_pos = T.unsafe(nil)); end
  def number; end
  def paren; end
  def range(start_pos, end_pos = T.unsafe(nil)); end
  def raw; end
  def selector; end
  def source_position; end
  def space; end
  def special_fun; end
  def string; end
  def try_op_before_interp(op, prev = T.unsafe(nil), after_interp = T.unsafe(nil)); end
  def try_ops_after_interp(ops, name, prev = T.unsafe(nil)); end
  def try_tok(name); end
  def try_toks(*names); end
  def variable; end
  def without_css_variable_warning; end

  class << self
    def associative?(op); end
    def parse(value, line, offset, options = T.unsafe(nil)); end
    def precedence_of(op); end

    private

    def production(name, sub, *ops); end
    def unary(op, sub); end
  end
end

Sass::Script::Parser::ASSOCIATIVE = T.let(T.unsafe(nil), Array)
Sass::Script::Parser::EXPR_NAMES = T.let(T.unsafe(nil), Hash)
Sass::Script::Parser::PRECEDENCE = T.let(T.unsafe(nil), Array)
Sass::Script::Parser::VALID_CSS_OPS = T.let(T.unsafe(nil), Array)
Sass::Script::String = Sass::Script::Value::String
Sass::Script::StringInterpolation = Sass::Script::Tree::StringInterpolation
module Sass::Script::Tree; end

class Sass::Script::Tree::Funcall < ::Sass::Script::Tree::Node
  include ::Sass::Script::HasSimpleCrossBrowserFunctionSupport

  def initialize(name, args, keywords, splat, kwarg_splat); end

  def args; end
  def children; end
  def deep_copy; end
  def inspect; end
  def keywords; end
  def kwarg_splat; end
  def kwarg_splat=(_arg0); end
  def name; end
  def splat; end
  def splat=(_arg0); end
  def to_sass(opts = T.unsafe(nil)); end
  def to_value(args); end

  protected

  def _perform(environment); end
  def sass_to_value(args); end
  def to_literal(args); end

  private

  def construct_ruby_args(name, args, splat, environment); end
  def perform_arg(argument, environment, name); end
  def perform_sass_fn(function, args, splat, environment); end
  def reformat_argument_error(e); end
  def ruby_name; end
  def signature; end
  def without_original(value); end
end

class Sass::Script::Tree::Interpolation < ::Sass::Script::Tree::Node
  def initialize(before, mid, after, wb, wa, opts = T.unsafe(nil)); end

  def after; end
  def before; end
  def children; end
  def deep_copy; end
  def deprecation; end
  def inspect; end
  def mid; end
  def originally_text; end
  def to_quoted_equivalent; end
  def to_sass(opts = T.unsafe(nil)); end
  def warn_for_color; end
  def whitespace_after; end
  def whitespace_before; end

  protected

  def to_string_interpolation(node_or_interp); end

  private

  def _perform(environment); end
  def concat(string_or_interp1, string_or_interp2); end
  def string_literal(string); end
end

class Sass::Script::Tree::ListLiteral < ::Sass::Script::Tree::Node
  def initialize(elements, separator); end

  def children; end
  def deep_copy; end
  def elements; end
  def force_division!; end
  def inspect; end
  def separator; end
  def to_sass(opts = T.unsafe(nil)); end

  protected

  def _perform(environment); end

  private

  def element_needs_parens?(element); end
  def is_literal_number?(value); end
  def sep_str(opts = T.unsafe(nil)); end
end

class Sass::Script::Tree::Literal < ::Sass::Script::Tree::Node
  def initialize(value); end

  def children; end
  def deep_copy; end
  def force_division!; end
  def inspect; end
  def options=(options); end
  def to_sass(opts = T.unsafe(nil)); end
  def value; end

  protected

  def _perform(environment); end
end

class Sass::Script::Tree::MapLiteral < ::Sass::Script::Tree::Node
  def initialize(pairs); end

  def children; end
  def deep_copy; end
  def inspect(opts = T.unsafe(nil)); end
  def pairs; end
  def to_sass(opts = T.unsafe(nil)); end

  protected

  def _perform(environment); end
end

class Sass::Script::Tree::Node
  def children; end
  def css_variable_warning; end
  def css_variable_warning=(_arg0); end
  def deep_copy; end
  def filename; end
  def filename=(_arg0); end
  def force_division!; end
  def line; end
  def line=(_arg0); end
  def options; end
  def options=(options); end
  def perform(environment); end
  def source_range; end
  def source_range=(_arg0); end
  def to_sass(opts = T.unsafe(nil)); end

  protected

  def _perform(environment); end
  def dasherize(s, opts); end
  def opts(value); end
end

class Sass::Script::Tree::Operation < ::Sass::Script::Tree::Node
  def initialize(operand1, operand2, operator); end

  def children; end
  def deep_copy; end
  def inspect; end
  def operand1; end
  def operand2; end
  def operator; end
  def to_sass(opts = T.unsafe(nil)); end

  protected

  def _perform(environment); end

  private

  def operand_to_sass(op, side, opts); end
  def warn_for_color_arithmetic(value1, value2); end
  def warn_for_unitless_equals(value1, value2, result); end
end

class Sass::Script::Tree::Selector < ::Sass::Script::Tree::Node
  def initialize; end

  def children; end
  def deep_copy; end
  def to_sass(opts = T.unsafe(nil)); end

  protected

  def _perform(environment); end
end

class Sass::Script::Tree::StringInterpolation < ::Sass::Script::Tree::Node
  def initialize(before, mid, after); end

  def after; end
  def before; end
  def children; end
  def deep_copy; end
  def inspect; end
  def mid; end
  def quote; end
  def to_sass(opts = T.unsafe(nil)); end
  def type; end

  protected

  def _perform(environment); end

  private

  def _to_sass(string_or_interp, opts); end
  def quote_for(string_or_interp); end
end

class Sass::Script::Tree::UnaryOperation < ::Sass::Script::Tree::Node
  def initialize(operand, operator); end

  def children; end
  def deep_copy; end
  def inspect; end
  def operand; end
  def operator; end
  def to_sass(opts = T.unsafe(nil)); end

  protected

  def _perform(environment); end
end

class Sass::Script::Tree::Variable < ::Sass::Script::Tree::Node
  def initialize(name); end

  def children; end
  def deep_copy; end
  def inspect(opts = T.unsafe(nil)); end
  def name; end
  def to_sass(opts = T.unsafe(nil)); end
  def underscored_name; end

  protected

  def _perform(environment); end
end

Sass::Script::UnaryOperation = Sass::Script::Tree::UnaryOperation
Sass::Script::VALIDATE = T.let(T.unsafe(nil), Regexp)
module Sass::Script::Value; end

class Sass::Script::Value::ArgList < ::Sass::Script::Value::List
  def initialize(value, keywords, separator); end

  def children; end
  def keywords; end
  def keywords_accessed; end
  def keywords_accessed=(_arg0); end
end

class Sass::Script::Value::Base
  def initialize(value = T.unsafe(nil)); end

  def ==(other); end
  def assert_int!; end
  def children; end
  def div(other); end
  def eq(other); end
  def eql?(other); end
  def hash; end
  def inspect; end
  def minus(other); end
  def neq(other); end
  def null?; end
  def options; end
  def options=(_arg0); end
  def opts(value); end
  def plus(other); end
  def separator; end
  def single_eq(other); end
  def source_range; end
  def source_range=(_arg0); end
  def to_a; end
  def to_bool; end
  def to_h; end
  def to_i; end
  def to_s(opts = T.unsafe(nil)); end
  def to_sass(opts = T.unsafe(nil)); end
  def unary_div; end
  def unary_minus; end
  def unary_not; end
  def unary_plus; end
  def value; end

  protected

  def _perform(environment); end
end

Sass::Script::Value::Base::NO_CHILDREN = T.let(T.unsafe(nil), Array)

class Sass::Script::Value::Bool < ::Sass::Script::Value::Base
  def to_bool; end
  def to_s(opts = T.unsafe(nil)); end
  def to_sass(opts = T.unsafe(nil)); end
  def value; end

  class << self
    def new(value); end
  end
end

Sass::Script::Value::Bool::FALSE = T.let(T.unsafe(nil), Sass::Script::Value::Bool)
Sass::Script::Value::Bool::TRUE = T.let(T.unsafe(nil), Sass::Script::Value::Bool)

class Sass::Script::Value::Color < ::Sass::Script::Value::Base
  def initialize(attrs, representation = T.unsafe(nil), allow_both_rgb_and_hsl = T.unsafe(nil)); end

  def alpha; end
  def alpha?; end
  def blue; end
  def div(other); end
  def eq(other); end
  def green; end
  def hash; end
  def hsl; end
  def hsla; end
  def hue; end
  def inspect; end
  def lightness; end
  def minus(other); end
  def mod(other); end
  def name; end
  def plus(other); end
  def red; end
  def representation; end
  def rgb; end
  def rgba; end
  def saturation; end
  def times(other); end
  def to_s(opts = T.unsafe(nil)); end
  def to_sass(opts = T.unsafe(nil)); end
  def with(attrs); end

  private

  def hex_str; end
  def hsl_to_rgb!; end
  def hue_to_rgb(m1, m2, h); end
  def operation_name(operation); end
  def piecewise(other, operation); end
  def rgb_to_hsl!; end
  def rgba_str; end
  def smallest; end

  class << self
    def from_hex(hex_string, alpha = T.unsafe(nil)); end
    def int_to_rgba(color); end
  end
end

Sass::Script::Value::Color::ALTERNATE_COLOR_NAMES = T.let(T.unsafe(nil), Hash)
Sass::Script::Value::Color::COLOR_NAMES = T.let(T.unsafe(nil), Hash)
Sass::Script::Value::Color::COLOR_NAMES_REVERSE = T.let(T.unsafe(nil), Hash)

module Sass::Script::Value::Helpers
  def bool(value); end
  def calc?(literal); end
  def hex_color(value, alpha = T.unsafe(nil)); end
  def hsl_color(hue, saturation, lightness, alpha = T.unsafe(nil)); end
  def identifier(str); end
  def list(*elements); end
  def map(hash); end
  def null; end
  def number(number, unit_string = T.unsafe(nil)); end
  def parse_complex_selector(value, name = T.unsafe(nil), allow_parent_ref = T.unsafe(nil)); end
  def parse_compound_selector(value, name = T.unsafe(nil), allow_parent_ref = T.unsafe(nil)); end
  def parse_selector(value, name = T.unsafe(nil), allow_parent_ref = T.unsafe(nil)); end
  def quoted_string(str); end
  def rgb_color(red, green, blue, alpha = T.unsafe(nil)); end
  def unquoted_string(str); end

  private

  def normalize_selector(value, name); end
  def parse_unit_string(unit_string); end
  def selector_to_str(value); end
end

Sass::Script::Value::Helpers::VALID_UNIT = T.let(T.unsafe(nil), Regexp)

class Sass::Script::Value::List < ::Sass::Script::Value::Base
  def initialize(value, separator); end

  def children; end
  def eq(other); end
  def has_aspect?; end
  def hash; end
  def inspect; end
  def options=(options); end
  def separator; end
  def supports?(aspect); end
  def to_a; end
  def to_h; end
  def to_s(opts = T.unsafe(nil)); end
  def to_sass(opts = T.unsafe(nil)); end
  def value; end

  private

  def element_needs_parens?(element); end
  def sep_str(opts = T.unsafe(nil)); end

  class << self
    def assert_valid_index(list, n); end
  end
end

class Sass::Script::Value::Map < ::Sass::Script::Value::Base
  def initialize(hash); end

  def children; end
  def eq(other); end
  def hash; end
  def inspect(opts = T.unsafe(nil)); end
  def options=(options); end
  def separator; end
  def to_a; end
  def to_h; end
  def to_s(opts = T.unsafe(nil)); end
  def to_sass(opts = T.unsafe(nil)); end
  def value; end
end

class Sass::Script::Value::Null < ::Sass::Script::Value::Base
  def inspect; end
  def null?; end
  def to_bool; end
  def to_s(opts = T.unsafe(nil)); end
  def to_sass(opts = T.unsafe(nil)); end

  class << self
    def new; end
  end
end

Sass::Script::Value::Null::NULL = T.let(T.unsafe(nil), Sass::Script::Value::Null)

class Sass::Script::Value::Number < ::Sass::Script::Value::Base
  def initialize(value, numerator_units = T.unsafe(nil), denominator_units = T.unsafe(nil)); end

  def coerce(num_units, den_units); end
  def comparable_to?(other); end
  def denominator_units; end
  def div(other); end
  def eq(other); end
  def eql?(other); end
  def gt(other); end
  def gte(other); end
  def hash; end
  def inspect(opts = T.unsafe(nil)); end
  def int?; end
  def is_unit?(unit); end
  def legal_units?; end
  def lt(other); end
  def lte(other); end
  def minus(other); end
  def mod(other); end
  def numerator_units; end
  def original; end
  def original=(_arg0); end
  def plus(other); end
  def times(other); end
  def to_i; end
  def to_s(opts = T.unsafe(nil)); end
  def to_sass(opts = T.unsafe(nil)); end
  def unary_minus; end
  def unary_plus; end
  def unit_str; end
  def unitless?; end
  def value; end

  private

  def basically_equal?(num1, num2); end
  def coercion_factor(from_units, to_units); end
  def compute_units(this, other, operation); end
  def conversion_factor(from_unit, to_unit); end
  def convertable?(units); end
  def normalize!; end
  def operate(other, operation); end
  def sans_common_units(units1, units2); end

  class << self
    def basically_equal?(num1, num2); end
    def epsilon; end
    def precision; end
    def precision=(digits); end
    def precision_factor; end
    def round(num); end
  end
end

Sass::Script::Value::Number::CONVERSION_TABLE = T.let(T.unsafe(nil), Hash)
Sass::Script::Value::Number::MUTUALLY_CONVERTIBLE = T.let(T.unsafe(nil), Hash)
Sass::Script::Value::Number::NO_UNITS = T.let(T.unsafe(nil), Array)
Sass::Script::Value::Number::OPERATIONS = T.let(T.unsafe(nil), Array)

class Sass::Script::Value::String < ::Sass::Script::Value::Base
  def initialize(value, type = T.unsafe(nil), deprecated_interp_equivalent = T.unsafe(nil)); end

  def check_deprecated_interp; end
  def inspect; end
  def plus(other); end
  def separator; end
  def to_a; end
  def to_s(opts = T.unsafe(nil)); end
  def to_sass(opts = T.unsafe(nil)); end
  def type; end
  def value; end

  class << self
    def quote(contents, opts = T.unsafe(nil)); end
    def value(contents); end
  end
end

Sass::Script::Variable = Sass::Script::Tree::Variable
module Sass::Selector; end

class Sass::Selector::AbstractSequence
  def ==(other); end
  def eql?(other); end
  def filename; end
  def filename=(filename); end
  def has_placeholder?; end
  def hash; end
  def line; end
  def line=(line); end
  def specificity; end
  def to_s(opts = T.unsafe(nil)); end

  protected

  def _specificity(arr); end
end

class Sass::Selector::Attribute < ::Sass::Selector::Simple
  def initialize(name, namespace, operator, value, flags); end

  def flags; end
  def name; end
  def namespace; end
  def operator; end
  def specificity; end
  def to_s(opts = T.unsafe(nil)); end
  def value; end
end

class Sass::Selector::Class < ::Sass::Selector::Simple
  def initialize(name); end

  def name; end
  def specificity; end
  def to_s(opts = T.unsafe(nil)); end
end

class Sass::Selector::CommaSequence < ::Sass::Selector::AbstractSequence
  def initialize(seqs); end

  def contains_parent_ref?; end
  def do_extend(extends, parent_directives = T.unsafe(nil), replace = T.unsafe(nil), seen = T.unsafe(nil), original = T.unsafe(nil)); end
  def inspect; end
  def members; end
  def populate_extends(extends, extendee, extend_node = T.unsafe(nil), parent_directives = T.unsafe(nil), allow_compound_target = T.unsafe(nil)); end
  def resolve_parent_refs(super_cseq, implicit_parent = T.unsafe(nil)); end
  def superselector?(cseq); end
  def to_s(opts = T.unsafe(nil)); end
  def to_sass_script; end
  def unify(other); end

  private

  def _eql?(other); end
  def _hash; end
end

class Sass::Selector::Element < ::Sass::Selector::Simple
  def initialize(name, namespace); end

  def name; end
  def namespace; end
  def specificity; end
  def to_s(opts = T.unsafe(nil)); end
  def unify(sels); end
end

class Sass::Selector::Id < ::Sass::Selector::Simple
  def initialize(name); end

  def name; end
  def specificity; end
  def to_s(opts = T.unsafe(nil)); end
  def unify(sels); end
end

class Sass::Selector::Parent < ::Sass::Selector::Simple
  def initialize(suffix = T.unsafe(nil)); end

  def suffix; end
  def to_s(opts = T.unsafe(nil)); end
  def unify(sels); end
end

class Sass::Selector::Placeholder < ::Sass::Selector::Simple
  def initialize(name); end

  def name; end
  def specificity; end
  def to_s(opts = T.unsafe(nil)); end
end

class Sass::Selector::Pseudo < ::Sass::Selector::Simple
  def initialize(syntactic_type, name, arg, selector); end

  def arg; end
  def name; end
  def normalized_name; end
  def selector; end
  def specificity; end
  def superselector?(their_sseq, parents = T.unsafe(nil)); end
  def syntactic_type; end
  def to_s(opts = T.unsafe(nil)); end
  def type; end
  def unify(sels); end
  def with_selector(new_selector); end
end

Sass::Selector::Pseudo::ACTUALLY_ELEMENTS = T.let(T.unsafe(nil), Set)
Sass::Selector::SPECIFICITY_BASE = T.let(T.unsafe(nil), Integer)

class Sass::Selector::Sequence < ::Sass::Selector::AbstractSequence
  def initialize(seqs_and_ops); end

  def add_sources!(sources); end
  def contains_parent_ref?; end
  def do_extend(extends, parent_directives, replace, seen, original); end
  def filename=(filename); end
  def inspect; end
  def line=(line); end
  def members; end
  def resolve_parent_refs(super_cseq, implicit_parent); end
  def subjectless; end
  def superselector?(seq); end
  def to_s(opts = T.unsafe(nil)); end
  def unify(other); end

  private

  def _eql?(other); end
  def _hash; end
  def _sources(seq); end
  def _superselector?(seq1, seq2); end
  def chunks(seq1, seq2); end
  def extended_not_expanded_to_s(extended_not_expanded); end
  def group_selectors(seq); end
  def has_root?(sseq); end
  def merge_final_ops(seq1, seq2, res = T.unsafe(nil)); end
  def merge_initial_ops(seq1, seq2); end
  def parent_superselector?(seq1, seq2); end
  def path_has_two_subjects?(path); end
  def subweave(seq1, seq2); end
  def trim(seqses); end
  def weave(path); end
end

class Sass::Selector::Simple
  def ==(other); end
  def eql?(other); end
  def filename; end
  def filename=(_arg0); end
  def hash; end
  def inspect; end
  def line; end
  def line=(_arg0); end
  def to_s(opts = T.unsafe(nil)); end
  def unify(sels); end

  protected

  def equality_key; end
  def unify_namespaces(ns1, ns2); end
end

class Sass::Selector::SimpleSequence < ::Sass::Selector::AbstractSequence
  def initialize(selectors, subject, source_range = T.unsafe(nil)); end

  def base; end
  def do_extend(extends, parent_directives, replace, seen); end
  def inspect; end
  def members; end
  def members=(_arg0); end
  def pseudo_elements; end
  def resolve_parent_refs(super_cseq); end
  def rest; end
  def selector_pseudo_classes; end
  def source_range; end
  def source_range=(_arg0); end
  def sources; end
  def sources=(_arg0); end
  def subject=(_arg0); end
  def subject?; end
  def superselector?(their_sseq, parents = T.unsafe(nil)); end
  def to_s(opts = T.unsafe(nil)); end
  def unify(other); end
  def with_more_sources(sources); end

  private

  def _eql?(other); end
  def _hash; end
  def check_directives_match!(extend, parent_directives); end
end

class Sass::Selector::Universal < ::Sass::Selector::Simple
  def initialize(namespace); end

  def namespace; end
  def specificity; end
  def to_s(opts = T.unsafe(nil)); end
  def unify(sels); end
end

class Sass::SemiGlobalEnvironment < ::Sass::Environment
  def try_set_var(name, value); end
end

module Sass::Shared
  extend ::Sass::Shared

  def balance(scanner, start, finish, count = T.unsafe(nil)); end
  def handle_interpolation(str); end
  def human_indentation(indentation, was = T.unsafe(nil)); end
end

module Sass::Source; end

class Sass::Source::Map
  def initialize; end

  def add(input, output); end
  def data; end
  def shift_output_lines(delta); end
  def shift_output_offsets(delta); end
  def to_json(options); end

  private

  def write_json_field(out, name, value, is_first = T.unsafe(nil)); end
end

class Sass::Source::Map::Mapping < ::Struct
  def inspect; end
end

class Sass::Source::Position
  def initialize(line, offset); end

  def after(str); end
  def inspect; end
  def line; end
  def line=(_arg0); end
  def offset; end
  def offset=(_arg0); end
end

class Sass::Source::Range
  def initialize(start_pos, end_pos, file, importer = T.unsafe(nil)); end

  def end_pos; end
  def end_pos=(_arg0); end
  def file; end
  def file=(_arg0); end
  def importer; end
  def importer=(_arg0); end
  def inspect; end
  def start_pos; end
  def start_pos=(_arg0); end
end

class Sass::Stack
  def initialize; end

  def frames; end
  def to_s; end
  def with_base(filename, line); end
  def with_import(filename, line); end
  def with_mixin(filename, line, name); end

  private

  def with_frame(filename, line, type, name = T.unsafe(nil)); end
end

class Sass::Stack::Frame
  def initialize(filename, line, type, name = T.unsafe(nil)); end

  def filename; end
  def is_base?; end
  def is_import?; end
  def is_mixin?; end
  def line; end
  def name; end
  def type; end
end

module Sass::Supports; end

class Sass::Supports::Condition
  def deep_copy; end
  def options=(options); end
  def perform(environment); end
  def to_css; end
  def to_src(options); end
end

class Sass::Supports::Declaration < ::Sass::Supports::Condition
  def initialize(name, value); end

  def deep_copy; end
  def name; end
  def name=(_arg0); end
  def options=(options); end
  def perform(env); end
  def resolved_name; end
  def resolved_name=(_arg0); end
  def resolved_value; end
  def resolved_value=(_arg0); end
  def to_css; end
  def to_src(options); end
  def value; end
  def value=(_arg0); end
end

class Sass::Supports::Interpolation < ::Sass::Supports::Condition
  def initialize(value); end

  def deep_copy; end
  def options=(options); end
  def perform(env); end
  def resolved_value; end
  def resolved_value=(_arg0); end
  def to_css; end
  def to_src(options); end
  def value; end
  def value=(_arg0); end
end

class Sass::Supports::Negation < ::Sass::Supports::Condition
  def initialize(condition); end

  def condition; end
  def condition=(_arg0); end
  def deep_copy; end
  def options=(options); end
  def perform(env); end
  def to_css; end
  def to_src(options); end

  private

  def parens(str); end
end

class Sass::Supports::Operator < ::Sass::Supports::Condition
  def initialize(left, right, op); end

  def deep_copy; end
  def left; end
  def left=(_arg0); end
  def op; end
  def op=(_arg0); end
  def options=(options); end
  def perform(env); end
  def right; end
  def right=(_arg0); end
  def to_css; end
  def to_src(options); end

  private

  def parens(condition, str); end
end

class Sass::SyntaxError < ::StandardError
  def initialize(msg, attrs = T.unsafe(nil)); end

  def add_backtrace(attrs); end
  def backtrace; end
  def modify_backtrace(attrs); end
  def sass_backtrace; end
  def sass_backtrace=(_arg0); end
  def sass_backtrace_str(default_filename = T.unsafe(nil)); end
  def sass_filename; end
  def sass_line; end
  def sass_mixin; end
  def sass_template; end
  def sass_template=(_arg0); end
  def to_s; end

  class << self
    def exception_to_css(e, line_offset = T.unsafe(nil)); end

    private

    def header_string(e, line_offset); end
  end
end

module Sass::Tree; end

class Sass::Tree::AtRootNode < ::Sass::Tree::Node
  def initialize(query = T.unsafe(nil)); end

  def bubbles?; end
  def exclude?(directive); end
  def exclude_node?(node); end
  def group_end; end
  def group_end=(_arg0); end
  def query; end
  def query=(_arg0); end
  def resolved_type; end
  def resolved_type=(_arg0); end
  def resolved_value; end
  def resolved_value=(_arg0); end
  def tabs; end
  def tabs=(_arg0); end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::CharsetNode < ::Sass::Tree::Node
  def initialize(name); end

  def invisible?; end
  def name; end
  def name=(_arg0); end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::CommentNode < ::Sass::Tree::Node
  def initialize(value, type); end

  def ==(other); end
  def invisible?; end
  def lines; end
  def resolved_value; end
  def resolved_value=(_arg0); end
  def type; end
  def type=(_arg0); end
  def value; end
  def value=(_arg0); end

  private

  def normalize_indentation(str); end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::ContentNode < ::Sass::Tree::Node
  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::CssImportNode < ::Sass::Tree::DirectiveNode
  def initialize(uri, query = T.unsafe(nil), supports_condition = T.unsafe(nil)); end

  def query; end
  def query=(_arg0); end
  def resolved_query; end
  def resolved_query=(_arg0); end
  def resolved_uri; end
  def resolved_uri=(_arg0); end
  def resolved_value; end
  def supports_condition; end
  def supports_condition=(_arg0); end
  def uri; end
  def uri=(_arg0); end
  def value; end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def resolved(uri); end
    def visit_method; end
  end
end

class Sass::Tree::DebugNode < ::Sass::Tree::Node
  def initialize(expr); end

  def expr; end
  def expr=(_arg0); end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::DirectiveNode < ::Sass::Tree::Node
  def initialize(value); end

  def bubbles?; end
  def group_end; end
  def group_end=(_arg0); end
  def name; end
  def normalized_name; end
  def resolved_value; end
  def resolved_value=(_arg0); end
  def tabs; end
  def tabs=(_arg0); end
  def value; end
  def value=(_arg0); end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def resolved(value); end
    def visit_method; end
  end
end

class Sass::Tree::EachNode < ::Sass::Tree::Node
  def initialize(vars, list); end

  def list; end
  def list=(_arg0); end
  def vars; end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::ErrorNode < ::Sass::Tree::Node
  def initialize(expr); end

  def expr; end
  def expr=(_arg0); end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::ExtendNode < ::Sass::Tree::Node
  def initialize(selector, optional, selector_source_range); end

  def optional?; end
  def resolved_selector; end
  def resolved_selector=(_arg0); end
  def selector; end
  def selector=(_arg0); end
  def selector_source_range; end
  def selector_source_range=(_arg0); end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::ForNode < ::Sass::Tree::Node
  def initialize(var, from, to, exclusive); end

  def exclusive; end
  def from; end
  def from=(_arg0); end
  def to; end
  def to=(_arg0); end
  def var; end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::FunctionNode < ::Sass::Tree::Node
  def initialize(name, args, splat); end

  def args; end
  def args=(_arg0); end
  def name; end
  def normalized_name; end
  def splat; end
  def splat=(_arg0); end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::IfNode < ::Sass::Tree::Node
  def initialize(expr); end

  def _dump(f); end
  def add_else(node); end
  def else; end
  def else=(_arg0); end
  def expr; end
  def expr=(_arg0); end

  class << self
    def _load(data); end
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::ImportNode < ::Sass::Tree::RootNode
  def initialize(imported_filename); end

  def css_import?; end
  def imported_file; end
  def imported_file=(_arg0); end
  def imported_filename; end
  def invisible?; end

  private

  def import; end
  def options_for_importer; end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::KeyframeRuleNode < ::Sass::Tree::Node
  def initialize(resolved_value); end

  def resolved_value; end
  def resolved_value=(_arg0); end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::MediaNode < ::Sass::Tree::DirectiveNode
  def initialize(query); end

  def invisible?; end
  def name; end
  def query; end
  def query=(_arg0); end
  def resolved_query; end
  def resolved_query=(_arg0); end
  def resolved_value; end
  def value; end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::MixinDefNode < ::Sass::Tree::Node
  def initialize(name, args, splat); end

  def args; end
  def args=(_arg0); end
  def has_content; end
  def has_content=(_arg0); end
  def name; end
  def splat; end
  def splat=(_arg0); end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::MixinNode < ::Sass::Tree::Node
  def initialize(name, args, keywords, splat, kwarg_splat); end

  def args; end
  def args=(_arg0); end
  def keywords; end
  def keywords=(_arg0); end
  def kwarg_splat; end
  def kwarg_splat=(_arg0); end
  def name; end
  def splat; end
  def splat=(_arg0); end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::Node
  include ::Enumerable

  def initialize; end

  def <<(child); end
  def ==(other); end
  def bubbles?; end
  def children; end
  def children=(children); end
  def css; end
  def css_with_sourcemap; end
  def deep_copy; end
  def each; end
  def filename; end
  def filename=(_arg0); end
  def has_children; end
  def has_children=(_arg0); end
  def inspect; end
  def invisible?; end
  def line; end
  def line=(_arg0); end
  def options; end
  def options=(options); end
  def source_range; end
  def source_range=(_arg0); end
  def style; end
  def to_sass(options = T.unsafe(nil)); end
  def to_scss(options = T.unsafe(nil)); end
  def visit_depth_first(visitor); end

  protected

  def balance(*args); end

  class << self
    def inherited(base); end
  end
end

class Sass::Tree::PropNode < ::Sass::Tree::Node
  def initialize(name, value, prop_syntax); end

  def ==(other); end
  def declaration(opts = T.unsafe(nil), fmt = T.unsafe(nil)); end
  def invisible?; end
  def name; end
  def name=(_arg0); end
  def name_source_range; end
  def name_source_range=(_arg0); end
  def pseudo_class_selector_message; end
  def resolved_name; end
  def resolved_name=(_arg0); end
  def resolved_value; end
  def resolved_value=(_arg0); end
  def tabs; end
  def tabs=(_arg0); end
  def value; end
  def value=(_arg0); end
  def value_source_range; end
  def value_source_range=(_arg0); end

  private

  def check!; end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def val_to_sass(value, opts); end
    def visit_method; end

    private

    def val_to_sass_comma(node, opts); end
    def val_to_sass_concat(node, opts); end
    def val_to_sass_div(node, opts); end
  end
end

class Sass::Tree::ReturnNode < ::Sass::Tree::Node
  def initialize(expr); end

  def expr; end
  def expr=(_arg0); end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::RootNode < ::Sass::Tree::Node
  def initialize(template); end

  def render; end
  def render_with_sourcemap; end
  def template; end

  private

  def css_tree; end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::RuleNode < ::Sass::Tree::Node
  def initialize(rule, selector_source_range = T.unsafe(nil)); end

  def ==(other); end
  def add_rules(node); end
  def continued?; end
  def debug_info; end
  def filename=(filename); end
  def group_end; end
  def group_end=(_arg0); end
  def invisible?; end
  def line=(line); end
  def parsed_rules; end
  def parsed_rules=(_arg0); end
  def resolved_rules; end
  def resolved_rules=(_arg0); end
  def rule; end
  def rule=(_arg0); end
  def selector_source_range; end
  def selector_source_range=(_arg0); end
  def stack_trace; end
  def stack_trace=(_arg0); end
  def tabs; end
  def tabs=(_arg0); end

  private

  def try_to_parse_non_interpolated_rules; end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

Sass::Tree::RuleNode::PARENT = T.let(T.unsafe(nil), String)

class Sass::Tree::SupportsNode < ::Sass::Tree::DirectiveNode
  def initialize(name, condition); end

  def condition; end
  def condition=(_arg0); end
  def invisible?; end
  def name; end
  def name=(_arg0); end
  def resolved_value; end
  def value; end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::TraceNode < ::Sass::Tree::Node
  def initialize(name); end

  def name; end

  class << self
    def from_node(name, node); end
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::VariableNode < ::Sass::Tree::Node
  def initialize(name, expr, guarded, global); end

  def expr; end
  def expr=(_arg0); end
  def global; end
  def guarded; end
  def name; end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

module Sass::Tree::Visitors; end

class Sass::Tree::Visitors::Base
  protected

  def visit(node); end
  def visit_children(parent); end
  def visit_if(node); end

  class << self
    def node_name(node); end
    def visit(root); end
  end
end

class Sass::Tree::Visitors::CheckNesting < ::Sass::Tree::Visitors::Base
  def initialize; end

  protected

  def invalid_charset_parent?(parent, child); end
  def invalid_content_parent?(parent, child); end
  def invalid_extend_parent?(parent, child); end
  def invalid_function_child?(parent, child); end
  def invalid_function_parent?(parent, child); end
  def invalid_import_parent?(parent, child); end
  def invalid_mixindef_parent?(parent, child); end
  def invalid_prop_child?(parent, child); end
  def invalid_prop_parent?(parent, child); end
  def invalid_return_parent?(parent, child); end
  def visit(node); end
  def visit_children(parent); end
  def visit_import(node); end
  def visit_mixindef(node); end
  def visit_root(node); end

  private

  def is_any_of?(val, classes); end
  def transparent_parent?(parent, grandparent); end
  def try_send(method, *args); end
end

Sass::Tree::Visitors::CheckNesting::CONTROL_NODES = T.let(T.unsafe(nil), Array)
Sass::Tree::Visitors::CheckNesting::INVALID_IMPORT_PARENTS = T.let(T.unsafe(nil), Array)
Sass::Tree::Visitors::CheckNesting::SCRIPT_NODES = T.let(T.unsafe(nil), Array)
Sass::Tree::Visitors::CheckNesting::VALID_EXTEND_PARENTS = T.let(T.unsafe(nil), Array)
Sass::Tree::Visitors::CheckNesting::VALID_FUNCTION_CHILDREN = T.let(T.unsafe(nil), Array)
Sass::Tree::Visitors::CheckNesting::VALID_PROP_CHILDREN = T.let(T.unsafe(nil), Array)
Sass::Tree::Visitors::CheckNesting::VALID_PROP_PARENTS = T.let(T.unsafe(nil), Array)

class Sass::Tree::Visitors::Convert < ::Sass::Tree::Visitors::Base
  def initialize(options, format); end

  protected

  def visit_atroot(node); end
  def visit_charset(node); end
  def visit_children(parent); end
  def visit_comment(node); end
  def visit_content(node); end
  def visit_cssimport(node); end
  def visit_debug(node); end
  def visit_directive(node); end
  def visit_each(node); end
  def visit_error(node); end
  def visit_extend(node); end
  def visit_for(node); end
  def visit_function(node); end
  def visit_if(node); end
  def visit_import(node); end
  def visit_keyframerule(node); end
  def visit_media(node); end
  def visit_mixin(node); end
  def visit_mixindef(node); end
  def visit_prop(node); end
  def visit_return(node); end
  def visit_root(node); end
  def visit_rule(node); end
  def visit_supports(node); end
  def visit_variable(node); end
  def visit_warn(node); end
  def visit_while(node); end

  private

  def dasherize(s); end
  def interp_to_src(interp); end
  def query_interp_to_src(interp); end
  def selector_to_sass(sel); end
  def selector_to_scss(sel); end
  def selector_to_src(sel); end
  def semi; end
  def tab_str; end
  def visit_rule_level(nodes); end

  class << self
    def visit(root, options, format); end
  end
end

class Sass::Tree::Visitors::Cssize < ::Sass::Tree::Visitors::Base
  def initialize; end

  protected

  def parent; end
  def visit(node); end
  def visit_atroot(node); end
  def visit_children(parent); end
  def visit_children_without_parent(node); end
  def visit_directive(node); end
  def visit_extend(node); end
  def visit_import(node); end
  def visit_keyframerule(node); end
  def visit_media(node); end
  def visit_prop(node); end
  def visit_root(node); end
  def visit_rule(node); end
  def visit_supports(node); end
  def visit_trace(node); end
  def with_parent(parent); end

  private

  def bubblable?(node); end
  def bubble(node); end
  def debubble(children, parent = T.unsafe(nil)); end

  class << self
    def visit(root); end
  end
end

class Sass::Tree::Visitors::Cssize::Bubble
  def initialize(node); end

  def bubbles?; end
  def group_end; end
  def group_end=(_arg0); end
  def inspect; end
  def node; end
  def node=(_arg0); end
  def tabs; end
  def tabs=(_arg0); end
end

class Sass::Tree::Visitors::Cssize::Extend < ::Struct
  def directives; end
  def directives=(_); end
  def extender; end
  def extender=(_); end
  def node; end
  def node=(_); end
  def result; end
  def result=(_); end
  def target; end
  def target=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Sass::Tree::Visitors::DeepCopy < ::Sass::Tree::Visitors::Base
  protected

  def visit(node); end
  def visit_children(parent); end
  def visit_debug(node); end
  def visit_directive(node); end
  def visit_each(node); end
  def visit_error(node); end
  def visit_extend(node); end
  def visit_for(node); end
  def visit_function(node); end
  def visit_if(node); end
  def visit_media(node); end
  def visit_mixin(node); end
  def visit_mixindef(node); end
  def visit_prop(node); end
  def visit_return(node); end
  def visit_rule(node); end
  def visit_supports(node); end
  def visit_variable(node); end
  def visit_warn(node); end
  def visit_while(node); end
end

class Sass::Tree::Visitors::Extend < ::Sass::Tree::Visitors::Base
  def initialize(extends); end

  protected

  def visit(node); end
  def visit_children(parent); end
  def visit_rule(node); end

  class << self
    def visit(root, extends); end

    private

    def check_extends_fired!(extends); end
  end
end

class Sass::Tree::Visitors::Perform < ::Sass::Tree::Visitors::Base
  def initialize(env); end

  protected

  def visit(node); end
  def visit_atroot(node); end
  def visit_children(parent); end
  def visit_comment(node); end
  def visit_content(node); end
  def visit_cssimport(node); end
  def visit_debug(node); end
  def visit_directive(node); end
  def visit_each(node); end
  def visit_error(node); end
  def visit_extend(node); end
  def visit_for(node); end
  def visit_function(node); end
  def visit_if(node); end
  def visit_import(node); end
  def visit_media(node); end
  def visit_mixin(node); end
  def visit_mixindef(node); end
  def visit_prop(node); end
  def visit_return(node); end
  def visit_root(node); end
  def visit_rule(node); end
  def visit_supports(node); end
  def visit_variable(node); end
  def visit_warn(node); end
  def visit_while(node); end
  def with_environment(env); end

  private

  def handle_import_loop!(node); end
  def run_interp(text); end
  def run_interp_no_strip(text); end

  class << self
    def perform_arguments(callable, args, splat, environment); end
    def perform_splat(splat, performed_keywords, kwarg_splat, environment); end
    def visit(root, environment = T.unsafe(nil)); end

    private

    def arg_hash(map); end
  end
end

class Sass::Tree::Visitors::SetOptions < ::Sass::Tree::Visitors::Base
  def initialize(options); end

  protected

  def visit(node); end
  def visit_comment(node); end
  def visit_cssimport(node); end
  def visit_debug(node); end
  def visit_directive(node); end
  def visit_each(node); end
  def visit_error(node); end
  def visit_extend(node); end
  def visit_for(node); end
  def visit_function(node); end
  def visit_if(node); end
  def visit_import(node); end
  def visit_media(node); end
  def visit_mixin(node); end
  def visit_mixindef(node); end
  def visit_prop(node); end
  def visit_return(node); end
  def visit_rule(node); end
  def visit_supports(node); end
  def visit_variable(node); end
  def visit_warn(node); end
  def visit_while(node); end

  class << self
    def visit(root, options); end
  end
end

class Sass::Tree::Visitors::ToCss < ::Sass::Tree::Visitors::Base
  def initialize(build_source_mapping = T.unsafe(nil)); end

  def source_mapping; end
  def visit(node); end

  protected

  def erase!(chars); end
  def for_node(node, attr_prefix = T.unsafe(nil)); end
  def lstrip; end
  def output(s); end
  def prepend!(prefix); end
  def rstrip!; end
  def trailing_semicolon?; end
  def visit_charset(node); end
  def visit_comment(node); end
  def visit_cssimport(node); end
  def visit_directive(node); end
  def visit_keyframerule(node); end
  def visit_media(node); end
  def visit_prop(node); end
  def visit_root(node); end
  def visit_rule(node); end
  def visit_supports(node); end
  def with_tabs(tabs); end

  private

  def debug_info_rule(debug_info, options); end
end

Sass::Tree::Visitors::ToCss::NEWLINE = T.let(T.unsafe(nil), String)

class Sass::Tree::WarnNode < ::Sass::Tree::Node
  def initialize(expr); end

  def expr; end
  def expr=(_arg0); end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::Tree::WhileNode < ::Sass::Tree::Node
  def initialize(expr); end

  def expr; end
  def expr=(_arg0); end

  class << self
    def invalid_child_method_name; end
    def invalid_parent_method_name; end
    def node_name; end
    def visit_method; end
  end
end

class Sass::UnitConversionError < ::Sass::SyntaxError; end

module Sass::Util
  extend ::Sass::Util

  private

  def absolute_path(path, dir_string = T.unsafe(nil)); end
  def abstract(obj); end
  def ap_geq?(version); end
  def ap_geq_3?; end
  def array_minus(minuend, subtrahend); end
  def atomic_create_and_write_file(filename, perms = T.unsafe(nil)); end
  def av_template_class(name); end
  def caller_info(entry = T.unsafe(nil)); end
  def check_range(name, range, value, unit = T.unsafe(nil)); end
  def check_sass_encoding(str); end
  def cleanpath(path); end
  def deprecated(obj, message = T.unsafe(nil)); end
  def destructure(val); end
  def downcase(string); end
  def encode_vlq(value); end
  def enum_cons(enum, n); end
  def enum_slice(enum, n); end
  def enum_with_index(enum); end
  def escape_uri(string); end
  def extract!(array); end
  def extract_values(arr); end
  def file_uri_from_path(path); end
  def find_encoding_error(str); end
  def flatten_vertically(arrs); end
  def glob(path); end
  def group_by_to_a(enum); end
  def has?(attr, klass, method); end
  def hash_to_a(hash); end
  def inject_values(str, values); end
  def inspect_obj(obj); end
  def intersperse(enum, val); end
  def ironruby?; end
  def jruby1_6?; end
  def jruby?; end
  def jruby_version; end
  def json_escape_string(s); end
  def json_value_of(v); end
  def lcs(x, y, &block); end
  def lcs_backtrace(c, x, y, i, j, &block); end
  def lcs_table(x, y); end
  def listen_geq_2?; end
  def load_listen!; end
  def macruby?; end
  def map_hash(hash); end
  def map_keys(hash); end
  def map_vals(hash); end
  def max(val1, val2); end
  def merge_adjacent_strings(arr); end
  def min(val1, val2); end
  def ord(c); end
  def ordered_hash(*pairs_or_hash); end
  def pathname(path); end
  def paths(arrs); end
  def powerset(arr); end
  def rails_env; end
  def rails_root; end
  def rbx?; end
  def realpath(path); end
  def relative_path_from(path, from); end
  def replace_subseq(arr, subseq, replacement); end
  def restrict(value, range); end
  def retry_on_windows; end
  def round(value); end
  def ruby1?; end
  def ruby1_8?; end
  def ruby1_9_2?; end
  def ruby2_4?; end
  def sass_warn(msg); end
  def scope(file); end
  def silence_sass_warnings; end
  def silence_warnings; end
  def slice_by(enum); end
  def sourcemap_name(css); end
  def strip_string_array(arr); end
  def subsequence?(seq1, seq2); end
  def substitute(ary, from, to); end
  def to_hash(arr); end
  def undefined_conversion_error_char(e); end
  def upcase(string); end
  def version_geq(v1, v2); end
  def version_gt(v1, v2); end
  def windows?; end
  def with_extracted_values(arr); end

  class << self
    def absolute_path(path, dir_string = T.unsafe(nil)); end
    def abstract(obj); end
    def ap_geq?(version); end
    def ap_geq_3?; end
    def array_minus(minuend, subtrahend); end
    def atomic_create_and_write_file(filename, perms = T.unsafe(nil)); end
    def av_template_class(name); end
    def caller_info(entry = T.unsafe(nil)); end
    def check_range(name, range, value, unit = T.unsafe(nil)); end
    def check_sass_encoding(str); end
    def cleanpath(path); end
    def deprecated(obj, message = T.unsafe(nil)); end
    def destructure(val); end
    def downcase(string); end
    def encode_vlq(value); end
    def enum_cons(enum, n); end
    def enum_slice(enum, n); end
    def enum_with_index(enum); end
    def escape_uri(string); end
    def extract!(array); end
    def extract_values(arr); end
    def file_uri_from_path(path); end
    def flatten_vertically(arrs); end
    def glob(path); end
    def group_by_to_a(enum); end
    def has?(attr, klass, method); end
    def hash_to_a(hash); end
    def inject_values(str, values); end
    def inspect_obj(obj); end
    def intersperse(enum, val); end
    def ironruby?; end
    def jruby1_6?; end
    def jruby?; end
    def jruby_version; end
    def json_escape_string(s); end
    def json_value_of(v); end
    def lcs(x, y, &block); end
    def listen_geq_2?; end
    def load_listen!; end
    def macruby?; end
    def map_hash(hash); end
    def map_keys(hash); end
    def map_vals(hash); end
    def max(val1, val2); end
    def merge_adjacent_strings(arr); end
    def min(val1, val2); end
    def ord(c); end
    def ordered_hash(*pairs_or_hash); end
    def pathname(path); end
    def paths(arrs); end
    def powerset(arr); end
    def rails_env; end
    def rails_root; end
    def rbx?; end
    def realpath(path); end
    def relative_path_from(path, from); end
    def replace_subseq(arr, subseq, replacement); end
    def restrict(value, range); end
    def retry_on_windows; end
    def round(value); end
    def ruby1?; end
    def ruby1_8?; end
    def ruby1_9_2?; end
    def ruby2_4?; end
    def sass_warn(msg); end
    def scope(file); end
    def silence_sass_warnings; end
    def silence_warnings; end
    def slice_by(enum); end
    def sourcemap_name(css); end
    def strip_string_array(arr); end
    def subsequence?(seq1, seq2); end
    def substitute(ary, from, to); end
    def to_hash(arr); end
    def undefined_conversion_error_char(e); end
    def upcase(string); end
    def version_geq(v1, v2); end
    def version_gt(v1, v2); end
    def windows?; end
    def with_extracted_values(arr); end
  end
end

Sass::Util::ATOMIC_WRITE_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)
Sass::Util::BASE64_DIGITS = T.let(T.unsafe(nil), Array)
Sass::Util::BASE64_DIGIT_MAP = T.let(T.unsafe(nil), Hash)
Sass::Util::CHARSET_REGEXP = T.let(T.unsafe(nil), Regexp)

class Sass::Util::CrossPlatformRandom
  def initialize(seed = T.unsafe(nil)); end

  def rand(*args); end
end

class Sass::Util::MultibyteStringScanner < ::StringScanner
  def initialize(str); end

  def byte_matched_size; end
  def byte_pos; end
  def check(pattern); end
  def check_until(pattern); end
  def clear; end
  def get_byte; end
  def getbyte; end
  def getch; end
  def match?(pattern); end
  def matched_size; end
  def peek(len); end
  def peep(len); end
  def pointer; end
  def pos; end
  def pos=(n); end
  def reset; end
  def rest_size; end
  def scan(pattern); end
  def scan_full(pattern, advance_pointer_p, return_string_p); end
  def scan_until(pattern); end
  def search_full(pattern, advance_pointer_p, return_string_p); end
  def skip(pattern); end
  def skip_until(pattern); end
  def string=(str); end
  def terminate; end
  def unscan; end

  private

  def _forward(str); end
  def _match(str); end
  def _matched(res); end
  def _size(str); end

  class << self
    def new(str); end
  end
end

class Sass::Util::NormalizedMap
  def initialize(map = T.unsafe(nil)); end

  def [](k); end
  def []=(k, v); end
  def as_stored; end
  def delete(k); end
  def denormalize(key); end
  def dup; end
  def each; end
  def empty?; end
  def has_key?(k); end
  def keys; end
  def map; end
  def method_missing(method, *args, &block); end
  def normalize(key); end
  def size; end
  def sort_by; end
  def to_a; end
  def to_hash; end
  def update(map); end
  def values; end

  private

  def respond_to_missing?(method, include_private = T.unsafe(nil)); end
end

Sass::Util::RUBY_ENGINE = T.let(T.unsafe(nil), String)
Sass::Util::RUBY_VERSION_COMPONENTS = T.let(T.unsafe(nil), Array)

class Sass::Util::StaticConditionalContext
  def initialize(set); end

  def method_missing(name, *args); end
end

class Sass::Util::SubsetMap
  def initialize; end

  def [](set); end
  def []=(set, value); end
  def each_value; end
  def empty?; end
  def get(set); end
end

Sass::Util::URI_ESCAPE = T.let(T.unsafe(nil), URI::RFC2396_Parser)
Sass::Util::UTF_16BE_BOM = T.let(T.unsafe(nil), String)
Sass::Util::UTF_16LE_BOM = T.let(T.unsafe(nil), String)
Sass::Util::UTF_8_BOM = T.let(T.unsafe(nil), String)
Sass::Util::VLQ_BASE = T.let(T.unsafe(nil), Integer)
Sass::Util::VLQ_BASE_MASK = T.let(T.unsafe(nil), Integer)
Sass::Util::VLQ_BASE_SHIFT = T.let(T.unsafe(nil), Integer)
Sass::Util::VLQ_CONTINUATION_BIT = T.let(T.unsafe(nil), Integer)
Sass::VERSION = T.let(T.unsafe(nil), String)

module Sass::Version
  def version; end

  private

  def revision_number; end
  def version_date; end
end
