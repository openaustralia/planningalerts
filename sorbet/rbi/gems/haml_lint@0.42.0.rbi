# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `haml_lint` gem.
# Please instead update this file by running `bin/tapioca gem haml_lint`.

# Global application constants.
#
# source://haml_lint//lib/haml_lint/constants.rb#4
module HamlLint; end

# source://haml_lint//lib/haml_lint/constants.rb#6
HamlLint::APP_NAME = T.let(T.unsafe(nil), String)

# Determines the adapter to use for the current Haml version
#
# source://haml_lint//lib/haml_lint/adapter/haml_4.rb#6
class HamlLint::Adapter
  class << self
    # Detects the adapter to use for the current Haml version
    #
    # @api public
    # @example
    #   HamlLint::Adapter.detect_class.new('%div')
    # @raise [HamlLint::Exceptions::UnknownHamlVersion]
    # @return [Class] the adapter class
    #
    # source://haml_lint//lib/haml_lint/adapter.rb#19
    def detect_class; end

    private

    # Determines the approximate version of Haml that is installed
    #
    # @api private
    # @return [String] the approximate Haml version
    #
    # source://haml_lint//lib/haml_lint/adapter.rb#33
    def haml_version; end
  end
end

# Adapts the Haml::Parser from Haml 4 for use in HamlLint
# :reek:UncommunicativeModuleName
#
# source://haml_lint//lib/haml_lint/adapter/haml_4.rb#9
class HamlLint::Adapter::Haml4 < ::HamlLint::Adapter
  extend ::Forwardable

  # Parses the specified Haml code into an abstract syntax tree
  #
  # @api public
  # @example
  #   HamlLint::Adapter::Haml4.new('%div')
  # @param source [String] Haml code to parse
  # @param options [Haml::Options]
  # @return [Haml4] a new instance of Haml4
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_4.rb#20
  def initialize(source, options = T.unsafe(nil)); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def parse(*args, &block); end

  private

  # The Haml parser to adapt for HamlLint
  #
  # @api private
  # @return [Haml::Parser] the Haml 4 parser
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_4.rb#41
  def parser; end
end

# Adapts the Haml::Parser from Haml 5 for use in HamlLint
# :reek:UncommunicativeModuleName
#
# source://haml_lint//lib/haml_lint/adapter/haml_5.rb#15
class HamlLint::Adapter::Haml5 < ::HamlLint::Adapter
  # Parses the specified Haml code into an abstract syntax tree
  #
  # @api public
  # @example
  #   HamlLint::Adapter::Haml5.new('%div')
  # @param source [String] Haml code to parse
  # @param options [Haml::Options]
  # @return [Haml5] a new instance of Haml5
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_5.rb#16
  def initialize(source, options = T.unsafe(nil)); end

  # Parses the source code into an abstract syntax tree
  #
  # @api public
  # @example
  #   HamlLint::Adapter::Haml5.new('%div').parse
  # @raise [Haml::Error]
  # @return [Haml::Parser::ParseNode]
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_5.rb#29
  def parse; end

  private

  # The Haml parser to adapt for HamlLint
  #
  # @api private
  # @return [Haml::Parser] the Haml 4 parser
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_5.rb#39
  def parser; end

  # The Haml code to parse
  #
  # @api private
  # @return [String] Haml code to parse
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_5.rb#45
  def source; end
end

# Adapts the Haml::Parser from Haml 5 for use in HamlLint
# :reek:UncommunicativeModuleName
#
# source://haml_lint//lib/haml_lint/adapter/haml_6.rb#15
class HamlLint::Adapter::Haml6 < ::HamlLint::Adapter
  # Parses the specified Haml code into an abstract syntax tree
  #
  # @api public
  # @example
  #   HamlLint::Adapter::Haml6.new('%div')
  # @param source [String] Haml code to parse
  # @param options [private Haml::Parser::ParserOptions]
  # @return [Haml6] a new instance of Haml6
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_6.rb#16
  def initialize(source, options = T.unsafe(nil)); end

  # Parses the source code into an abstract syntax tree
  #
  # @api public
  # @example
  #   HamlLint::Adapter::Haml6.new('%div').parse
  # @raise [Haml::Error]
  # @return [Haml::Parser::ParseNode]
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_6.rb#29
  def parse; end

  private

  # The Haml parser to adapt for HamlLint
  #
  # @api private
  # @return [Haml::Parser] the Haml 4 parser
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_6.rb#39
  def parser; end

  # The Haml code to parse
  #
  # @api private
  # @return [String] Haml code to parse
  #
  # source://haml_lint//lib/haml_lint/adapter/haml_6.rb#45
  def source; end
end

# source://haml_lint//lib/haml_lint/constants.rb#9
HamlLint::BUG_REPORT_URL = T.let(T.unsafe(nil), String)

# Determines what linters are enabled or disabled via comments.
#
# source://haml_lint//lib/haml_lint/comment_configuration.rb#5
class HamlLint::CommentConfiguration
  # Instantiates a new {HamlLint::CommentConfiguration}.
  #
  # @param node [HamlLint::Tree::Node] the node to configure
  # @return [CommentConfiguration] a new instance of CommentConfiguration
  #
  # source://haml_lint//lib/haml_lint/comment_configuration.rb#9
  def initialize(node); end

  # Checks whether a linter is disabled for the node.
  #
  # @api public
  # @param linter_name [String] the name of the linter
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/comment_configuration.rb#18
  def disabled?(linter_name); end

  private

  # The list of directives in order of precedence.
  #
  # @api private
  # @return [Array<HamlLint::Directive>]
  #
  # source://haml_lint//lib/haml_lint/comment_configuration.rb#30
  def directives; end

  # Finds all directives applicable to the given linter name.
  #
  # @api private
  # @param linter_name [String] the name of the linter
  # @return [Array<HamlLint::Directive>] the filtered directives
  #
  # source://haml_lint//lib/haml_lint/comment_configuration.rb#37
  def directives_for(linter_name); end
end

# Stores runtime configuration for the application.
#
# The purpose of this class is to validate and ensure all configurations
# satisfy some basic pre-conditions so other parts of the application don't
# have to check the configuration for errors. It should have no knowledge of
# how these configuration values are ultimately used.
#
# source://haml_lint//lib/haml_lint/configuration.rb#10
class HamlLint::Configuration
  # Creates a configuration from the given options hash.
  #
  # @param options [Hash]
  # @return [Configuration] a new instance of Configuration
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#17
  def initialize(options, file = T.unsafe(nil)); end

  # Compares this configuration with another.
  #
  # @param other [HamlLint::Configuration]
  # @return [true, false] whether the given configuration is equivalent
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#36
  def ==(other); end

  # Access the configuration as if it were a hash.
  #
  # @param key [String]
  # @return [Array, Hash, Number, String]
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#28
  def [](key); end

  # Returns a non-modifiable configuration for the specified linter.
  #
  # @param linter [HamlLint::Linter, Class]
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#43
  def for_linter(linter); end

  # Internal hash storing the configuration.
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#12
  def hash; end

  # Merges the given configuration with this one, returning a new
  # {Configuration}. The provided configuration will either add to or replace
  # any options defined in this configuration.
  #
  # @param config [HamlLint::Configuration]
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#60
  def merge(config); end

  private

  # Ensures the `exclude` global option is an array.
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#105
  def ensure_exclude_option_array_exists; end

  # Ensure `include` and `exclude` options for linters are arrays
  # (since users can specify a single string glob pattern for convenience)
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#116
  def ensure_linter_include_exclude_arrays_valid; end

  # Ensures the `linters` configuration section exists.
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#110
  def ensure_linter_section_exists; end

  # source://haml_lint//lib/haml_lint/configuration.rb#125
  def ensure_linter_severity_valid; end

  # Requires any extra linters / files specified in the configuration.
  # String starting with a . are treated as relative paths
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#84
  def resolve_requires; end

  # Merge two hashes such that nested hashes are merged rather than replaced.
  #
  # @param parent [Hash]
  # @param child [Hash]
  # @return [Hash]
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#71
  def smart_merge(parent, child); end

  # Validates the configuration for any invalid options, normalizing it where
  # possible.
  #
  # source://haml_lint//lib/haml_lint/configuration.rb#97
  def validate; end
end

# Manages configuration file loading.
#
# source://haml_lint//lib/haml_lint/configuration_loader.rb#8
class HamlLint::ConfigurationLoader
  class << self
    # Loads the built-in default configuration.
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#38
    def default_configuration; end

    # Path to the default config file, if it exists
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#31
    def default_path_to_config; end

    # Load configuration file given the current working directory the
    # application is running within.
    #
    # @option options
    # @param config_file [String] optional path to the config file to load
    # @param options [Hash]
    # @return [HamlLint::Configuration]
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#21
    def load_applicable_config(config_file = T.unsafe(nil), options = T.unsafe(nil)); end

    # Loads a configuration, ensuring it extends the default configuration.
    #
    # @option context
    # @option context
    # @param file [String]
    # @param context [Hash]
    # @return [HamlLint::Configuration]
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#51
    def load_file(file, context = T.unsafe(nil)); end

    # Creates a configuration from the specified hash, ensuring it extends the
    # default configuration.
    #
    # @param hash [Hash]
    # @return [HamlLint::Configuration]
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#69
    def load_hash(hash); end

    private

    # Parses and loads a configuration from the given file.
    #
    # @param file [String]
    # @return [HamlLint::Configuration]
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#81
    def load_from_file(file); end

    # Returns a list of possible configuration files given the context of the
    # specified directory.
    #
    # @param directory [String]
    # @return [Array<Pathname>]
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#102
    def possible_config_files(directory); end

    # Resolves an inherited file and loads it.
    #
    # @param file [String] the path to the file
    # @param loaded_files [Array<String>] previously loaded files in the
    #   inheritance chain
    # @return [HamlLint::Configuration, nil]
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#115
    def resolve(file, context); end

    # Resolves the chain of `inherits_from` directives in a configuration.
    #
    # @param config [HamlLint::Configuration] the pre-existing configuration
    # @param loaded_files [Array<String>] any previously loaded files in an
    #   inheritance chain
    # @return [HamlLint::Configuration]
    #
    # source://haml_lint//lib/haml_lint/configuration_loader.rb#130
    def resolve_inheritance(config, context); end
  end
end

# source://haml_lint//lib/haml_lint/configuration_loader.rb#9
HamlLint::ConfigurationLoader::AUTO_GENERATED_FILE = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/configuration_loader.rb#11
HamlLint::ConfigurationLoader::CONFIG_FILE_NAME = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/configuration_loader.rb#10
HamlLint::ConfigurationLoader::DEFAULT_CONFIG_PATH = T.let(T.unsafe(nil), String)

# Handles linter configuration transformation via Haml comments.
#
# source://haml_lint//lib/haml_lint/directive.rb#5
class HamlLint::Directive
  # Instantiates a new {HamlLint::Directive}
  #
  # @api semipublic
  # @param source [String] the source code to analyze
  # @param line [Integer] the line number the source starts at
  # @param mode [String] the type of directive, one of "disable" or "enable"
  # @param linters [Array<String>] the name of the linters to act upon
  # @return [Directive] a new instance of Directive
  #
  # source://haml_lint//lib/haml_lint/directive.rb#41
  def initialize(source, line, mode, linters); end

  # Checks whether a directive is equivalent to another.
  #
  # @api public
  # @param other [HamlLint::Directive] the other directive
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#63
  def ==(other); end

  # Checks whether this is a disable directive.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#72
  def disable?; end

  # Checks whether this is an enable directive.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#79
  def enable?; end

  # Formats the directive for display in a console.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#86
  def inspect; end

  # The names of the linters to act upon.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#51
  def linters; end

  # The mode of the directive. One of "disable" or "enable".
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#56
  def mode; end

  class << self
    # Constructs a directive from source code as a given line.
    #
    # @param source [String] the source code to analyze
    # @param line [Integer] the line number the source starts at
    # @return [HamlLint::Directive]
    #
    # source://haml_lint//lib/haml_lint/directive.rb#24
    def from_line(source, line); end
  end
end

# source://haml_lint//lib/haml_lint/directive.rb#8
HamlLint::Directive::DIRECTIVE_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://haml_lint//lib/haml_lint/directive.rb#6
HamlLint::Directive::LINTER_REGEXP = T.let(T.unsafe(nil), Regexp)

# A null representation of a directive.
#
# source://haml_lint//lib/haml_lint/directive.rb#95
class HamlLint::Directive::Null < ::HamlLint::Directive
  # Instantiates a new null directive.
  #
  # @param source [String] the source code to analyze
  # @param line [Integer] the line number the source starts at
  # @return [Null] a new instance of Null
  #
  # source://haml_lint//lib/haml_lint/directive.rb#96
  def initialize(source, line); end

  # Stubs out the disable check as false.
  #
  # @return [false]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#104
  def disable?; end

  # Stubs out the ensable check as false.
  #
  # @return [false]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#111
  def enable?; end

  # Formats the null directive for display in a console.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#118
  def inspect; end

  # Stubs out the linters.
  #
  # @return [Array]
  #
  # source://haml_lint//lib/haml_lint/directive.rb#125
  def linters; end
end

# Represents a parsed Haml document and its associated metadata.
#
# source://haml_lint//lib/haml_lint/document.rb#7
class HamlLint::Document
  # Parses the specified Haml code into a {Document}.
  #
  # @option options
  # @param source [String] Haml code to parse
  # @param options [Hash]
  # @raise [Haml::Parser::Error] if there was a problem parsing the document
  # @return [Document] a new instance of Document
  #
  # source://haml_lint//lib/haml_lint/document.rb#32
  def initialize(source, options); end

  # @return [HamlLint::Configuration] Configuration used to parse template
  #
  # source://haml_lint//lib/haml_lint/document.rb#12
  def config; end

  # @return [String] Haml template file path
  #
  # source://haml_lint//lib/haml_lint/document.rb#15
  def file; end

  # @return [String] original source code
  #
  # source://haml_lint//lib/haml_lint/document.rb#21
  def source; end

  # @return [Array<String>] original source code as an array of lines
  #
  # source://haml_lint//lib/haml_lint/document.rb#24
  def source_lines; end

  # @return [HamlLint::Tree::Node] Root of the parse tree
  #
  # source://haml_lint//lib/haml_lint/document.rb#18
  def tree; end

  private

  # Converts a HAML parse tree to a tree of {HamlLint::Tree::Node} objects.
  #
  # This provides a cleaner interface with which the linters can interact with
  # the parse tree.
  #
  # @param haml_node [Haml::Parser::ParseNode]
  # @param parent [Haml::Tree::Node]
  # @return [Haml::Tree::Node]
  #
  # source://haml_lint//lib/haml_lint/document.rb#78
  def convert_tree(haml_node, parent = T.unsafe(nil)); end

  # Ensures source code is interpreted as UTF-8.
  #
  # This is necessary as sometimes Ruby guesses the encoding of a file
  # incorrectly, for example if the LC_ALL environment variable is set to "C".
  #
  # @param source [String]
  # @return [String] source encoded with UTF-8 encoding
  # @see http://unix.stackexchange.com/a/87763
  #
  # source://haml_lint//lib/haml_lint/document.rb#97
  def process_encoding(source); end

  # @param source [String] Haml code to parse
  # @raise [HamlLint::Exceptions::ParseError] if there was a problem parsing
  #
  # source://haml_lint//lib/haml_lint/document.rb#43
  def process_source(source); end

  # Processes the {Haml::Parser::ParseNode} tree and returns a tree composed
  # of friendlier {HamlLint::Tree::Node}s.
  #
  # @param original_tree [Haml::Parser::ParseNode]
  # @return [Haml::Tree::Node]
  #
  # source://haml_lint//lib/haml_lint/document.rb#59
  def process_tree(original_tree); end

  # Removes YAML frontmatter
  #
  # source://haml_lint//lib/haml_lint/document.rb#102
  def strip_frontmatter(source); end
end

# File name given to source code parsed from just a string.
#
# source://haml_lint//lib/haml_lint/document.rb#9
HamlLint::Document::STRING_SOURCE = T.let(T.unsafe(nil), String)

# Collection of exceptions that can be raised by the HAML Lint application.
#
# source://haml_lint//lib/haml_lint/exceptions.rb#4
module HamlLint::Exceptions; end

# Raised when a {Configuration} could not be loaded from a file.
#
# source://haml_lint//lib/haml_lint/exceptions.rb#6
class HamlLint::Exceptions::ConfigurationError < ::StandardError; end

# Raised when invalid/incompatible command line options are provided.
#
# source://haml_lint//lib/haml_lint/exceptions.rb#9
class HamlLint::Exceptions::InvalidCLIOption < ::StandardError; end

# Raised when an invalid file path is specified
#
# source://haml_lint//lib/haml_lint/exceptions.rb#12
class HamlLint::Exceptions::InvalidFilePath < ::StandardError; end

# Raised when attempting to execute `Runner` with options that would result in
# no linters being enabled.
#
# source://haml_lint//lib/haml_lint/exceptions.rb#19
class HamlLint::Exceptions::NoLintersError < ::StandardError; end

# Raised when a problem occurs parsing a HAML document.
#
# source://haml_lint//lib/haml_lint/exceptions.rb#15
class HamlLint::Exceptions::ParseError < ::Haml::SyntaxError; end

# Raised when an unsupported Haml version is detected
#
# source://haml_lint//lib/haml_lint/exceptions.rb#22
class HamlLint::Exceptions::UnknownHamlVersion < ::StandardError; end

# Raised when a severity is not recognized
#
# source://haml_lint//lib/haml_lint/exceptions.rb#25
class HamlLint::Exceptions::UnknownSeverity < ::StandardError; end

# Finds Haml files that should be linted given a specified list of paths, glob
# patterns, and configuration.
#
# source://haml_lint//lib/haml_lint/file_finder.rb#8
class HamlLint::FileFinder
  # Create a file finder using the specified configuration.
  #
  # @param config [HamlLint::Configuration]
  # @return [FileFinder] a new instance of FileFinder
  #
  # source://haml_lint//lib/haml_lint/file_finder.rb#16
  def initialize(config); end

  # Return list of files to lint given the specified set of paths and glob
  # patterns.
  #
  # @param patterns [Array<String>]
  # @param excluded_patterns [Array<String>]
  # @raise [HamlLint::Exceptions::InvalidFilePath]
  # @return [Array<String>] list of actual files
  #
  # source://haml_lint//lib/haml_lint/file_finder.rb#26
  def find(patterns, excluded_patterns); end

  private

  # Extract the list of matching files given the list of glob patterns, file
  # paths, and directories.
  #
  # @param patterns [Array<String>]
  # @return [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/file_finder.rb#43
  def extract_files_from(patterns); end

  # Whether the given file should be treated as a Haml file.
  #
  # @param file [String]
  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/file_finder.rb#84
  def haml_file?(file); end

  # Trim "./" from the front of relative paths.
  #
  # @param path [String]
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/file_finder.rb#76
  def normalize_path(path); end
end

# List of extensions of files to include under a directory when a directory
# is specified instead of a file.
#
# source://haml_lint//lib/haml_lint/file_finder.rb#11
HamlLint::FileFinder::VALID_EXTENSIONS = T.let(T.unsafe(nil), Array)

# source://haml_lint//lib/haml_lint/constants.rb#5
HamlLint::HOME = T.let(T.unsafe(nil), String)

# Provides an interface which when included allows a class to visit nodes in
# the parse tree of a HAML document.
#
# source://haml_lint//lib/haml_lint/haml_visitor.rb#6
module HamlLint::HamlVisitor
  # source://haml_lint//lib/haml_lint/haml_visitor.rb#7
  def visit(node); end

  # source://haml_lint//lib/haml_lint/haml_visitor.rb#31
  def visit_children(parent); end

  private

  # source://haml_lint//lib/haml_lint/haml_visitor.rb#37
  def node_name(node); end

  # source://haml_lint//lib/haml_lint/haml_visitor.rb#41
  def safe_send(name, *args, &block); end
end

# Contains information about a problem or issue with a HAML document.
#
# source://haml_lint//lib/haml_lint/lint.rb#5
class HamlLint::Lint
  # Creates a new lint.
  #
  # @param linter [HamlLint::Linter]
  # @param filename [String]
  # @param line [Fixnum]
  # @param message [String]
  # @param severity [Symbol]
  # @return [Lint] a new instance of Lint
  #
  # source://haml_lint//lib/haml_lint/lint.rb#28
  def initialize(linter, filename, line, message, severity = T.unsafe(nil)); end

  # Return whether this lint has a severity of error.
  #
  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/lint.rb#39
  def error?; end

  # @return [String] file path to which the lint applies
  #
  # source://haml_lint//lib/haml_lint/lint.rb#7
  def filename; end

  # @return [String] line number of the file the lint corresponds to
  #
  # source://haml_lint//lib/haml_lint/lint.rb#10
  def line; end

  # @return [SlimLint::Linter] linter that reported the lint
  #
  # source://haml_lint//lib/haml_lint/lint.rb#13
  def linter; end

  # @return [String] error/warning message to display to user
  #
  # source://haml_lint//lib/haml_lint/lint.rb#16
  def message; end

  # @return [Symbol] whether this lint is a warning or an error
  #
  # source://haml_lint//lib/haml_lint/lint.rb#19
  def severity; end
end

# Base implementation for all lint checks.
#
# @abstract
#
# source://haml_lint//lib/haml_lint/linter.rb#7
class HamlLint::Linter
  include ::HamlLint::HamlVisitor

  # Initializes a linter with the specified configuration.
  #
  # @param config [Hash] configuration for this linter
  # @return [Linter] a new instance of Linter
  #
  # source://haml_lint//lib/haml_lint/linter.rb#19
  def initialize(config); end

  # List of lints reported by this linter.
  #
  # @todo Remove once spec/support/shared_linter_context returns an array of
  #   lints for the subject instead of the linter itself.
  #
  # source://haml_lint//lib/haml_lint/linter.rb#14
  def lints; end

  # Returns the simple name for this linter.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#47
  def name; end

  # Runs the linter against the given Haml document.
  #
  # @param document [HamlLint::Document]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#27
  def run(document); end

  private

  # Returns the value of attribute config.
  #
  # source://haml_lint//lib/haml_lint/linter.rb#53
  def config; end

  # Returns whether a string contains any interpolation.
  #
  # @param string [String]
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#85
  def contains_interpolation?(string); end

  # Returns the value of attribute document.
  #
  # source://haml_lint//lib/haml_lint/linter.rb#53
  def document; end

  # Returns the line of the "following node" (child of this node or sibling or
  # the last line in the file).
  #
  # @param node [HamlLint::Tree::Node]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#167
  def following_node_line(node); end

  # Returns whether the inline content for a node is a string.
  #
  # For example, the following node has a literal string:
  #
  #   %tag= "A literal #{string}"
  #
  # whereas this one does not:
  #
  #   %tag A literal #{string}
  #
  # @param node [HamlLint::Tree::Node]
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#118
  def inline_content_is_string?(node); end

  # Get the inline content for this node.
  #
  # Inline content is the content that appears inline right after the
  # tag/script. For example, in the code below...
  #
  #   %tag Some inline content
  #
  # ..."Some inline content" would be the inline content.
  #
  # @param node [HamlLint::Tree::Node]
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#138
  def inline_node_content(node); end

  # Gets the next node following this node, ascending up the ancestor chain
  # recursively if this node has no siblings.
  #
  # @param node [HamlLint::Tree::Node]
  # @return [HamlLint::Tree::Node, nil]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#153
  def next_node(node); end

  # Parse Ruby code into an abstract syntax tree.
  #
  # @return [AST::Node]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#67
  def parse_ruby(source); end

  # Record a lint for reporting back to the user.
  #
  # @param node [#line] node to extract the line number from
  # @param message [String] error/warning to display to the user
  #
  # source://haml_lint//lib/haml_lint/linter.rb#59
  def record_lint(node, message); end

  # Remove the surrounding double quotes from a string, ignoring any
  # leading/trailing whitespace.
  #
  # @param string [String]
  # @return [String] stripped with leading/trailing double quotes removed.
  #
  # source://haml_lint//lib/haml_lint/linter.rb#77
  def strip_surrounding_quotes(string); end

  # Returns whether this tag node has inline script, e.g. is of the form
  # %tag= ...
  #
  # @param tag_node [HamlLint::Tree::TagNode]
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/linter.rb#95
  def tag_has_inline_script?(tag_node); end

  # Extracts all text for a tag node and normalizes it, including additional
  # lines following commas or multiline bar indicators ('|')
  #
  # @param tag_node [HamlLine::Tree::TagNode]
  # @return [String] source code of original parse node
  #
  # source://haml_lint//lib/haml_lint/linter.rb#179
  def tag_with_inline_text(tag_node); end
end

# source://haml_lint//lib/haml_lint/linter/alignment_tabs.rb#5
class HamlLint::Linter::AlignmentTabs < ::HamlLint::Linter
  # source://haml_lint//lib/haml_lint/linter/alignment_tabs.rb#8
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/alignment_tabs.rb#6
HamlLint::Linter::AlignmentTabs::REGEX = T.let(T.unsafe(nil), Regexp)

# source://haml_lint//lib/haml_lint/linter/alt_text.rb#5
class HamlLint::Linter::AltText < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/alt_text.rb#8
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/class_attribute_with_static_value.rb#18
class HamlLint::Linter::ClassAttributeWithStaticValue < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/class_attribute_with_static_value.rb#25
  def visit_tag(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/class_attribute_with_static_value.rb#38
  def contains_class_attribute?(attributes_sources); end

  # source://haml_lint//lib/haml_lint/linter/class_attribute_with_static_value.rb#51
  def static_class_attribute_value?(pair); end

  # source://haml_lint//lib/haml_lint/linter/class_attribute_with_static_value.rb#34
  def surrounded_by_braces?(code); end
end

# source://haml_lint//lib/haml_lint/linter/class_attribute_with_static_value.rb#21
HamlLint::Linter::ClassAttributeWithStaticValue::STATIC_TYPES = T.let(T.unsafe(nil), Array)

# source://haml_lint//lib/haml_lint/linter/class_attribute_with_static_value.rb#23
HamlLint::Linter::ClassAttributeWithStaticValue::VALID_CLASS_REGEX = T.let(T.unsafe(nil), Regexp)

# source://haml_lint//lib/haml_lint/linter/classes_before_ids.rb#5
class HamlLint::Linter::ClassesBeforeIds < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/classes_before_ids.rb#16
  def visit_tag(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/classes_before_ids.rb#34
  def attribute_prefix_order; end

  # source://haml_lint//lib/haml_lint/linter/classes_before_ids.rb#40
  def attribute_type_order; end

  # source://haml_lint//lib/haml_lint/linter/classes_before_ids.rb#46
  def enforced_style; end

  # source://haml_lint//lib/haml_lint/linter/classes_before_ids.rb#50
  def ids_first?; end
end

# source://haml_lint//lib/haml_lint/linter/classes_before_ids.rb#14
HamlLint::Linter::ClassesBeforeIds::MSG = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/linter/classes_before_ids.rb#9
HamlLint::Linter::ClassesBeforeIds::TYPES_BY_PREFIX = T.let(T.unsafe(nil), Hash)

# source://haml_lint//lib/haml_lint/linter/consecutive_comments.rb#5
class HamlLint::Linter::ConsecutiveComments < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/consecutive_comments.rb#10
  def visit_haml_comment(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/consecutive_comments.rb#26
  def possible_group(node); end

  # source://haml_lint//lib/haml_lint/linter/consecutive_comments.rb#30
  def previously_reported?(node); end

  # source://haml_lint//lib/haml_lint/linter/consecutive_comments.rb#34
  def reported_nodes; end
end

# source://haml_lint//lib/haml_lint/linter/consecutive_comments.rb#8
HamlLint::Linter::ConsecutiveComments::COMMENT_DETECTOR = T.let(T.unsafe(nil), Proc)

# source://haml_lint//lib/haml_lint/linter/consecutive_silent_scripts.rb#6
class HamlLint::Linter::ConsecutiveSilentScripts < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/consecutive_silent_scripts.rb#13
  def visit_silent_script(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/consecutive_silent_scripts.rb#29
  def possible_group(node); end

  # source://haml_lint//lib/haml_lint/linter/consecutive_silent_scripts.rb#33
  def previously_reported?(node); end

  # source://haml_lint//lib/haml_lint/linter/consecutive_silent_scripts.rb#37
  def reported_nodes; end
end

# source://haml_lint//lib/haml_lint/linter/consecutive_silent_scripts.rb#9
HamlLint::Linter::ConsecutiveSilentScripts::SILENT_SCRIPT_DETECTOR = T.let(T.unsafe(nil), Proc)

# source://haml_lint//lib/haml_lint/linter/empty_object_reference.rb#5
class HamlLint::Linter::EmptyObjectReference < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/empty_object_reference.rb#8
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/empty_script.rb#5
class HamlLint::Linter::EmptyScript < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/empty_script.rb#8
  def visit_silent_script(node); end
end

# source://haml_lint//lib/haml_lint/linter/final_newline.rb#5
class HamlLint::Linter::FinalNewline < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/final_newline.rb#8
  def visit_root(root); end
end

# source://haml_lint//lib/haml_lint/linter/html_attributes.rb#6
class HamlLint::Linter::HtmlAttributes < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/html_attributes.rb#9
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/id_names.rb#5
class HamlLint::Linter::IdNames < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/id_names.rb#22
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/id_names.rb#15
HamlLint::Linter::IdNames::STYLES = T.let(T.unsafe(nil), Hash)

# source://haml_lint//lib/haml_lint/linter/id_names.rb#8
HamlLint::Linter::IdNames::STYLIZED_NAMES = T.let(T.unsafe(nil), Hash)

# source://haml_lint//lib/haml_lint/linter/implicit_div.rb#6
class HamlLint::Linter::ImplicitDiv < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/implicit_div.rb#9
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/indentation.rb#5
class HamlLint::Linter::Indentation < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/indentation.rb#16
  def visit_root(root); end

  private

  # source://haml_lint//lib/haml_lint/linter/indentation.rb#27
  def check_character(character, root); end

  # source://haml_lint//lib/haml_lint/linter/indentation.rb#42
  def check_width(width, root); end
end

# source://haml_lint//lib/haml_lint/linter/indentation.rb#9
HamlLint::Linter::Indentation::INDENT_REGEX = T.let(T.unsafe(nil), Hash)

# source://haml_lint//lib/haml_lint/linter/indentation.rb#14
HamlLint::Linter::Indentation::LEADING_SPACES_REGEX = T.let(T.unsafe(nil), Regexp)

# source://haml_lint//lib/haml_lint/linter/inline_styles.rb#5
class HamlLint::Linter::InlineStyles < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/inline_styles.rb#10
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/inline_styles.rb#8
HamlLint::Linter::InlineStyles::MESSAGE = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/linter/instance_variables.rb#5
class HamlLint::Linter::InstanceVariables < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/instance_variables.rb#12
  def visit_root(node); end

  # source://haml_lint//lib/haml_lint/linter/instance_variables.rb#20
  def visit_script(node); end

  # source://haml_lint//lib/haml_lint/linter/instance_variables.rb#20
  def visit_silent_script(node); end

  # source://haml_lint//lib/haml_lint/linter/instance_variables.rb#39
  def visit_tag(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/instance_variables.rb#54
  def enabled; end

  # source://haml_lint//lib/haml_lint/linter/instance_variables.rb#54
  def enabled?; end

  # source://haml_lint//lib/haml_lint/linter/instance_variables.rb#67
  def file_types; end

  # source://haml_lint//lib/haml_lint/linter/instance_variables.rb#75
  def matcher; end
end

# source://haml_lint//lib/haml_lint/linter/leading_comment_space.rb#5
class HamlLint::Linter::LeadingCommentSpace < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/leading_comment_space.rb#8
  def visit_haml_comment(node); end
end

# source://haml_lint//lib/haml_lint/linter/line_length.rb#5
class HamlLint::Linter::LineLength < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/line_length.rb#15
  def visit_root(root); end
end

# source://haml_lint//lib/haml_lint/linter/line_length.rb#11
class HamlLint::Linter::LineLength::DummyNode < ::Struct
  def line; end

  # source://haml_lint//lib/haml_lint/linter/line_length.rb#11
  def line=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# source://haml_lint//lib/haml_lint/linter/line_length.rb#13
HamlLint::Linter::LineLength::MSG = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/linter/multiline_pipe.rb#5
class HamlLint::Linter::MultilinePipe < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/multiline_pipe.rb#23
  def visit_plain(node); end

  # source://haml_lint//lib/haml_lint/linter/multiline_pipe.rb#15
  def visit_script(node); end

  # source://haml_lint//lib/haml_lint/linter/multiline_pipe.rb#19
  def visit_silent_script(node); end

  # source://haml_lint//lib/haml_lint/linter/multiline_pipe.rb#11
  def visit_tag(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/multiline_pipe.rb#40
  def check(node); end

  # source://haml_lint//lib/haml_lint/linter/multiline_pipe.rb#36
  def line_text_for_node(node); end
end

# source://haml_lint//lib/haml_lint/linter/multiline_pipe.rb#8
HamlLint::Linter::MultilinePipe::MESSAGE = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/linter/multiline_pipe.rb#34
HamlLint::Linter::MultilinePipe::MULTILINE_PIPE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://haml_lint//lib/haml_lint/linter/multiline_script.rb#5
class HamlLint::Linter::MultilineScript < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/multiline_script.rb#26
  def visit_script(node); end

  # source://haml_lint//lib/haml_lint/linter/multiline_script.rb#30
  def visit_silent_script(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/multiline_script.rb#36
  def check(node); end
end

# source://haml_lint//lib/haml_lint/linter/multiline_script.rb#10
HamlLint::Linter::MultilineScript::SPLIT_OPERATORS = T.let(T.unsafe(nil), Set)

# source://haml_lint//lib/haml_lint/linter/object_reference_attributes.rb#6
class HamlLint::Linter::ObjectReferenceAttributes < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/object_reference_attributes.rb#9
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/repeated_id.rb#5
class HamlLint::Linter::RepeatedId < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/repeated_id.rb#10
  def visit_root(_node); end

  # source://haml_lint//lib/haml_lint/linter/repeated_id.rb#14
  def visit_tag(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/repeated_id.rb#30
  def add_lint(node, id); end

  # source://haml_lint//lib/haml_lint/linter/repeated_id.rb#34
  def add_lints_for_first_duplications(nodes); end

  # source://haml_lint//lib/haml_lint/linter/repeated_id.rb#28
  def id_map; end
end

# source://haml_lint//lib/haml_lint/linter/repeated_id.rb#8
HamlLint::Linter::RepeatedId::MESSAGE_FORMAT = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/linter/rubocop.rb#8
class HamlLint::Linter::RuboCop < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#21
  def visit_root(_node); end

  private

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#79
  def extract_lints_from_offenses(offenses, source_map); end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#46
  def find_lints(ruby, source_map); end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#64
  def lint_file(rubocop, file); end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#94
  def record_lint(node, message, severity); end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#102
  def rubocop_flags; end

  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#115
  def with_ruby_from_stdin(ruby, &_block); end

  class << self
    # source://haml_lint//lib/haml_lint/linter/rubocop.rb#32
    def rubocop_cli; end
  end
end

# source://haml_lint//lib/haml_lint/linter/rubocop.rb#12
HamlLint::Linter::RuboCop::SEVERITY_MAP = T.let(T.unsafe(nil), Hash)

# source://haml_lint//lib/haml_lint/linter/ruby_comments.rb#5
class HamlLint::Linter::RubyComments < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/ruby_comments.rb#8
  def visit_silent_script(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/ruby_comments.rb#16
  def code_comment?(node); end
end

# source://haml_lint//lib/haml_lint/linter/space_before_script.rb#5
class HamlLint::Linter::SpaceBeforeScript < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/space_before_script.rb#41
  def visit_script(node); end

  # source://haml_lint//lib/haml_lint/linter/space_before_script.rb#48
  def visit_silent_script(node); end

  # source://haml_lint//lib/haml_lint/linter/space_before_script.rb#12
  def visit_tag(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/space_before_script.rb#54
  def missing_space?(node); end
end

# source://haml_lint//lib/haml_lint/linter/space_before_script.rb#10
HamlLint::Linter::SpaceBeforeScript::ALLOWED_SEPARATORS = T.let(T.unsafe(nil), Array)

# source://haml_lint//lib/haml_lint/linter/space_before_script.rb#8
HamlLint::Linter::SpaceBeforeScript::MESSAGE_FORMAT = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/linter/space_inside_hash_attributes.rb#6
class HamlLint::Linter::SpaceInsideHashAttributes < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/space_inside_hash_attributes.rb#24
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/space_inside_hash_attributes.rb#9
HamlLint::Linter::SpaceInsideHashAttributes::STYLE = T.let(T.unsafe(nil), Hash)

# source://haml_lint//lib/haml_lint/linter/syntax.rb#5
class HamlLint::Linter::Syntax < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry
end

# source://haml_lint//lib/haml_lint/linter/tag_name.rb#5
class HamlLint::Linter::TagName < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/tag_name.rb#8
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/trailing_whitespace.rb#5
class HamlLint::Linter::TrailingWhitespace < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/trailing_whitespace.rb#10
  def visit_root(root); end
end

# source://haml_lint//lib/haml_lint/linter/trailing_whitespace.rb#8
class HamlLint::Linter::TrailingWhitespace::DummyNode < ::Struct
  def line; end

  # source://haml_lint//lib/haml_lint/linter/trailing_whitespace.rb#8
  def line=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# source://haml_lint//lib/haml_lint/linter/unnecessary_interpolation.rb#11
class HamlLint::Linter::UnnecessaryInterpolation < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/unnecessary_interpolation.rb#14
  def visit_tag(node); end
end

# source://haml_lint//lib/haml_lint/linter/unnecessary_string_output.rb#11
class HamlLint::Linter::UnnecessaryStringOutput < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/unnecessary_string_output.rb#22
  def visit_script(node); end

  # source://haml_lint//lib/haml_lint/linter/unnecessary_string_output.rb#16
  def visit_tag(node); end

  private

  # source://haml_lint//lib/haml_lint/linter/unnecessary_string_output.rb#34
  def outputs_string_literal?(script_node); end

  # source://haml_lint//lib/haml_lint/linter/unnecessary_string_output.rb#44
  def starts_with_reserved_character?(stringish); end
end

# source://haml_lint//lib/haml_lint/linter/unnecessary_string_output.rb#14
HamlLint::Linter::UnnecessaryStringOutput::MESSAGE = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/linter/view_length.rb#5
class HamlLint::Linter::ViewLength < ::HamlLint::Linter
  include ::HamlLint::LinterRegistry

  # source://haml_lint//lib/haml_lint/linter/view_length.rb#12
  def visit_root(root); end
end

# source://haml_lint//lib/haml_lint/linter/view_length.rb#10
class HamlLint::Linter::ViewLength::DummyNode < ::Struct
  def line; end

  # source://haml_lint//lib/haml_lint/linter/view_length.rb#10
  def line=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# source://haml_lint//lib/haml_lint/linter/view_length.rb#8
HamlLint::Linter::ViewLength::MSG = T.let(T.unsafe(nil), String)

# Stores all defined linters.
#
# source://haml_lint//lib/haml_lint/linter_registry.rb#7
module HamlLint::LinterRegistry
  class << self
    # Return a list of {HamlLint::Linter} {Class}es corresponding to the
    # specified list of names.
    #
    # @param linter_names [Array<String>]
    # @return [Array<Class>]
    #
    # source://haml_lint//lib/haml_lint/linter_registry.rb#28
    def extract_linters_from(linter_names); end

    # Executed when a linter includes the {LinterRegistry} module.
    #
    # This results in the linter being registered with the registry.
    #
    # @param subclass [Class]
    #
    # source://haml_lint//lib/haml_lint/linter_registry.rb#19
    def included(subclass); end

    # List of all registered linters.
    #
    # source://haml_lint//lib/haml_lint/linter_registry.rb#12
    def linters; end
  end
end

# Chooses the appropriate linters to run given the specified configuration.
#
# source://haml_lint//lib/haml_lint/linter_selector.rb#5
class HamlLint::LinterSelector
  # Creates a selector using the given configuration and additional options.
  #
  # @param config [HamlLint::Configuration]
  # @param options [Hash]
  # @return [LinterSelector] a new instance of LinterSelector
  #
  # source://haml_lint//lib/haml_lint/linter_selector.rb#10
  def initialize(config, options); end

  # Returns the set of linters to run against the given file.
  #
  # @param file [String]
  # @raise [HamlLint::Exceptions::NoLintersError] when no linters are enabled
  # @return [Array<HamlLint::Linter>]
  #
  # source://haml_lint//lib/haml_lint/linter_selector.rb#20
  def linters_for_file(file); end

  private

  # Returns a list of linters that are enabled given the specified
  # configuration and additional options.
  #
  # @param config [HamlLint::Configuration]
  # @param options [Hash]
  # @return [Array<HamlLint::Linter>]
  #
  # source://haml_lint//lib/haml_lint/linter_selector.rb#33
  def extract_enabled_linters(config, options); end

  # Whether to run the given linter against the specified file.
  #
  # @param config [HamlLint::Configuration]
  # @param linter [HamlLint::Linter]
  # @param file [String]
  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/linter_selector.rb#64
  def run_linter_on_file?(config, linter, file); end
end

# Encapsulates all communication to an output source.
#
# source://haml_lint//lib/haml_lint/logger.rb#5
class HamlLint::Logger
  # Creates a new {HamlLint::Logger} instance.
  #
  # @param out [IO] the output destination.
  # @param summary [true, false] whether to print summaries
  # @return [Logger] a new instance of Logger
  #
  # source://haml_lint//lib/haml_lint/logger.rb#24
  def initialize(out, summary: T.unsafe(nil)); end

  # Print the specified output in bold face.
  # If output destination is not a TTY, behaves the same as {#log}.
  #
  # @param args [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#42
  def bold(*args); end

  # Print the specified output in a bold face and color indicative of error.
  # If output destination is not a TTY, behaves the same as {#log}.
  #
  # @param args [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#58
  def bold_error(*args); end

  # Whether colored output via ANSI escape sequences is enabled.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#8
  def color_enabled; end

  # Whether colored output via ANSI escape sequences is enabled.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#8
  def color_enabled=(_arg0); end

  # Print the specified output in a color indicative of error.
  # If output destination is not a TTY, behaves the same as {#log}.
  #
  # @param args [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#50
  def error(*args); end

  # Print the specified output in a color indicating information.
  # If output destination is not a TTY, behaves the same as {#log}.
  #
  # @param args [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#82
  def info(*args); end

  # Print the specified output.
  #
  # @param output [String] the output to send
  # @param newline [true, false] whether to append a newline
  #
  # source://haml_lint//lib/haml_lint/logger.rb#33
  def log(output, newline = T.unsafe(nil)); end

  # Print a blank line.
  #
  # source://haml_lint//lib/haml_lint/logger.rb#87
  def newline; end

  # Print the specified output in a color indicative of success.
  # If output destination is not a TTY, behaves the same as {#log}.
  #
  # @param args [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#66
  def success(*args); end

  # Whether to output a summary in the log for certain reporters.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#12
  def summary_enabled; end

  # Whether to output a summary in the log for certain reporters.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#12
  def summary_enabled=(_arg0); end

  # Whether this logger is outputting to a TTY.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#94
  def tty?; end

  # Print the specified output in a color indicative of a warning.
  # If output destination is not a TTY, behaves the same as {#log}.
  #
  # @param args [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/logger.rb#74
  def warning(*args); end

  private

  # source://haml_lint//lib/haml_lint/logger.rb#100
  def color(code, output, newline = T.unsafe(nil)); end

  class << self
    # Creates a logger which outputs nothing.
    #
    # @return [HamlLint::Logger]
    #
    # source://haml_lint//lib/haml_lint/logger.rb#16
    def silent; end
  end
end

# source://haml_lint//lib/haml_lint/linter_registry.rb#4
class HamlLint::NoSuchLinter < ::StandardError; end

# Responsible for transforming {Haml::Parser::ParseNode} objects into
# corresponding {HamlLint::Tree::Node} objects.
#
# The parse tree generated by HAML has a number of strange cases where certain
# types of nodes are created that don't necessarily correspond to what one
# would expect. This class is intended to isolate and handle these cases so
# that linters don't have to deal with them.
#
# source://haml_lint//lib/haml_lint/node_transformer.rb#11
class HamlLint::NodeTransformer
  # Creates a node transformer for the given Haml document.
  #
  # @param document [HamlLint::Document]
  # @return [NodeTransformer] a new instance of NodeTransformer
  #
  # source://haml_lint//lib/haml_lint/node_transformer.rb#15
  def initialize(document); end

  # Converts the given HAML parse node into its corresponding HAML-Lint parse
  # node.
  #
  # @param haml_node [Haml::Parser::ParseNode]
  # @return [HamlLint::Tree::Node]
  #
  # source://haml_lint//lib/haml_lint/node_transformer.rb#24
  def transform(haml_node); end
end

# Collects offenses detected by RuboCop.
#
# source://haml_lint//lib/haml_lint/linter/rubocop.rb#128
class HamlLint::OffenseCollector < ::RuboCop::Formatter::BaseFormatter
  # Executed when a file has been scanned by RuboCop, adding the reported
  # offenses to our collection.
  #
  # @param _file [String]
  # @param offenses [Array<RuboCop::Cop::Offense>]
  #
  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#146
  def file_finished(_file, offenses); end

  # Executed when RuboCop begins linting.
  #
  # @param _target_files [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/linter/rubocop.rb#137
  def started(_target_files); end

  class << self
    # List of offenses reported by RuboCop.
    #
    # source://haml_lint//lib/haml_lint/linter/rubocop.rb#131
    def offenses; end

    # List of offenses reported by RuboCop.
    #
    # source://haml_lint//lib/haml_lint/linter/rubocop.rb#131
    def offenses=(_arg0); end
  end
end

# A thin wrapper around the syntax tree from the Parser gem.
#
# source://haml_lint//lib/haml_lint/parsed_ruby.rb#12
class HamlLint::ParsedRuby < ::SimpleDelegator
  # Checks whether the syntax tree contains any instance variables.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/parsed_ruby.rb#18
  def contains_instance_variables?; end

  # !@method syntax_tree
  #   Returns the bare syntax tree from the wrapper.
  #
  #   @api semipublic
  #   @return [Array] syntax tree in the form returned by Parser gem
  #
  # source://delegate/0.1.0/delegate.rb#312
  def syntax_tree; end
end

# source://haml_lint//lib/haml_lint/constants.rb#8
HamlLint::REPO_URL = T.let(T.unsafe(nil), String)

# Contains information about all lints detected during a scan.
#
# source://haml_lint//lib/haml_lint/report.rb#5
class HamlLint::Report
  # Creates a report.
  #
  # @param lints [Array<HamlLint::Lint>] lints that were found
  # @param files [Array<String>] files that were linted
  # @param fail_level [Symbol] the severity level to fail on
  # @param reporter [HamlLint::Reporter] the reporter for the report
  # @return [Report] a new instance of Report
  #
  # source://haml_lint//lib/haml_lint/report.rb#21
  def initialize(lints: T.unsafe(nil), files: T.unsafe(nil), fail_level: T.unsafe(nil), reporter: T.unsafe(nil)); end

  # Adds a lint to the report and notifies the reporter.
  #
  # @param lint [HamlLint::Lint] lint to add
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/report.rb#32
  def add_lint(lint); end

  # Displays the report via the configured reporter.
  #
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/report.rb#40
  def display; end

  # The level of lint to fail after detecting
  #
  # source://haml_lint//lib/haml_lint/report.rb#10
  def fail_level; end

  # Checks whether any lints were at or above the fail level
  #
  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/report.rb#47
  def failed?; end

  # List of files that were linted.
  #
  # source://haml_lint//lib/haml_lint/report.rb#13
  def files; end

  # Adds a file to the list of linted files and notifies the reporter.
  #
  # @param file [String] the name of the file that was finished
  # @param lints [Array<HamlLint::Lint>] the lints for the finished file
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/report.rb#56
  def finish_file(file, lints); end

  # List of lints that were found.
  #
  # source://haml_lint//lib/haml_lint/report.rb#7
  def lints; end

  # List of lints that were found.
  #
  # source://haml_lint//lib/haml_lint/report.rb#7
  def lints=(_arg0); end

  # Notifies the reporter that the report has started.
  #
  # @param files [Array<String>] the files to lint
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/report.rb#65
  def start(files); end
end

# Abstract lint reporter. Subclass and override {#display_report} to
# implement a custom lint reporter.
#
# @abstract
#
# source://haml_lint//lib/haml_lint/reporter/hooks.rb#4
class HamlLint::Reporter
  include ::HamlLint::Reporter::Hooks

  # Creates the reporter that will display the given report.
  #
  # @param logger [HamlLint::Logger]
  # @return [Reporter] a new instance of Reporter
  #
  # source://haml_lint//lib/haml_lint/reporter.rb#47
  def initialize(logger); end

  # Implemented by subclasses to display lints from a {HamlLint::Report}.
  #
  # @param report [HamlLint::Report]
  # @raise [NotImplementedError]
  #
  # source://haml_lint//lib/haml_lint/reporter.rb#54
  def display_report(report); end

  private

  # @return [HamlLint::Logger] logger to send output to
  #
  # source://haml_lint//lib/haml_lint/reporter.rb#77
  def log; end

  class << self
    # The CLI names of all configured reporters.
    #
    # @return [Array<String>]
    #
    # source://haml_lint//lib/haml_lint/reporter.rb#16
    def available; end

    # A flag for whether to show the reporter on the command line.
    #
    # @return [Boolean]
    #
    # source://haml_lint//lib/haml_lint/reporter.rb#27
    def available?; end

    # The name of the reporter as passed from the CLI.
    #
    # @return [String]
    #
    # source://haml_lint//lib/haml_lint/reporter.rb#34
    def cli_name; end

    # Keep tracking all the descendants of this class for the list of available
    # reporters.
    #
    # @return [Array<Class>]
    #
    # source://haml_lint//lib/haml_lint/reporter.rb#63
    def descendants; end

    # Executed when this class is subclassed.
    #
    # @param descendant [Class]
    #
    # source://haml_lint//lib/haml_lint/reporter.rb#70
    def inherited(descendant); end
  end
end

# Outputs report as an XML checkstyle document.
#
# source://haml_lint//lib/haml_lint/reporter/checkstyle_reporter.rb#5
class HamlLint::Reporter::CheckstyleReporter < ::HamlLint::Reporter
  # source://haml_lint//lib/haml_lint/reporter/checkstyle_reporter.rb#6
  def display_report(report); end

  private

  # source://haml_lint//lib/haml_lint/reporter/checkstyle_reporter.rb#26
  def render_offenses(offenses); end
end

# source://haml_lint//lib/haml_lint/reporter/default_reporter.rb#8
class HamlLint::Reporter::DefaultReporter < ::HamlLint::Reporter
  include ::HamlLint::Reporter::Utils

  # source://haml_lint//lib/haml_lint/reporter/default_reporter.rb#11
  def added_lint(lint, report); end

  # source://haml_lint//lib/haml_lint/reporter/default_reporter.rb#15
  def display_report(report); end
end

# source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#7
class HamlLint::Reporter::DisabledConfigReporter < ::HamlLint::Reporter::ProgressReporter
  # source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#28
  def initialize(log, limit: T.unsafe(nil)); end

  # source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#56
  def display_report(report); end

  # source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#50
  def exclude_limit; end

  # source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#71
  def finished_file(file, lints); end

  # source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#39
  def linters_lint_count; end

  # source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#45
  def linters_with_lints; end

  private

  # source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#87
  def config_file_contents; end

  # source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#102
  def generate_config_for_linter(linter, files); end

  class << self
    # source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#21
    def available?; end
  end
end

# source://haml_lint//lib/haml_lint/reporter/disabled_config_reporter.rb#8
HamlLint::Reporter::DisabledConfigReporter::HEADING = T.let(T.unsafe(nil), String)

# source://haml_lint//lib/haml_lint/reporter/hash_reporter.rb#8
class HamlLint::Reporter::HashReporter < ::HamlLint::Reporter
  # source://haml_lint//lib/haml_lint/reporter/hash_reporter.rb#13
  def display_report(report); end

  private

  # source://haml_lint//lib/haml_lint/reporter/hash_reporter.rb#41
  def map_file(file); end

  # source://haml_lint//lib/haml_lint/reporter/hash_reporter.rb#48
  def map_offense(offense); end

  # source://haml_lint//lib/haml_lint/reporter/hash_reporter.rb#32
  def metadata; end

  class << self
    # source://haml_lint//lib/haml_lint/reporter/hash_reporter.rb#9
    def available?; end
  end
end

# A collection of hook methods for incremental processing.
#
# source://haml_lint//lib/haml_lint/reporter/hooks.rb#6
module HamlLint::Reporter::Hooks
  # A hook that is called for each lint as it is detected.
  #
  # @param _lint [HamlLint::Lint] the lint added to the report
  # @param _report [HamlLint::Report] the report that contains the lint
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/hooks.rb#12
  def added_lint(_lint, _report); end

  # A hook that is called for each file as it is finished processing.
  #
  # @param _file [String] the name of the file that just finished
  # @param _lints [Array<HamlLint::Lint>] the lints added to the report
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/hooks.rb#19
  def finished_file(_file, _lints); end

  # A hook that is called when the processing starts.
  #
  # @param _files [Array<String>] the names of the files to be processed
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/hooks.rb#25
  def start(_files); end
end

# source://haml_lint//lib/haml_lint/reporter/json_reporter.rb#10
class HamlLint::Reporter::JsonReporter < ::HamlLint::Reporter::HashReporter
  # source://haml_lint//lib/haml_lint/reporter/json_reporter.rb#15
  def display_report(report); end

  class << self
    # source://haml_lint//lib/haml_lint/reporter/json_reporter.rb#11
    def available?; end
  end
end

# source://haml_lint//lib/haml_lint/reporter/offense_count_reporter.rb#6
class HamlLint::Reporter::OffenseCountReporter < ::HamlLint::Reporter
  # source://haml_lint//lib/haml_lint/reporter/offense_count_reporter.rb#7
  def display_report(report); end

  private

  # source://haml_lint//lib/haml_lint/reporter/offense_count_reporter.rb#25
  def lint_type_group(lint); end

  # source://haml_lint//lib/haml_lint/reporter/offense_count_reporter.rb#29
  def offense_type(lint); end
end

# source://haml_lint//lib/haml_lint/reporter/progress_reporter.rb#9
class HamlLint::Reporter::ProgressReporter < ::HamlLint::Reporter
  include ::HamlLint::Reporter::Utils

  # source://haml_lint//lib/haml_lint/reporter/progress_reporter.rb#14
  def display_report(report); end

  # source://haml_lint//lib/haml_lint/reporter/progress_reporter.rb#23
  def finished_file(_file, lints); end

  # source://haml_lint//lib/haml_lint/reporter/progress_reporter.rb#27
  def start(files); end

  private

  # source://haml_lint//lib/haml_lint/reporter/progress_reporter.rb#33
  def dot; end

  # source://haml_lint//lib/haml_lint/reporter/progress_reporter.rb#37
  def report_file_as_mark(lints); end
end

# source://haml_lint//lib/haml_lint/reporter/progress_reporter.rb#12
HamlLint::Reporter::ProgressReporter::DOT = T.let(T.unsafe(nil), String)

# Formatting helpers for printing the default report format.
#
# source://haml_lint//lib/haml_lint/reporter/utils.rb#6
module HamlLint::Reporter::Utils
  # Pluralizes a word based on a count.
  #
  # @param word [String] the word to pluralize
  # @param count [Integer] the count of items
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/reporter/utils.rb#12
  def pluralize(word, count: T.unsafe(nil)); end

  # Prints the lint with its location and severity.
  #
  # @param lint [HamlLint::Lint] the lint to print
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/utils.rb#24
  def print_lint(lint); end

  # Prints the location of a lint.
  #
  # @param lint [HamlLint::Lint] the lint to print
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/utils.rb#34
  def print_location(lint); end

  # Prints the description of a lint.
  #
  # @param lint [HamlLint::Lint] the lint to print
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/utils.rb#58
  def print_message(lint); end

  # Prints a summary of a report when summaries are enabled.
  #
  # @param report [HamlLint::Report] the report to print
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/utils.rb#70
  def print_summary(report); end

  # Prints a summary of the number of files linted in a report.
  #
  # @param report [HamlLint::Report] the report to print
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/utils.rb#83
  def print_summary_files(report); end

  # Prints a summary of the number of lints found in a report.
  #
  # @param report [HamlLint::Report] the report to print
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/utils.rb#91
  def print_summary_lints(report); end

  # Prints the severity of a lint.
  #
  # @param lint [HamlLint::Lint] the lint to print
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/reporter/utils.rb#44
  def print_type(lint); end
end

# Utility class for extracting Ruby script from a HAML file that can then be
# linted with a Ruby linter (i.e. is "legal" Ruby). The goal is to turn this:
#
#     - if signed_in?(viewer)
#       %span Stuff
#       = link_to 'Sign Out', sign_out_path
#     - else
#       .some-class{ class: my_method }= my_method
#       = link_to 'Sign In', sign_in_path
#
# into this:
#
#     if signed_in?(viewer)
#       link_to 'Sign Out', sign_out_path
#     else
#       { class: my_method }
#       my_method
#       link_to 'Sign In', sign_in_path
#     end
#
# The translation won't be perfect, and won't make any real sense, but the
# relationship between variable declarations/uses and the flow control graph
# will remain intact.
#
# source://haml_lint//lib/haml_lint/ruby_extractor.rb#27
class HamlLint::RubyExtractor
  include ::HamlLint::HamlVisitor

  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#90
  def after_visit_tag(node); end

  # Extracts Ruby code from Sexp representing a Slim document.
  #
  # @param document [HamlLint::Document]
  # @return [HamlLint::RubyExtractor::RubySource]
  #
  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#42
  def extract(document); end

  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#128
  def visit_filter(node); end

  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#114
  def visit_haml_comment(node); end

  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#57
  def visit_plain(node); end

  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#47
  def visit_root(_node); end

  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#95
  def visit_script(node); end

  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#124
  def visit_silent_script(node, &block); end

  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#64
  def visit_tag(node); end

  private

  # Adds a dummy method call with a unique name so we don't get
  # Style/IdenticalConditionalBranches RuboCop warnings
  #
  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#158
  def add_dummy_puts(node, annotation = T.unsafe(nil)); end

  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#164
  def add_line(code, node_or_line, discard_blanks = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#198
  def anonymous_block?(text); end

  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#213
  def block_keyword(text); end

  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#143
  def check_tag_static_hash_source(node); end

  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#193
  def indent_code(code, indent); end

  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#208
  def mid_block_keyword?(text); end

  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#203
  def start_block_keyword?(text); end
end

# source://haml_lint//lib/haml_lint/ruby_extractor.rb#212
HamlLint::RubyExtractor::LOOP_KEYWORDS = T.let(T.unsafe(nil), Array)

# source://haml_lint//lib/haml_lint/ruby_extractor.rb#207
HamlLint::RubyExtractor::MID_BLOCK_KEYWORDS = T.let(T.unsafe(nil), Array)

# Stores the extracted source and a map of lines of generated source to the
# original source that created them.
#
# @attr_reader source [String] generated source code
# @attr_reader source_map [Hash] map of line numbers from generated source
#   to original source line number
#
# source://haml_lint//lib/haml_lint/ruby_extractor.rb#36
class HamlLint::RubyExtractor::RubySource < ::Struct
  # generated source code
  #
  # @return [String] the current value of source
  def source; end

  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#36
  def source=(_); end

  # map of line numbers from generated source
  # to original source line number
  #
  # @return [Hash] the current value of source_map
  def source_map; end

  # source://haml_lint//lib/haml_lint/ruby_extractor.rb#36
  def source_map=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# source://haml_lint//lib/haml_lint/ruby_extractor.rb#202
HamlLint::RubyExtractor::START_BLOCK_KEYWORDS = T.let(T.unsafe(nil), Array)

# Parser for the Ruby language.
#
# This provides a convenient wrapper around the `parser` gem and the
# Astrolabe integration (now built-in to RuboCop, so no longer called
# Astrolabe) to go with it. It is intended to be used for linter
# checks that require deep inspection of Ruby code.
#
# source://haml_lint//lib/haml_lint/ruby_parser.rb#14
class HamlLint::RubyParser
  # Creates a reusable parser.
  #
  # @return [RubyParser] a new instance of RubyParser
  #
  # source://haml_lint//lib/haml_lint/ruby_parser.rb#16
  def initialize; end

  # Parse the given Ruby source into an abstract syntax tree.
  #
  # @param source [String] Ruby source code
  # @return [Array] syntax tree in the form returned by Parser gem
  #
  # source://haml_lint//lib/haml_lint/ruby_parser.rb#25
  def parse(source); end
end

# Responsible for running the applicable linters against the desired files.
#
# source://haml_lint//lib/haml_lint/runner.rb#7
class HamlLint::Runner
  # Runs the appropriate linters against the desired files given the specified
  # options.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash]
  # @return [HamlLint::Report] a summary of all lints found
  #
  # source://haml_lint//lib/haml_lint/runner.rb#21
  def run(options = T.unsafe(nil)); end

  private

  # Runs all provided linters using the specified config against the given
  # file.
  #
  # @param file [String] path to file to lint
  # @param linter_selector [HamlLint::LinterSelector]
  # @param config [HamlLint::Configuration]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#83
  def collect_lints(file, linter_selector, config); end

  # The {HamlLint::Configuration} that should be used for this run.
  #
  # @return [HamlLint::Configuration]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#36
  def config; end

  # Returns the list of files that should be linted given the specified
  # configuration and options.
  #
  # @param config [HamlLint::Configuration]
  # @param options [Hash]
  # @return [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#102
  def extract_applicable_files(config, options); end

  # A flag for whether to fail after the first failure.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#41
  def fail_fast; end

  # A flag for whether to fail after the first failure.
  # !@method fail_fast?
  #   Checks whether to fail after the first failure.
  #
  #   @return [true, false]
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#41
  def fail_fast?; end

  # The list of files to lint during this run.
  #
  # @return [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#52
  def files; end

  # The selector for which linters to run during this run.
  #
  # @return [HamlLint::LinterSelector]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#57
  def linter_selector; end

  # Returns the {HamlLint::Configuration} that should be used given the
  # specified options.
  #
  # @param options [Hash]
  # @return [HamlLint::Configuration]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#64
  def load_applicable_config(options); end

  # Process a file and add it to the given report.
  #
  # @param file [String] the name of the file to process
  # @param report [HamlLint::Report]
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#126
  def process_file(file, report); end

  # Process the files and add them to the given report.
  #
  # @param report [HamlLint::Report]
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#114
  def process_files(report); end

  # Generates a report based on the given options.
  #
  # @option options
  # @param options [Hash]
  # @return [HamlLint::Report]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#137
  def report(options); end

  # Cache the result of processing lints in parallel.
  #
  # @return [void]
  #
  # source://haml_lint//lib/haml_lint/runner.rb#148
  def warm_cache; end
end

# Models the severity of a lint
#
# source://haml_lint//lib/haml_lint/severity.rb#7
class HamlLint::Severity < ::SimpleDelegator
  include ::Comparable

  # Creates a new severity for a lint
  #
  # @api public
  # @example
  #   HamlLint::Severity.new(:warning)
  # @param name [Symbol] the name of the severity level
  # @return [Severity] a new instance of Severity
  #
  # source://haml_lint//lib/haml_lint/severity.rb#24
  def initialize(name); end

  # Compares the severity to another severity or a symbol
  #
  # @return [Integer]
  #
  # source://haml_lint//lib/haml_lint/severity.rb#92
  def <=>(other); end

  # The color of the mark in reporters.
  #
  # @return [Symbol]
  #
  # source://haml_lint//lib/haml_lint/severity.rb#34
  def color; end

  # Checks whether the severity is an error
  #
  # @api public
  # @example
  #   HamlLint::Severity.new(:error).error? #=> true
  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/severity.rb#45
  def error?; end

  # The level of severity for the lint
  #
  # @api public
  # @return [Integer]
  #
  # source://haml_lint//lib/haml_lint/severity.rb#53
  def level; end

  # The symbol to use in a {HamlLint::Reporter::ProgressReporter}.
  #
  # source://haml_lint//lib/haml_lint/severity.rb#60
  def mark; end

  # The colorized symbol to use in a reporter.
  #
  # source://haml_lint//lib/haml_lint/severity.rb#67
  def mark_with_color; end

  # The name of the severity.
  #
  # source://haml_lint//lib/haml_lint/severity.rb#74
  def name; end

  # Checks whether the severity is a warning
  #
  # @api public
  # @example
  #   HamlLint::Severity.new(:warning).warning? #=> true
  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/severity.rb#85
  def warning?; end
end

# source://haml_lint//lib/haml_lint/severity.rb#13
HamlLint::Severity::COLORS = T.let(T.unsafe(nil), Hash)

# source://haml_lint//lib/haml_lint/severity.rb#14
HamlLint::Severity::MARKS = T.let(T.unsafe(nil), Hash)

# source://haml_lint//lib/haml_lint/severity.rb#15
HamlLint::Severity::NAMES = T.let(T.unsafe(nil), Array)

# source://haml_lint//lib/haml_lint/severity.rb#10
HamlLint::Severity::SEVERITY_ERROR = T.let(T.unsafe(nil), Symbol)

# source://haml_lint//lib/haml_lint/severity.rb#11
HamlLint::Severity::SEVERITY_WARNING = T.let(T.unsafe(nil), Symbol)

# source://haml_lint//lib/haml_lint/tree/node.rb#5
module HamlLint::Tree; end

# Represents a visible XHTML comment in a HAML document.
#
# source://haml_lint//lib/haml_lint/tree/comment_node.rb#5
class HamlLint::Tree::CommentNode < ::HamlLint::Tree::Node; end

# Represents a doctype definition for a HAML document.
#
# source://haml_lint//lib/haml_lint/tree/doctype_node.rb#5
class HamlLint::Tree::DoctypeNode < ::HamlLint::Tree::Node; end

# Represents a filter node which contains arbitrary code.
#
# source://haml_lint//lib/haml_lint/tree/filter_node.rb#6
class HamlLint::Tree::FilterNode < ::HamlLint::Tree::Node
  # The type of code contained in this filter.
  #
  # source://haml_lint//lib/haml_lint/tree/filter_node.rb#7
  def filter_type; end
end

# Represents a HAML comment node.
#
# source://haml_lint//lib/haml_lint/tree/haml_comment_node.rb#7
class HamlLint::Tree::HamlCommentNode < ::HamlLint::Tree::Node
  # source://haml_lint//lib/haml_lint/tree/haml_comment_node.rb#8
  def directives; end

  # Returns the full text content of this comment, including newlines if a
  # single comment spans multiple lines.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/tree/haml_comment_node.rb#18
  def text; end

  private

  # source://haml_lint//lib/haml_lint/tree/haml_comment_node.rb#30
  def contained_directives; end
end

# Decorator class that provides a convenient set of helpers for HAML's
# {Haml::Parser::ParseNode} struct.
#
# The goal is to abstract away the details of the underlying struct and
# provide a cleaner and more uniform interface for getting information about a
# node, as there are a number of weird/special cases in the struct returned by
# the HAML parser.
#
# @abstract
#
# source://haml_lint//lib/haml_lint/tree/node.rb#15
class HamlLint::Tree::Node
  include ::Enumerable

  # Creates a node wrapping the given {Haml::Parser::ParseNode} struct.
  #
  # @param document [HamlLint::Document] Haml document that created this node
  # @param parse_node [Haml::Parser::ParseNode] parse node created by HAML's parser
  # @return [Node] a new instance of Node
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#25
  def initialize(document, parse_node); end

  # Returns the value of attribute children.
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#18
  def children; end

  # Sets the attribute children
  #
  # @param value the value to set the attribute children to.
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#18
  def children=(_arg0); end

  # Holds any configuration that is created from Haml comments.
  #
  # @return [HamlLint::CommentConfiguration]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#35
  def comment_configuration; end

  # The comment directives to apply to the node.
  #
  # @return [Array<HamlLint::Directive>]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#64
  def directives; end

  # Checks whether a visitor is disabled due to comment configuration.
  #
  # @param [HamlLint::HamlVisitor]
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#43
  def disabled?(visitor); end

  # Implements the Enumerable interface to walk through an entire tree.
  #
  # @return [Enumerator, HamlLint::Tree::Node]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#51
  def each; end

  # source://haml_lint//lib/haml_lint/tree/node.rb#86
  def inspect; end

  # Returns the value of attribute line.
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#19
  def line; end

  # The line numbers that are contained within the node.
  #
  # @api public
  # @return [Range]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#104
  def line_numbers; end

  # The lines of text, if any, that are contained in the node.
  #
  # @api public
  # @return [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#94
  def lines; end

  # Returns the next node that appears after this node in the document.
  #
  # Returns nil if there is no next node.
  #
  # @return [HamlLint::Tree::Node, nil]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#140
  def next_node; end

  # Returns the value of attribute parent.
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#18
  def parent; end

  # Sets the attribute parent
  #
  # @param value the value to set the attribute parent to.
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#18
  def parent=(_arg0); end

  # The previous node to be traversed in the tree.
  #
  # @return [HamlLint::Tree::Node, nil]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#116
  def predecessor; end

  # Source code of all lines this node spans (excluding children).
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#73
  def source_code; end

  # The sibling nodes that come after this node in the tree.
  #
  # @return [Array<HamlLint::Tree::Node>]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#147
  def subsequents; end

  # Returns the node that follows this node, whether it be a sibling or an
  # ancestor's child, but not a child of this node.
  #
  # If you are also willing to return the child, call {#next_node}.
  #
  # Returns nil if there is no successor.
  #
  # @return [HamlLint::Tree::Node, nil]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#128
  def successor; end

  # Returns the text content of this node.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#154
  def text; end

  # Returns the value of attribute type.
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#19
  def type; end

  private

  # Discovers the end line of the node when there are no lines.
  #
  # @return [Integer] the end line of the node
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#163
  def nontrivial_end_line; end

  # The siblings of this node within the tree.
  #
  # @api private
  # @return [Array<HamlLint::Tree::Node>]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#175
  def siblings; end
end

# Finds the node's siblings within the tree and makes them queryable.
#
# source://haml_lint//lib/haml_lint/tree/node.rb#184
class HamlLint::Tree::Node::Siblings < ::SimpleDelegator
  # Finds the next sibling in the tree for a given node.
  #
  # @param node [HamlLint::Tree::Node]
  # @return [HamlLint::Tree::Node, nil]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#185
  def next(node); end

  # Finds the previous sibling in the tree for a given node.
  #
  # @param node [HamlLint::Tree::Node]
  # @return [HamlLint::Tree::Node, nil]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#193
  def previous(node); end

  # Finds all sibling notes that appear before a node in the tree.
  #
  # @param node [HamlLint::Tree::Node]
  # @return [Array<HamlLint::Tree::Node>]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#201
  def priors(node); end

  # The set of siblings within the tree.
  #
  # @api private
  # @return [Array<HamlLint::Tree::Node>]
  #
  # source://delegate/0.1.0/delegate.rb#312
  def siblings; end

  # Finds all sibling notes that appear after a node in the tree.
  #
  # @param node [HamlLint::Tree::Node]
  # @return [Array<HamlLint::Tree::Node>]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#214
  def subsequents(node); end

  private

  # Finds the position of a node within a set of siblings.
  #
  # @api private
  # @return [Integer, nil]
  #
  # source://haml_lint//lib/haml_lint/tree/node.rb#230
  def position(node); end
end

# A null object version of a node that can be used as a safe default.
#
# source://haml_lint//lib/haml_lint/tree/null_node.rb#6
class HamlLint::Tree::NullNode < ::HamlLint::Tree::Node
  # Instantiates a new {HamlLint::Tree::NullNode}, ignoring all input.
  #
  # @return [NullNode] a new instance of NullNode
  #
  # source://haml_lint//lib/haml_lint/tree/null_node.rb#7
  def initialize(*_args); end

  # Overrides the disabled check to always say the linter is enabled.
  #
  # @param _linter [HamlLint::Linter] the linter to check
  # @return [false]
  #
  # source://haml_lint//lib/haml_lint/tree/null_node.rb#13
  def disabled?(_linter); end
end

# Represents a node that contains plain text.
#
# source://haml_lint//lib/haml_lint/tree/plain_node.rb#5
class HamlLint::Tree::PlainNode < ::HamlLint::Tree::Node; end

# Represents the root node of a HAML document that contains all other nodes.
#
# source://haml_lint//lib/haml_lint/tree/root_node.rb#10
class HamlLint::Tree::RootNode < ::HamlLint::Tree::Node
  # The name fo the file parsed to build this tree.
  #
  # @return [String] a file name
  #
  # source://haml_lint//lib/haml_lint/tree/root_node.rb#11
  def file; end

  # Gets the node of the syntax tree for a given line number.
  #
  # @param line [Integer] the line number of the node
  # @return [HamlLint::Node]
  #
  # source://haml_lint//lib/haml_lint/tree/root_node.rb#19
  def node_for_line(line); end
end

# Represents a node which produces output based on Ruby code.
#
# source://haml_lint//lib/haml_lint/tree/script_node.rb#10
class HamlLint::Tree::ScriptNode < ::HamlLint::Tree::Node
  # The Ruby script contents parsed into a syntax tree.
  #
  # @return [ParsedRuby] syntax tree in the form returned by Parser gem
  #
  # source://haml_lint//lib/haml_lint/tree/script_node.rb#11
  def parsed_script; end

  # Returns the source for the script following the `-` marker.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/tree/script_node.rb#24
  def script; end
end

# Represents a HAML silent script node (`- some_expression`) which executes
# code without producing output.
#
# source://haml_lint//lib/haml_lint/tree/silent_script_node.rb#9
class HamlLint::Tree::SilentScriptNode < ::HamlLint::Tree::Node
  # The Ruby script contents parsed into a syntax tree.
  #
  # @return [ParsedRuby] syntax tree in the form returned by Parser gem
  #
  # source://haml_lint//lib/haml_lint/tree/silent_script_node.rb#10
  def parsed_script; end

  # Returns the source for the script following the `-` marker.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/tree/silent_script_node.rb#32
  def script; end
end

# Represents a tag node in a HAML document.
#
# source://haml_lint//lib/haml_lint/tree/tag_node.rb#18
class HamlLint::Tree::TagNode < ::HamlLint::Tree::Node
  # Returns the source code for the static and dynamic attributes
  # of a tag.
  #
  # @example For `%tag.class{ id: 'hello' }(lang=en)`, this returns:
  #   { :static => '.class', :hash => " id: 'hello' ", :html => "lang=en" }
  # @return [Hash]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#100
  def attributes_source; end

  # Returns whether this tag contains executable script (e.g. is followed by a
  # `=`).
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#32
  def contains_script?; end

  # Returns the source code for the dynamic attributes defined in `{...}`,
  # `(...)`, or `[...]` after a tag name.
  #
  # @example For `%tag.class{ id: 'hello' }(lang=en)`, this returns:
  #   { :hash => " id: 'hello' ", :html => "lang=en" }
  # @return [Hash]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#88
  def dynamic_attributes_source; end

  # Computed set of attribute hashes code.
  #
  # This is a combination of all dynamically calculated attributes from the
  # different attribute setting syntaxes (`{...}`/`(...)`), converted into
  # Ruby code.
  #
  # calling `DynamicAttributes#to_literal`, they mutate the "old" parameter using
  # `String#sub!` instead of returning a new string. This means that any subsequent
  # calls can return a nil instead of a string for that attribute, which causes
  # any subsequent calls to the method to raise an error.
  #
  # @note This has to be memoized because of a design decision in Haml 5. When
  # @return [Array<String>]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#19
  def dynamic_attributes_sources; end

  # Returns whether this tag has a specified attribute.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#39
  def has_hash_attribute?(attribute); end

  # Whether this tag node has a set of hash attributes defined via the
  # curly brace syntax (e.g. `%tag{ lang: 'en' }`).
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#131
  def hash_attributes?; end

  # Attributes defined after the tag name in Ruby hash brackets (`{}`).
  #
  # @example For `%tag.class{ lang: 'en' }`, this returns:
  #   " lang: 'en' "
  # @return [String] source without the surrounding curly braces
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#141
  def hash_attributes_source; end

  # Whether this tag node has a set of HTML attributes defined via the
  # parentheses syntax (e.g. `%tag(lang=en)`).
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#149
  def html_attributes?; end

  # Attributes defined after the tag name in parentheses (`()`).
  #
  # @example For `%tag.class(lang=en)`, this returns:
  #   "lang=en"
  # @return [String, nil] source without the surrounding parentheses, or `nil`
  #   if it has not been defined
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#160
  def html_attributes_source; end

  # Whether this tag node has a set of square brackets (e.g. `%tag[...]`)
  # following it that indicates its class and ID will be to the value of the
  # given object's {#to_key} or {#id} method (in that order).
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#183
  def object_reference?; end

  # Source code for the contents of the node's object reference.
  #
  # @return [String, nil] string source of object reference or `nil` if it has
  #   not been defined
  # @see http://haml.info/docs/yardoc/file.REFERENCE.html#object_reference_
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#192
  def object_reference_source; end

  # The attributes given to the tag parsed into a Ruby syntax tree.
  #
  # @return [ParsedRuby] syntax tree in the form returned by Parser gem
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#199
  def parsed_attributes; end

  # The Ruby script contents of a tag parsed into a syntax tree.
  #
  # @return [ParsedRuby] syntax tree in the form returned by Parser gem
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#206
  def parsed_script; end

  # Whether this node had a `<` after it signifying that outer whitespace
  # should be removed.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#214
  def remove_inner_whitespace?; end

  # Whether this node had a `>` after it signifying that outer whitespace
  # should be removed.
  #
  # @return [true, false]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#222
  def remove_outer_whitespace?; end

  # Returns the script source that will be evaluated to produce this tag's
  # inner content, if any.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#230
  def script; end

  # Static element attributes defined after the tag name.
  #
  # @example For `%tag.button#start-button`, this returns:
  #   '.button#start-button'
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#77
  def static_attributes_source; end

  # List of classes statically defined for this tag.
  #
  # @example For `%tag.button.button-info{ class: status }`, this returns:
  #   ['button', 'button-info']
  # @return [Array<String>] list of statically defined classes with leading
  #   dot removed
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#50
  def static_classes; end

  # List of ids statically defined for this tag.
  #
  # @example For `%tag.button#start-button{ id: special_id }`, this returns:
  #   ['start-button']
  # @return [Array<String>] list of statically defined ids with leading `#`
  #   removed
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#64
  def static_ids; end

  # ID of the HTML tag.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#167
  def tag_id; end

  # Name of the HTML tag.
  #
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#174
  def tag_name; end

  private

  # source://haml_lint//lib/haml_lint/tree/tag_node.rb#236
  def existing_attributes; end
end

# A miscellaneous set of utility functions.
#
# source://haml_lint//lib/haml_lint/utils.rb#7
module HamlLint::Utils
  private

  # Returns whether a glob pattern (or any of a list of patterns) matches the
  # specified file.
  #
  # This is defined here so our file globbing options are consistent
  # everywhere we perform globbing.
  #
  # @param glob [String, Array]
  # @param file [String]
  # @return [Boolean]
  #
  # source://haml_lint//lib/haml_lint/utils.rb#19
  def any_glob_matches?(globs_or_glob, file); end

  # Converts a string containing underscores/hyphens/spaces into CamelCase.
  #
  # @param str [String]
  # @return [String]
  #
  # source://haml_lint//lib/haml_lint/utils.rb#92
  def camel_case(str); end

  # Count the number of consecutive items satisfying the given {Proc}.
  #
  # @param items [Array]
  # @param offset [Fixnum] index to start searching from
  # @return [Integer]
  # @yield [item] Passes item to the provided block.
  # @yieldparam item [Object] Item to evaluate as matching criteria for
  #   inclusion
  # @yieldreturn [Boolean] whether to include the item
  #
  # source://haml_lint//lib/haml_lint/utils.rb#133
  def count_consecutive(items, offset = T.unsafe(nil)); end

  # Yields interpolated values within a block of text.
  #
  # @param text [String]
  # @yield Passes interpolated code and line number that code appears on in
  #   the text.
  # @yieldparam interpolated_code [String] code that was interpolated
  # @yieldparam line [Integer] line number code appears on in text
  #
  # source://haml_lint//lib/haml_lint/utils.rb#55
  def extract_interpolated_values(text); end

  # Returns indexes of all occurrences of a substring within a string.
  #
  # Note, this will not return overlaping substrings, so searching for "aa"
  # in "aaa" will only find one substring, not two.
  #
  # @param text [String] the text to search
  # @param substr [String] the substring to search for
  # @return [Array<Integer>] list of indexes where the substring occurs
  #
  # source://haml_lint//lib/haml_lint/utils.rb#81
  def extract_substring_positions(text, substr); end

  # Find all consecutive items satisfying the given block of a minimum size,
  # yielding each group of consecutive items to the provided block.
  #
  # @param items [Array]
  # @param satisfies [Proc] function that takes an item and returns true/false
  # @param min_consecutive [Fixnum] minimum number of consecutive items before
  #   yielding the group
  # @yield Passes list of consecutive items all matching the criteria defined
  #   by the `satisfies` {Proc} to the provided block
  # @yieldparam group [Array] List of consecutive items
  # @yieldreturn [Boolean] block should return whether item matches criteria
  #   for inclusion
  #
  # source://haml_lint//lib/haml_lint/utils.rb#108
  def for_consecutive_items(items, satisfies, min_consecutive = T.unsafe(nil)); end

  # Returns an array of two items, the first being the absolute path, the second
  # the relative path.
  #
  # The relative path is relative to the current working dir. The path passed can
  # be either relative or absolute.
  #
  # @param path [String] Path to get absolute and relative path of
  # @return [Array<String>] Absolute and relative path
  #
  # source://haml_lint//lib/haml_lint/utils.rb#37
  def get_abs_and_rel_path(path); end

  # Calls a block of code with a modified set of environment variables,
  # restoring them once the code has executed.
  #
  # @param env [Hash] environment variables to set
  #
  # source://haml_lint//lib/haml_lint/utils.rb#143
  def with_environment(env); end

  class << self
    # Returns whether a glob pattern (or any of a list of patterns) matches the
    # specified file.
    #
    # This is defined here so our file globbing options are consistent
    # everywhere we perform globbing.
    #
    # @param glob [String, Array]
    # @param file [String]
    # @return [Boolean]
    #
    # source://haml_lint//lib/haml_lint/utils.rb#19
    def any_glob_matches?(globs_or_glob, file); end

    # Converts a string containing underscores/hyphens/spaces into CamelCase.
    #
    # @param str [String]
    # @return [String]
    #
    # source://haml_lint//lib/haml_lint/utils.rb#92
    def camel_case(str); end

    # Count the number of consecutive items satisfying the given {Proc}.
    #
    # @param items [Array]
    # @param offset [Fixnum] index to start searching from
    # @return [Integer]
    # @yield [item] Passes item to the provided block.
    # @yieldparam item [Object] Item to evaluate as matching criteria for
    #   inclusion
    # @yieldreturn [Boolean] whether to include the item
    #
    # source://haml_lint//lib/haml_lint/utils.rb#133
    def count_consecutive(items, offset = T.unsafe(nil)); end

    # Yields interpolated values within a block of text.
    #
    # @param text [String]
    # @yield Passes interpolated code and line number that code appears on in
    #   the text.
    # @yieldparam interpolated_code [String] code that was interpolated
    # @yieldparam line [Integer] line number code appears on in text
    #
    # source://haml_lint//lib/haml_lint/utils.rb#55
    def extract_interpolated_values(text); end

    # Returns indexes of all occurrences of a substring within a string.
    #
    # Note, this will not return overlaping substrings, so searching for "aa"
    # in "aaa" will only find one substring, not two.
    #
    # @param text [String] the text to search
    # @param substr [String] the substring to search for
    # @return [Array<Integer>] list of indexes where the substring occurs
    #
    # source://haml_lint//lib/haml_lint/utils.rb#81
    def extract_substring_positions(text, substr); end

    # Find all consecutive items satisfying the given block of a minimum size,
    # yielding each group of consecutive items to the provided block.
    #
    # @param items [Array]
    # @param satisfies [Proc] function that takes an item and returns true/false
    # @param min_consecutive [Fixnum] minimum number of consecutive items before
    #   yielding the group
    # @yield Passes list of consecutive items all matching the criteria defined
    #   by the `satisfies` {Proc} to the provided block
    # @yieldparam group [Array] List of consecutive items
    # @yieldreturn [Boolean] block should return whether item matches criteria
    #   for inclusion
    #
    # source://haml_lint//lib/haml_lint/utils.rb#108
    def for_consecutive_items(items, satisfies, min_consecutive = T.unsafe(nil)); end

    # Returns an array of two items, the first being the absolute path, the second
    # the relative path.
    #
    # The relative path is relative to the current working dir. The path passed can
    # be either relative or absolute.
    #
    # @param path [String] Path to get absolute and relative path of
    # @return [Array<String>] Absolute and relative path
    #
    # source://haml_lint//lib/haml_lint/utils.rb#37
    def get_abs_and_rel_path(path); end

    # Calls a block of code with a modified set of environment variables,
    # restoring them once the code has executed.
    #
    # @param env [Hash] environment variables to set
    #
    # source://haml_lint//lib/haml_lint/utils.rb#143
    def with_environment(env); end
  end
end

# source://haml_lint//lib/haml_lint/version.rb#5
HamlLint::VERSION = T.let(T.unsafe(nil), String)
